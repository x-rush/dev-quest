# Next.js 15 SaaSå¹³å°å¼€å‘å®æˆ˜

> é€šè¿‡æ„å»ºä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„ä¼ä¸šçº§SaaSå¹³å°ï¼ŒæŒæ¡ç°ä»£SaaSåº”ç”¨å¼€å‘çš„æ ¸å¿ƒæŠ€æœ¯å’Œå•†ä¸šæ¨¡å¼ã€‚æœ¬é¡¹ç›®æ¶µç›–å¤šç§Ÿæˆ·æ¶æ„ã€è®¢é˜…è®¡è´¹ã€ç”¨æˆ·ç®¡ç†ã€APIé›†æˆã€å®æ—¶åä½œç­‰ä¼ä¸šçº§SaaSç³»ç»Ÿçš„å…³é”®åŠŸèƒ½ã€‚

**ç›®æ ‡è¯»è€…**: æœ‰Next.jså’Œå…¨æ ˆå¼€å‘åŸºç¡€ï¼Œå¸Œæœ›å­¦ä¹ ä¼ä¸šçº§SaaSå¹³å°å¼€å‘çš„å¼€å‘è€…
**å‰ç½®çŸ¥è¯†**: Next.jsåŸºç¡€ã€æ•°æ®åº“è®¾è®¡ã€APIå¼€å‘ã€è®¤è¯æˆæƒã€åŸºç¡€ä¸šåŠ¡é€»è¾‘
**é¢„è®¡æ—¶é•¿**: 4-6å‘¨

## ğŸ“š æ–‡æ¡£å…ƒæ•°æ®
| å±æ€§ | å†…å®¹ |
|------|------|
| **æ¨¡å—** | `02-nextjs-frontend` |
| **åˆ†ç±»** | `projects` |
| **éš¾åº¦** | â­â­â­â­â­ (5/5æ˜Ÿ) |
| **æ ‡ç­¾** | `Next.js 15` `React 19` `TypeScript 5` `SaaS` `å¤šç§Ÿæˆ·` `è®¢é˜…è®¡è´¹` `Stripe Billing` |
| **æ›´æ–°æ—¥æœŸ** | `2025å¹´10æœˆ` |
| **ä½œè€…** | Dev Quest Team |
| **çŠ¶æ€** | âœ… å·²å®Œæˆ |

## ğŸ¯ å­¦ä¹ ç›®æ ‡
- æ„å»ºå¤šç§Ÿæˆ·SaaSå¹³å°æ¶æ„
- å®ç°å®Œæ•´çš„ç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†ç³»ç»Ÿ
- å¼€å‘è®¢é˜…è®¡è´¹å’ŒStripeé›†æˆ
- æŒæ¡å¤šç§Ÿæˆ·æ•°æ®éš”ç¦»å’Œå®‰å…¨
- å®ç°å®æ—¶åä½œå’Œé€šçŸ¥ç³»ç»Ÿ
- å¼€å‘å¯å®šåˆ¶çš„ç™½æ ‡è§£å†³æ–¹æ¡ˆ
- æŒæ¡SaaSä¸šåŠ¡çš„ç›‘æ§å’Œåˆ†æ
- éƒ¨ç½²å’Œæ‰©å±•ç”Ÿäº§çº§SaaSåº”ç”¨

## ğŸ“– é¡¹ç›®æ¦‚è¿°

### é¡¹ç›®èƒŒæ™¯
SaaSï¼ˆSoftware as a Serviceï¼‰æ˜¯ç°ä»£è½¯ä»¶è¡Œä¸šçš„é‡è¦å•†ä¸šæ¨¡å¼ï¼Œéœ€è¦å¤„ç†å¤æ‚çš„ä¸šåŠ¡é€»è¾‘ã€å¤šç§Ÿæˆ·æ¶æ„ã€è®¢é˜…è®¡è´¹ã€å®‰å…¨éš”ç¦»ç­‰æŒ‘æˆ˜ã€‚æœ¬é¡¹ç›®å°†æ„å»ºä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„ä¼ä¸šçº§SaaSå¹³å°ã€‚

### æ ¸å¿ƒåŠŸèƒ½
- ğŸ¢ å¤šç§Ÿæˆ·æ¶æ„å’Œæ•°æ®éš”ç¦»
- ğŸ‘¥ å®Œæ•´çš„ç”¨æˆ·ç®¡ç†å’Œæƒé™ç³»ç»Ÿ
- ğŸ’³ è®¢é˜…è®¡è´¹å’ŒStripeé›†æˆ
- ğŸ¨ ç™½æ ‡å’Œå“ç‰Œå®šåˆ¶
- ğŸ”„ å®æ—¶åä½œå’ŒWebSocketé€šä¿¡
- ğŸ“Š ä¸šåŠ¡åˆ†æå’ŒæŠ¥è¡¨ç³»ç»Ÿ
- ğŸ” ä¼ä¸šçº§å®‰å…¨å’Œåˆè§„
- ğŸ“± å“åº”å¼å’Œç§»åŠ¨ç«¯é€‚é…
- ğŸ”Œ APIé›†æˆå’Œç¬¬ä¸‰æ–¹æœåŠ¡
- ğŸ“§ é‚®ä»¶é€šçŸ¥å’Œè‡ªåŠ¨åŒ–

### æŠ€æœ¯æ ˆ
- **å‰ç«¯æ¡†æ¶**: Next.js 15 + React 19
- **å¼€å‘è¯­è¨€**: TypeScript 5
- **UIç»„ä»¶åº“**: Shadcn/ui + Tailwind CSS
- **çŠ¶æ€ç®¡ç†**: Zustand + React Query
- **æ•°æ®åº“**: PostgreSQL + Prisma ORM
- **è®¤è¯**: NextAuth.js v5 + å¤šç§Ÿæˆ·é€‚é…
- **æ”¯ä»˜ç³»ç»Ÿ**: Stripe + Stripe Billing
- **å®æ—¶é€šä¿¡**: Socket.io + Redis
- **é‚®ä»¶æœåŠ¡**: Resend + React Email
- **æ–‡ä»¶å­˜å‚¨**: AWS S3/Cloudinary
- **ç›‘æ§**: Sentry + LogRocket
- **éƒ¨ç½²**: Vercel + Railway + Supabase

## ğŸ—ï¸ é¡¹ç›®æ¶æ„

### ç›®å½•ç»“æ„
```
saas-platform/
â”œâ”€â”€ app/                          # App Routerç›®å½•
â”‚   â”œâ”€â”€ (auth)/                   # è®¤è¯è·¯ç”±ç»„
â”‚   â”‚   â”œâ”€â”€ login/               # ç™»å½•é¡µé¢
â”‚   â”‚   â”œâ”€â”€ register/            # æ³¨å†Œé¡µé¢
â”‚   â”‚   â”œâ”€â”€ verify-email/        # é‚®ç®±éªŒè¯
â”‚   â”‚   â”œâ”€â”€ forgot-password/     # å¿˜è®°å¯†ç 
â”‚   â”‚   â””â”€â”€ layout.tsx           # è®¤è¯å¸ƒå±€
â”‚   â”œâ”€â”€ (app)/                   # åº”ç”¨è·¯ç”±ç»„
â”‚   â”‚   â”œâ”€â”€ dashboard/           # ä»ªè¡¨æ¿
â”‚   â”‚   â”œâ”€â”€ settings/            # è®¾ç½®é¡µé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ profile/         # ä¸ªäººèµ„æ–™
â”‚   â”‚   â”‚   â”œâ”€â”€ billing/         # è®¡è´¹ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ team/            # å›¢é˜Ÿç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ integrations/    # é›†æˆç®¡ç†
â”‚   â”‚   â”‚   â””â”€â”€ branding/        # å“ç‰Œå®šåˆ¶
â”‚   â”‚   â”œâ”€â”€ admin/               # ç®¡ç†åå°
â”‚   â”‚   â”‚   â”œâ”€â”€ tenants/         # ç§Ÿæˆ·ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ users/           # ç”¨æˆ·ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ subscriptions/   # è®¢é˜…ç®¡ç†
â”‚   â”‚   â”‚   â””â”€â”€ analytics/       # å¹³å°åˆ†æ
â”‚   â”‚   â””â”€â”€ layout.tsx           # åº”ç”¨å¸ƒå±€
â”‚   â”œâ”€â”€ api/                     # APIè·¯ç”±
â”‚   â”‚   â”œâ”€â”€ auth/                # è®¤è¯API
â”‚   â”‚   â”œâ”€â”€ tenants/             # ç§Ÿæˆ·API
â”‚   â”‚   â”œâ”€â”€ users/               # ç”¨æˆ·API
â”‚   â”‚   â”œâ”€â”€ subscriptions/       # è®¢é˜…API
â”‚   â”‚   â”œâ”€â”€ billing/             # è®¡è´¹API
â”‚   â”‚   â”œâ”€â”€ webhooks/            # Webhookå¤„ç†
â”‚   â”‚   â””â”€â”€ admin/               # ç®¡ç†API
â”‚   â”œâ”€â”€ billing/                 # è®¡è´¹é¡µé¢
â”‚   â”‚   â”œâ”€â”€ checkout/            # ç»“è´¦é¡µé¢
â”‚   â”‚   â”œâ”€â”€ success/             # æ”¯ä»˜æˆåŠŸ
â”‚   â”‚   â””â”€â”€ cancelled/           # æ”¯ä»˜å–æ¶ˆ
â”‚   â”œâ”€â”€ invite/                  # é‚€è¯·é¡µé¢
â”‚   â”œâ”€â”€ globals.css              # å…¨å±€æ ·å¼
â”‚   â”œâ”€â”€ layout.tsx               # æ ¹å¸ƒå±€
â”‚   â””â”€â”€ page.tsx                 # é¦–é¡µ
â”œâ”€â”€ components/                  # ç»„ä»¶åº“
â”‚   â”œâ”€â”€ ui/                      # UIåŸºç¡€ç»„ä»¶
â”‚   â”œâ”€â”€ auth/                    # è®¤è¯ç»„ä»¶
â”‚   â”œâ”€â”€ billing/                 # è®¡è´¹ç»„ä»¶
â”‚   â”œâ”€â”€ dashboard/               # ä»ªè¡¨æ¿ç»„ä»¶
â”‚   â”œâ”€â”€ settings/                # è®¾ç½®ç»„ä»¶
â”‚   â”œâ”€â”€ admin/                   # ç®¡ç†ç»„ä»¶
â”‚   â”œâ”€â”€ layout/                  # å¸ƒå±€ç»„ä»¶
â”‚   â””â”€â”€ forms/                   # è¡¨å•ç»„ä»¶
â”œâ”€â”€ lib/                         # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ auth/                    # è®¤è¯é…ç½®
â”‚   â”œâ”€â”€ db/                      # æ•°æ®åº“é…ç½®
â”‚   â”œâ”€â”€ billing/                 # è®¡è´¹å¤„ç†
â”‚   â”œâ”€â”€ email/                   # é‚®ä»¶æœåŠ¡
â”‚   â”œâ”€â”€ tenants/                 # ç§Ÿæˆ·ç®¡ç†
â”‚   â”œâ”€â”€ permissions/             # æƒé™æ§åˆ¶
â”‚   â”œâ”€â”€ notifications/           # é€šçŸ¥æœåŠ¡
â”‚   â””â”€â”€ utils/                   # é€šç”¨å·¥å…·
â”œâ”€â”€ hooks/                       # è‡ªå®šä¹‰Hooks
â”œâ”€â”€ store/                       # çŠ¶æ€ç®¡ç†
â”œâ”€â”€ types/                       # TypeScriptç±»å‹
â”œâ”€â”€ prisma/                      # Prismaé…ç½®
â”‚   â”œâ”€â”€ schema.prisma           # æ•°æ®åº“æ¨¡å‹
â”‚   â”œâ”€â”€ migrations/             # æ•°æ®åº“è¿ç§»
â”‚   â””â”€â”€ seed.ts                 # ç§å­æ•°æ®
â”œâ”€â”€ emails/                      # é‚®ä»¶æ¨¡æ¿
â”œâ”€â”€ public/                     # é™æ€èµ„æº
â””â”€â”€ middleware.ts              # ä¸­é—´ä»¶
```

### å¤šç§Ÿæˆ·æ•°æ®åº“è®¾è®¡
```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// å¹³å°çº§æ¨¡å‹ï¼ˆå…¨å±€æ•°æ®ï¼‰
model Platform {
  id              String   @id @default(cuid())
  name            String
  domain          String   @unique
  settings        Json     @default("{}")
  stripeAccountId String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // å…³è”
  tenants         Tenant[]
  plans           Plan[]
  platformUsers   PlatformUser[]

  @@map("platforms")
}

model Plan {
  id           String      @id @default(cuid())
  platformId   String
  platform     Platform    @relation(fields: [platformId], references: [id])
  name         String
  description  String?
  price        Float
  currency     String      @default("USD")
  interval     BillingInterval
  features     Json        @default("[]")
  stripePriceId String?
  isActive     Boolean     @default(true)
  sortOrder    Int         @default(0)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  // å…³è”
  subscriptions Subscription[]

  @@map("plans")
}

model PlatformUser {
  id            String    @id @default(cuid())
  platformId    String
  platform      Platform  @relation(fields: [platformId], references: [id])
  email         String
  name          String
  role          PlatformRole @default(USER)
  isActive      Boolean   @default(true)
  lastLoginAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([platformId, email])
  @@map("platform_users")
}

// ç§Ÿæˆ·çº§æ¨¡å‹ï¼ˆæ¯ä¸ªç§Ÿæˆ·çš„æ•°æ®ï¼‰
model Tenant {
  id            String   @id @default(cuid())
  platformId    String
  platform      Platform @relation(fields: [platformId], references: [id])
  name          String
  slug          String
  domain        String?
  subdomain     String?
  settings      Json     @default("{}")
  branding      Json     @default("{}")
  status        TenantStatus @default(ACTIVE)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // å…³è”
  users         User[]
  subscriptions Subscription[]
  invitations   Invitation[]
  projects      Project[]
  auditLogs     AuditLog[]

  @@unique([platformId, slug])
  @@map("tenants")
}

model User {
  id            String    @id @default(cuid())
  tenantId      String
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  platformUserId String
  email         String
  name          String
  avatar        String?
  role          UserRole  @default(MEMBER)
  status        UserStatus @default(ACTIVE)
  lastLoginAt   DateTime?
  emailVerified Boolean   @default(false)
  twoFactorEnabled Boolean @default(false)
  twoFactorSecret String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // å…³è”
  sessions      Session[]
  invitations   Invitation[]
  projectMemberships ProjectMembership[]
  auditLogs     AuditLog[]
  notifications Notification[]

  @@unique([tenantId, email])
  @@map("users")
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token        String   @unique
  refreshToken String?  @unique
  expiresAt    DateTime
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  @@map("sessions")
}

model Subscription {
  id             String           @id @default(cuid())
  tenantId       String
  tenant         Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  planId         String
  plan           Plan             @relation(fields: [planId], references: [id])
  stripeSubscriptionId String?   @unique
  status         SubscriptionStatus @default(TRIALING)
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  cancelAtPeriodEnd  Boolean   @default(false)
  canceledAt          DateTime?
  trialEnd            DateTime?
  metadata           Json?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@map("subscriptions")
}

model Invitation {
  id           String          @id @default(cuid())
  tenantId     String
  tenant       Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  inviterId    String
  inviter      User            @relation(fields: [inviterId], references: [id])
  email        String
  role         UserRole        @default(MEMBER)
  token        String          @unique
  expiresAt    DateTime
  acceptedAt   DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  @@map("invitations")
}

model Project {
  id          String   @id @default(cuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name        String
  description String?
  status      ProjectStatus @default(ACTIVE)
  settings    Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // å…³è”
  members     ProjectMembership[]

  @@map("projects")
}

model ProjectMembership {
  id        String   @id @default(cuid())
  projectId String
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  role      ProjectRole @default(MEMBER)
  joinedAt  DateTime @default(now())

  @@unique([projectId, userId])
  @@map("project_memberships")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  content   String
  metadata  Json?
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  @@map("notifications")
}

model AuditLog {
  id        String       @id @default(cuid())
  tenantId  String
  tenant    Tenant       @relation(fields: [tenantId], references: [id])
  userId    String?
  user      User?        @relation(fields: [userId], references: [id])
  action    AuditAction
  resource  String       // èµ„æºç±»å‹
  resourceId String?    // èµ„æºID
  oldValues Json?        // ä¿®æ”¹å‰çš„å€¼
  newValues Json?        // ä¿®æ”¹åçš„å€¼
  ipAddress String?
  userAgent String?
  createdAt DateTime     @default(now())

  @@map("audit_logs")
}

// æšä¸¾ç±»å‹
enum PlatformRole {
  OWNER
  ADMIN
  USER
}

enum UserRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

enum ProjectRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

enum TenantStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum ProjectStatus {
  ACTIVE
  ARCHIVED
  DELETED
}

enum BillingInterval {
  MONTH
  YEAR
}

enum SubscriptionStatus {
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
}

enum NotificationType {
  SYSTEM
  BILLING
  PROJECT
  INVITATION
  SECURITY
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  ACCESS
}
```

## ğŸ› ï¸ å®æˆ˜æ­¥éª¤

### æ­¥éª¤ä¸€ï¼šé¡¹ç›®åˆå§‹åŒ–

#### 1.1 åˆ›å»ºNext.jsé¡¹ç›®
```bash
# åˆ›å»ºNext.js 15é¡¹ç›®
npx create-next-app@latest saas-platform --typescript --tailwind --eslint --app

# è¿›å…¥é¡¹ç›®ç›®å½•
cd saas-platform

# å®‰è£…å¿…è¦ä¾èµ–
npm install @prisma/client prisma
npm install @auth/prisma-adapter next-auth
npm install @radix-ui/react-dialog @radix-ui/react-dropdown-menu
npm install @radix-ui/react-select @radix-ui/react-tabs
npm install @radix-ui/react-toast @radix-ui/react-avatar
npm install @hookform/resolvers react-hook-form zod
npm install @tanstack/react-query zustand
npm install stripe @types/stripe
npm install socket.io socket.io-client
npm install resend react-email @react-email/components
npm install lucide-react clsx tailwind-merge
npm install bcryptjs @types/bcryptjs
npm install nanoid @types/nanoid
npm install qrcode @types/qrcode
npm install date-fns lodash @types/lodash

# å®‰è£…å¼€å‘ä¾èµ–
npm install -D @tailwindcss/typography
npm install -D eslint-config-prettier prettier
npm install -D prisma-dbml-generator
```

#### 1.2 é…ç½®å¤šç§Ÿæˆ·Prisma
**lib/db/tenant-prisma.ts**:
```typescript
import { PrismaClient } from '@prisma/client'

// å…¨å±€Prismaå®¢æˆ·ç«¯ï¼ˆç”¨äºå¹³å°çº§æ“ä½œï¼‰
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

// ç§Ÿæˆ·ç‰¹å®šçš„Prismaå®¢æˆ·ç«¯
const tenantPrismaClients = new Map<string, PrismaClient>()

export function getTenantPrisma(tenantId: string): PrismaClient {
  if (!tenantPrismaClients.has(tenantId)) {
    // ä¸ºæ¯ä¸ªç§Ÿæˆ·åˆ›å»ºç‹¬ç«‹çš„æ•°æ®åº“è¿æ¥æˆ–schema
    const client = new PrismaClient({
      datasources: {
        db: {
          url: `${process.env.DATABASE_URL}?schema=tenant_${tenantId}`,
        },
      },
    })

    tenantPrismaClients.set(tenantId, client)
  }

  return tenantPrismaClients.get(tenantId)!
}

// æ¸…ç†ç§Ÿæˆ·å®¢æˆ·ç«¯è¿æ¥
export function cleanupTenantPrisma(tenantId: string): void {
  const client = tenantPrismaClients.get(tenantId)
  if (client) {
    client.$disconnect()
    tenantPrismaClients.delete(tenantId)
  }
}

// ç§Ÿæˆ·æ•°æ®åº“æ“ä½œåŒ…è£…å™¨
export class TenantDB {
  constructor(private tenantId: string) {}

  get prisma() {
    return getTenantPrisma(this.tenantId)
  }

  // äº‹åŠ¡æ”¯æŒ
  async transaction<T>(callback: (tx: PrismaClient) => Promise<T>): Promise<T> {
    const client = this.prisma
    return client.$transaction(callback)
  }

  // å¥åº·æ£€æŸ¥
  async healthCheck(): Promise<boolean> {
    try {
      await this.prisma.$queryRaw`SELECT 1`
      return true
    } catch (error) {
      console.error('Tenant database health check failed:', error)
      return false
    }
  }

  // è¿ç§»æ£€æŸ¥
  async checkMigrations(): Promise<boolean> {
    try {
      // æ£€æŸ¥å¿…è¦çš„è¡¨æ˜¯å¦å­˜åœ¨
      await this.prisma.user.findFirst()
      return true
    } catch (error) {
      console.error('Tenant migration check failed:', error)
      return false
    }
  }
}
```

#### 1.3 å®ç°å¤šç§Ÿæˆ·ä¸­é—´ä»¶
**middleware.ts**:
```typescript
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { getToken } from 'next-auth/jwt'
import { prisma } from '@/lib/db/prisma'

export async function middleware(request: NextRequest) {
  const token = await getToken({ req: request })
  const { pathname, host } = request.nextUrl

  // è·³è¿‡é™æ€èµ„æºå’Œéè®¤è¯è·¯ç”±
  if (
    pathname.startsWith('/_next') ||
    pathname.startsWith('/api/auth') ||
    pathname.startsWith('/login') ||
    pathname.startsWith('/register') ||
    pathname.startsWith('/billing') ||
    pathname.startsWith('/invite')
  ) {
    return NextResponse.next()
  }

  // ä»å­åŸŸåæˆ–è·¯å¾„ä¸­æå–ç§Ÿæˆ·ä¿¡æ¯
  const hostname = host.split('.')[0]
  const pathSegments = pathname.split('/').filter(Boolean)

  let tenantSlug: string | null = null

  // æ–¹æ³•1: å­åŸŸåæ¨¡å¼ (tenant.domain.com)
  if (hostname !== 'localhost' && hostname !== 'www') {
    tenantSlug = hostname
  }

  // æ–¹æ³•2: è·¯å¾„æ¨¡å¼ (domain.com/tenant/...)
  if (!tenantSlug && pathSegments.length > 0 && pathSegments[0] !== 'app') {
    tenantSlug = pathSegments[0]
  }

  // å¦‚æœæ˜¯åº”ç”¨è·¯ç”±ä½†æ²¡æœ‰ç§Ÿæˆ·ä¿¡æ¯ï¼Œé‡å®šå‘åˆ°ç™»å½•
  if (pathname.startsWith('/app') && !tenantSlug) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // å¦‚æœæœ‰ç§Ÿæˆ·ä¿¡æ¯ï¼ŒéªŒè¯ç§Ÿæˆ·å’Œç”¨æˆ·æƒé™
  if (tenantSlug) {
    try {
      const tenant = await prisma.tenant.findUnique({
        where: { slug: tenantSlug },
        include: {
          users: {
            where: {
              platformUserId: token?.sub,
            },
          },
        },
      })

      if (!tenant) {
        return NextResponse.redirect(new URL('/login', request.url))
      }

      if (tenant.status !== 'ACTIVE') {
        return NextResponse.redirect(new URL('/suspended', request.url))
      }

      // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æ­¤ç§Ÿæˆ·
      if (!token || tenant.users.length === 0) {
        return NextResponse.redirect(new URL('/login', request.url))
      }

      const user = tenant.users[0]
      if (user.status !== 'ACTIVE') {
        return NextResponse.redirect(new URL('/login', request.url))
      }

      // æ£€æŸ¥è®¢é˜…çŠ¶æ€
      const subscription = await prisma.subscription.findFirst({
        where: {
          tenantId: tenant.id,
          status: {
            in: ['ACTIVE', 'TRIALING'],
          },
        },
        orderBy: { createdAt: 'desc' },
      })

      if (!subscription) {
        // é‡å®šå‘åˆ°è®¡è´¹é¡µé¢
        return NextResponse.redirect(new URL('/billing', request.url))
      }

      // åœ¨å“åº”å¤´ä¸­æ·»åŠ ç§Ÿæˆ·ä¿¡æ¯
      const response = NextResponse.next()
      response.headers.set('x-tenant-id', tenant.id)
      response.headers.set('x-user-id', user.id)
      response.headers.set('x-user-role', user.role)

      return response
    } catch (error) {
      console.error('Middleware error:', error)
      return NextResponse.redirect(new URL('/login', request.url))
    }
  }

  return NextResponse.next()
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public (public files)
     */
    '/((?!api|_next/static|_next/image|favicon.ico|public).*)',
  ],
}
```

### æ­¥éª¤äºŒï¼šæ ¸å¿ƒåŠŸèƒ½å¼€å‘

#### 2.1 å®ç°å¤šç§Ÿæˆ·è®¤è¯ç³»ç»Ÿ
**lib/auth/multi-tenant-adapter.ts**:
```typescript
import { Adapter } from 'next-auth/adapters'
import { prisma } from '@/lib/db/prisma'
import { getTenantPrisma } from '@/lib/db/tenant-prisma'

export function MultiTenantAdapter(tenantId?: string): Adapter {
  return {
    async createUser(user) {
      if (!tenantId) {
        throw new Error('Tenant ID is required for user creation')
      }

      const tenantDb = getTenantPrisma(tenantId)

      // é¦–å…ˆåˆ›å»ºå¹³å°ç”¨æˆ·ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
      const platformUser = await prisma.platformUser.findUnique({
        where: { email: user.email },
      })

      if (!platformUser) {
        await prisma.platformUser.create({
          data: {
            email: user.email,
            name: user.name || '',
            role: 'USER',
          },
        })
      }

      // åˆ›å»ºç§Ÿæˆ·ç”¨æˆ·
      const tenantUser = await tenantDb.user.create({
        data: {
          email: user.email,
          name: user.name || '',
          platformUserId: platformUser?.id || '',
        },
      })

      return {
        id: tenantUser.id,
        email: tenantUser.email,
        name: tenantUser.name,
        emailVerified: tenantUser.emailVerified ? new Date() : null,
      }
    },

    async getUser(id) {
      if (!tenantId) return null

      const tenantDb = getTenantPrisma(tenantId)
      const user = await tenantDb.user.findUnique({
        where: { id },
      })

      if (!user) return null

      return {
        id: user.id,
        email: user.email,
        name: user.name,
        emailVerified: user.emailVerified ? new Date() : null,
      }
    },

    async getUserByEmail(email) {
      if (!tenantId) return null

      const tenantDb = getTenantPrisma(tenantId)
      const user = await tenantDb.user.findUnique({
        where: { email },
      })

      if (!user) return null

      return {
        id: user.id,
        email: user.email,
        name: user.name,
        emailVerified: user.emailVerified ? new Date() : null,
      }
    },

    async getUserByAccount({ providerAccountId, provider }) {
      if (!tenantId) return null

      const tenantDb = getTenantPrisma(tenantId)
      const account = await tenantDb.account.findUnique({
        where: {
          provider_providerAccountId: {
            provider,
            providerAccountId,
          },
        },
        include: {
          user: true,
        },
      })

      if (!account) return null

      return {
        id: account.user.id,
        email: account.user.email,
        name: account.user.name,
        emailVerified: account.user.emailVerified ? new Date() : null,
      }
    },

    async updateUser(user) {
      if (!tenantId) throw new Error('Tenant ID is required')

      const tenantDb = getTenantPrisma(tenantId)
      const updatedUser = await tenantDb.user.update({
        where: { id: user.id },
        data: {
          name: user.name || '',
          emailVerified: user.emailVerified?.toISOString() || null,
        },
      })

      return {
        id: updatedUser.id,
        email: updatedUser.email,
        name: updatedUser.name,
        emailVerified: updatedUser.emailVerified ? new Date() : null,
      }
    },

    async deleteUser(userId) {
      if (!tenantId) return

      const tenantDb = getTenantPrisma(tenantId)
      await tenantDb.user.delete({
        where: { id: userId },
      })
    },

    async linkAccount(account) {
      if (!tenantId) throw new Error('Tenant ID is required')

      const tenantDb = getTenantPrisma(tenantId)
      await tenantDb.account.create({
        data: {
          userId: account.userId,
          type: account.type,
          provider: account.provider,
          providerAccountId: account.providerAccountId,
          refresh_token: account.refresh_token,
          access_token: account.access_token,
          expires_at: account.expires_at,
          token_type: account.token_type,
          scope: account.scope,
          id_token: account.id_token,
          session_state: account.session_state,
        },
      })
    },

    async unlinkAccount({ providerAccountId, provider }) {
      if (!tenantId) return

      const tenantDb = getTenantPrisma(tenantId)
      await tenantDb.account.delete({
        where: {
          provider_providerAccountId: {
            provider,
            providerAccountId,
          },
        },
      })
    },

    async createSession({ sessionToken, userId, expires }) {
      if (!tenantId) throw new Error('Tenant ID is required')

      const tenantDb = getTenantPrisma(tenantId)
      const session = await tenantDb.session.create({
        data: {
          token: sessionToken,
          userId,
          expiresAt: expires,
        },
      })

      return {
        sessionToken: session.token,
        userId: session.userId,
        expires: session.expiresAt,
      }
    },

    async getSessionAndUser(sessionToken) {
      if (!tenantId) return null

      const tenantDb = getTenantPrisma(tenantId)
      const session = await tenantDb.session.findUnique({
        where: { token: sessionToken },
        include: {
          user: true,
        },
      })

      if (!session) return null

      return {
        session: {
          sessionToken: session.token,
          userId: session.userId,
          expires: session.expiresAt,
        },
        user: {
          id: session.user.id,
          email: session.user.email,
          name: session.user.name,
          emailVerified: session.user.emailVerified ? new Date() : null,
        },
      }
    },

    async updateSession({ sessionToken, userId, expires }) {
      if (!tenantId) throw new Error('Tenant ID is required')

      const tenantDb = getTenantPrisma(tenantId)
      const session = await tenantDb.session.update({
        where: { token: sessionToken },
        data: {
          userId,
          expiresAt: expires,
        },
      })

      return {
        sessionToken: session.token,
        userId: session.userId,
        expires: session.expiresAt,
      }
    },

    async deleteSession(sessionToken) {
      if (!tenantId) return

      const tenantDb = getTenantPrisma(tenantId)
      await tenantDb.session.delete({
        where: { token: sessionToken },
      })
    },
  }
}
```

#### 2.2 å®ç°è®¢é˜…è®¡è´¹ç³»ç»Ÿ
**lib/billing/subscription-service.ts**:
```typescript
import { prisma } from '@/lib/db/prisma'
import { stripe } from '@/lib/billing/stripe'
import { getTenantPrisma } from '@/lib/db/tenant-prisma'

export interface CreateSubscriptionParams {
  tenantId: string
  planId: string
  paymentMethodId?: string
  trialDays?: number
  couponCode?: string
}

export interface UpdateSubscriptionParams {
  subscriptionId: string
  planId?: string
  quantity?: number
  metadata?: Record<string, string>
}

export class SubscriptionService {
  /**
   * åˆ›å»ºè®¢é˜…
   */
  static async createSubscription(params: CreateSubscriptionParams) {
    const { tenantId, planId, paymentMethodId, trialDays, couponCode } = params

    // è·å–ç§Ÿæˆ·å’Œè®¡åˆ’ä¿¡æ¯
    const [tenant, plan] = await Promise.all([
      prisma.tenant.findUnique({ where: { id: tenantId } }),
      prisma.plan.findUnique({ where: { id: planId } }),
    ])

    if (!tenant || !plan) {
      throw new Error('Tenant or plan not found')
    }

    // æ£€æŸ¥æ˜¯å¦å·²æœ‰æ´»è·ƒè®¢é˜…
    const existingSubscription = await prisma.subscription.findFirst({
      where: {
        tenantId,
        status: {
          in: ['TRIALING', 'ACTIVE'],
        },
      },
    })

    if (existingSubscription) {
      throw new Error('Tenant already has an active subscription')
    }

    // åˆ›å»ºStripeè®¢é˜…
    const stripeSubscriptionParams: any = {
      customer: tenant.stripeCustomerId || await this.createStripeCustomer(tenant),
      items: [{ price: plan.stripePriceId }],
      payment_behavior: 'default_incomplete',
      payment_settings: {
        save_default_payment_method: 'on_subscription',
      },
      expand: ['latest_invoice.payment_intent'],
    }

    // æ·»åŠ è¯•ç”¨æœŸ
    if (trialDays) {
      stripeSubscriptionParams.trial_period_days = trialDays
    }

    // æ·»åŠ ä¼˜æƒ åˆ¸
    if (couponCode) {
      const coupon = await stripe.coupons.retrieve(couponCode)
      stripeSubscriptionParams.coupon = coupon.id
    }

    // æ·»åŠ æ”¯ä»˜æ–¹å¼
    if (paymentMethodId) {
      stripeSubscriptionParams.default_payment_method = paymentMethodId
    }

    const stripeSubscription = await stripe.subscriptions.create(stripeSubscriptionParams)

    // ä¿å­˜è®¢é˜…åˆ°æ•°æ®åº“
    const subscription = await prisma.subscription.create({
      data: {
        tenantId,
        planId,
        stripeSubscriptionId: stripeSubscription.id,
        status: this.mapStripeStatus(stripeSubscription.status),
        currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),
        currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),
        trialEnd: stripeSubscription.trial_end
          ? new Date(stripeSubscription.trial_end * 1000)
          : null,
        metadata: stripeSubscription.metadata,
      },
      include: {
        plan: true,
        tenant: true,
      },
    })

    // æ›´æ–°ç§Ÿæˆ·çš„Stripeå®¢æˆ·ID
    if (!tenant.stripeCustomerId) {
      await prisma.tenant.update({
        where: { id: tenantId },
        data: { stripeCustomerId: stripeSubscription.customer as string },
      })
    }

    return {
      subscription,
      clientSecret: (stripeSubscription.latest_invoice as any)?.payment_intent?.client_secret,
    }
  }

  /**
   * æ›´æ–°è®¢é˜…
   */
  static async updateSubscription(params: UpdateSubscriptionParams) {
    const { subscriptionId, planId, quantity, metadata } = params

    // è·å–æ•°æ®åº“ä¸­çš„è®¢é˜…
    const subscription = await prisma.subscription.findUnique({
      where: { id: subscriptionId },
      include: { plan: true },
    })

    if (!subscription) {
      throw new Error('Subscription not found')
    }

    // æ›´æ–°Stripeè®¢é˜…
    const stripeSubscription = await stripe.subscriptions.retrieve(
      subscription.stripeSubscriptionId!
    )

    const updateParams: any = {}

    if (planId && planId !== subscription.planId) {
      const newPlan = await prisma.plan.findUnique({ where: { id: planId } })
      if (!newPlan) {
        throw new Error('New plan not found')
      }

      updateParams.items = [{
        id: stripeSubscription.items.data[0].id,
        price: newPlan.stripePriceId,
      }]
    }

    if (quantity !== undefined) {
      updateParams.quantity = quantity
    }

    if (metadata) {
      updateParams.metadata = { ...stripeSubscription.metadata, ...metadata }
    }

    const updatedStripeSubscription = await stripe.subscriptions.update(
      subscription.stripeSubscriptionId!,
      updateParams
    )

    // æ›´æ–°æ•°æ®åº“ä¸­çš„è®¢é˜…
    const updatedSubscription = await prisma.subscription.update({
      where: { id: subscriptionId },
      data: {
        planId: planId || subscription.planId,
        status: this.mapStripeStatus(updatedStripeSubscription.status),
        currentPeriodStart: new Date(updatedStripeSubscription.current_period_start * 1000),
        currentPeriodEnd: new Date(updatedStripeSubscription.current_period_end * 1000),
        metadata: updatedStripeSubscription.metadata,
      },
      include: {
        plan: true,
        tenant: true,
      },
    })

    return updatedSubscription
  }

  /**
   * å–æ¶ˆè®¢é˜…
   */
  static async cancelSubscription(subscriptionId: string, immediate = false) {
    const subscription = await prisma.subscription.findUnique({
      where: { id: subscriptionId },
    })

    if (!subscription) {
      throw new Error('Subscription not found')
    }

    if (immediate) {
      // ç«‹å³å–æ¶ˆ
      await stripe.subscriptions.del(subscription.stripeSubscriptionId!)

      await prisma.subscription.update({
        where: { id: subscriptionId },
        data: {
          status: 'CANCELED',
          canceledAt: new Date(),
        },
      })
    } else {
      // åœ¨æœŸæœ«å–æ¶ˆ
      await stripe.subscriptions.update(subscription.stripeSubscriptionId!, {
        cancel_at_period_end: true,
      })

      await prisma.subscription.update({
        where: { id: subscriptionId },
        data: { cancelAtPeriodEnd: true },
      })
    }

    return true
  }

  /**
   * æ¢å¤è®¢é˜…
   */
  static async resumeSubscription(subscriptionId: string) {
    const subscription = await prisma.subscription.findUnique({
      where: { id: subscriptionId },
    })

    if (!subscription) {
      throw new Error('Subscription not found')
    }

    await stripe.subscriptions.update(subscription.stripeSubscriptionId!, {
      cancel_at_period_end: false,
    })

    await prisma.subscription.update({
      where: { id: subscriptionId },
      data: { cancelAtPeriodEnd: false },
    })

    return true
  }

  /**
   * è·å–è®¢é˜…ä½¿ç”¨æƒ…å†µ
   */
  static async getSubscriptionUsage(subscriptionId: string) {
    const subscription = await prisma.subscription.findUnique({
      where: { id: subscriptionId },
      include: {
        tenant: true,
        plan: true,
      },
    })

    if (!subscription) {
      throw new Error('Subscription not found')
    }

    const tenantDb = getTenantPrisma(subscription.tenantId)

    // æ ¹æ®è®¡åˆ’ç‰¹æ€§è®¡ç®—ä½¿ç”¨æƒ…å†µ
    const usage = {
      users: await tenantDb.user.count({
        where: { status: 'ACTIVE' },
      }),
      projects: await tenantDb.project.count({
        where: { status: 'ACTIVE' },
      }),
      storage: 0, // éœ€è¦å®ç°å­˜å‚¨ç»Ÿè®¡
      apiCalls: 0, // éœ€è¦å®ç°APIè°ƒç”¨ç»Ÿè®¡
    }

    const limits = this.extractPlanLimits(subscription.plan.features)

    return {
      usage,
      limits,
      isOverLimit: Object.keys(limits).some(
        key => usage[key as keyof typeof usage] > limits[key as keyof typeof limits]
      ),
    }
  }

  /**
   * åˆ›å»ºStripeå®¢æˆ·
   */
  private static async createStripeCustomer(tenant: any) {
    const customer = await stripe.customers.create({
      name: tenant.name,
      email: tenant.settings?.email || '',
      metadata: {
        tenantId: tenant.id,
      },
    })

    // æ›´æ–°ç§Ÿæˆ·è®°å½•
    await prisma.tenant.update({
      where: { id: tenant.id },
      data: { stripeCustomerId: customer.id },
    })

    return customer.id
  }

  /**
   * æ˜ å°„StripeçŠ¶æ€åˆ°æœ¬åœ°çŠ¶æ€
   */
  private static mapStripeStatus(stripeStatus: string): SubscriptionStatus {
    const statusMap: Record<string, SubscriptionStatus> = {
      trialing: 'TRIALING',
      active: 'ACTIVE',
      past_due: 'PAST_DUE',
      canceled: 'CANCELED',
      unpaid: 'UNPAID',
      incomplete: 'PAST_DUE',
      incomplete_expired: 'CANCELED',
    }

    return statusMap[stripeStatus] || 'PAST_DUE'
  }

  /**
   * ä»è®¡åˆ’ç‰¹æ€§ä¸­æå–é™åˆ¶
   */
  private static extractPlanLimits(features: any[]) {
    const limits: Record<string, number> = {}

    features.forEach(feature => {
      if (feature.type === 'limit') {
        limits[feature.name] = feature.value
      }
    })

    return limits
  }
}
```

#### 2.3 å®ç°æƒé™æ§åˆ¶ç³»ç»Ÿ
**lib/permissions/rbac.ts**:
```typescript
import { User, UserRole, ProjectRole } from '@prisma/client'

export type Resource =
  | 'dashboard'
  | 'users'
  | 'projects'
  | 'billing'
  | 'settings'
  | 'analytics'
  | 'integrations'
  | 'invitations'

export type Permission =
  | 'read'
  | 'write'
  | 'delete'
  | 'admin'

export interface PermissionRule {
  resource: Resource
  permission: Permission
  condition?: (user: User, context?: any) => boolean
}

// è§’è‰²æƒé™æ˜ å°„
const ROLE_PERMISSIONS: Record<UserRole, PermissionRule[]> = {
  OWNER: [
    // Owneræ‹¥æœ‰æ‰€æœ‰æƒé™
    { resource: 'dashboard', permission: 'read' },
    { resource: 'dashboard', permission: 'write' },
    { resource: 'dashboard', permission: 'delete' },
    { resource: 'users', permission: 'read' },
    { resource: 'users', permission: 'write' },
    { resource: 'users', permission: 'delete' },
    { resource: 'projects', permission: 'read' },
    { resource: 'projects', permission: 'write' },
    { resource: 'projects', permission: 'delete' },
    { resource: 'billing', permission: 'read' },
    { resource: 'billing', permission: 'write' },
    { resource: 'settings', permission: 'read' },
    { resource: 'settings', permission: 'write' },
    { resource: 'analytics', permission: 'read' },
    { resource: 'integrations', permission: 'read' },
    { resource: 'integrations', permission: 'write' },
    { resource: 'invitations', permission: 'read' },
    { resource: 'invitations', permission: 'write' },
    { resource: 'invitations', permission: 'delete' },
  ],
  ADMIN: [
    // Adminæ‹¥æœ‰é™¤billingç®¡ç†å¤–çš„æ‰€æœ‰æƒé™
    { resource: 'dashboard', permission: 'read' },
    { resource: 'dashboard', permission: 'write' },
    { resource: 'users', permission: 'read' },
    { resource: 'users', permission: 'write' },
    { resource: 'projects', permission: 'read' },
    { resource: 'projects', permission: 'write' },
    { resource: 'projects', permission: 'delete' },
    { resource: 'billing', permission: 'read' },
    { resource: 'settings', permission: 'read' },
    { resource: 'settings', permission: 'write' },
    { resource: 'analytics', permission: 'read' },
    { resource: 'integrations', permission: 'read' },
    { resource: 'integrations', permission: 'write' },
    { resource: 'invitations', permission: 'read' },
    { resource: 'invitations', permission: 'write' },
  ],
  MEMBER: [
    // Memberæ‹¥æœ‰åŸºæœ¬æƒé™
    { resource: 'dashboard', permission: 'read' },
    { resource: 'projects', permission: 'read' },
    { resource: 'projects', permission: 'write' },
    { resource: 'settings', permission: 'read' },
  ],
  VIEWER: [
    // Vieweråªæœ‰åªè¯»æƒé™
    { resource: 'dashboard', permission: 'read' },
    { resource: 'projects', permission: 'read' },
  ],
}

// é¡¹ç›®è§’è‰²æƒé™æ˜ å°„
const PROJECT_ROLE_PERMISSIONS: Record<ProjectRole, PermissionRule[]> = {
  OWNER: [
    { resource: 'projects', permission: 'read' },
    { resource: 'projects', permission: 'write' },
    { resource: 'projects', permission: 'delete' },
  ],
  ADMIN: [
    { resource: 'projects', permission: 'read' },
    { resource: 'projects', permission: 'write' },
  ],
  MEMBER: [
    { resource: 'projects', permission: 'read' },
    { resource: 'projects', permission: 'write' },
  ],
  VIEWER: [
    { resource: 'projects', permission: 'read' },
  ],
}

export class RBAC {
  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æŒ‡å®šæƒé™
   */
  static hasPermission(
    user: User,
    resource: Resource,
    permission: Permission,
    context?: any
  ): boolean {
    const userPermissions = ROLE_PERMISSIONS[user.role] || []

    const matchingPermissions = userPermissions.filter(rule =>
      rule.resource === resource && rule.permission === permission
    )

    // å¦‚æœæ²¡æœ‰åŒ¹é…çš„æƒé™è§„åˆ™ï¼Œæ‹’ç»è®¿é—®
    if (matchingPermissions.length === 0) {
      return false
    }

    // æ£€æŸ¥æ¡ä»¶
    return matchingPermissions.every(rule =>
      !rule.condition || rule.condition(user, context)
    )
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰é¡¹ç›®æƒé™
   */
  static hasProjectPermission(
    userRole: ProjectRole,
    resource: Resource,
    permission: Permission,
    context?: any
  ): boolean {
    const projectPermissions = PROJECT_ROLE_PERMISSIONS[userRole] || []

    const matchingPermissions = projectPermissions.filter(rule =>
      rule.resource === resource && rule.permission === permission
    )

    if (matchingPermissions.length === 0) {
      return false
    }

    return matchingPermissions.every(rule =>
      !rule.condition || rule.condition(context)
    )
  }

  /**
   * è·å–ç”¨æˆ·çš„æ‰€æœ‰æƒé™
   */
  static getUserPermissions(user: User): PermissionRule[] {
    return ROLE_PERMISSIONS[user.role] || []
  }

  /**
   * è·å–é¡¹ç›®çš„æ‰€æœ‰æƒé™
   */
  static getProjectPermissions(userRole: ProjectRole): PermissionRule[] {
    return PROJECT_ROLE_PERMISSIONS[userRole] || []
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ä»¥è®¿é—®èµ„æº
   */
  static canAccess(
    user: User,
    resource: Resource,
    action: 'read' | 'write' | 'delete' | 'admin',
    context?: {
      projectId?: string
      userId?: string
      tenantId?: string
    }
  ): boolean {
    // æ£€æŸ¥åŸºæœ¬æƒé™
    if (this.hasPermission(user, resource, action, context)) {
      return true
    }

    // æ£€æŸ¥é¡¹ç›®ç‰¹å®šæƒé™
    if (context?.projectId) {
      // è¿™é‡Œéœ€è¦æŸ¥è¯¢ç”¨æˆ·çš„è§’è‰²
      // å®é™…å®ç°ä¸­åº”è¯¥ä»æ•°æ®åº“è·å–ç”¨æˆ·åœ¨é¡¹ç›®ä¸­çš„è§’è‰²
      return true // ç®€åŒ–å®ç°
    }

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ä»¥è®¿é—®è‡ªå·±çš„èµ„æº
    if (context?.userId === user.id) {
      return resource === 'users' && action === 'read'
    }

    return false
  }

  /**
   * åˆ›å»ºæƒé™ä¸­é—´ä»¶
   */
  static requirePermission(
    resource: Resource,
    permission: Permission,
    context?: any
  ) {
    return (user: User) => {
      return this.hasPermission(user, resource, permission, context)
    }
  }

  /**
   * åˆ›å»ºå¤šä¸ªæƒé™æ£€æŸ¥
   */
  static requireAnyPermission(
    permissions: Array<{ resource: Resource; permission: Permission }>
  ) {
    return (user: User) => {
      return permissions.some(({ resource, permission }) =>
        this.hasPermission(user, resource, permission)
      )
    }
  }

  /**
   * æ£€æŸ¥è®¢é˜…é™åˆ¶
   */
  static checkSubscriptionLimits(
    subscriptionLimits: Record<string, number>,
    currentUsage: Record<string, number>,
    resource: Resource
  ): boolean {
    switch (resource) {
      case 'users':
        return currentUsage.users < subscriptionLimits.users
      case 'projects':
        return currentUsage.projects < subscriptionLimits.projects
      case 'integrations':
        return currentUsage.integrations < subscriptionLimits.integrations
      default:
        return true
    }
  }
}

// æƒé™è£…é¥°å™¨
export function RequirePermission(resource: Resource, permission: Permission) {
  return function (
    target: any,
    propertyName: string,
    descriptor: PropertyDescriptor
  ) {
    const method = descriptor.value

    descriptor.value = async function (...args: any[]) {
      const user = args[0]?.user // å‡è®¾ç¬¬ä¸€ä¸ªå‚æ•°åŒ…å«ç”¨æˆ·ä¿¡æ¯

      if (!user || !RBAC.hasPermission(user, resource, permission)) {
        throw new Error('Insufficient permissions')
      }

      return method.apply(this, args)
    }

    return descriptor
  }
}

// APIæƒé™æ£€æŸ¥ä¸­é—´ä»¶
export function withAuth(
  handler: (req: Request, context: any) => Promise<Response>,
  requiredPermissions?: Array<{ resource: Resource; permission: Permission }>
) {
  return async (req: Request, context: any) => {
    const user = context.user

    if (!user) {
      return new Response('Unauthorized', { status: 401 })
    }

    if (requiredPermissions) {
      const hasPermission = requiredPermissions.some(({ resource, permission }) =>
        RBAC.hasPermission(user, resource, permission, context)
      )

      if (!hasPermission) {
        return new Response('Forbidden', { status: 403 })
      }
    }

    return handler(req, context)
  }
}
```

#### 2.4 å®ç°å®æ—¶é€šçŸ¥ç³»ç»Ÿ
**lib/notifications/notification-service.ts**:
```typescript
import { Server as SocketIOServer } from 'socket.io'
import { Server as HTTPServer } from 'http'
import { getTenantPrisma } from '@/lib/db/tenant-prisma'
import { NotificationType } from '@prisma/client'

export interface NotificationData {
  userId: string
  tenantId: string
  type: NotificationType
  title: string
  content: string
  metadata?: Record<string, any>
}

export interface EmailNotificationData {
  to: string
  subject: string
  template: string
  data: Record<string, any>
}

export class NotificationService {
  private static io: SocketIOServer
  private static connectedUsers = new Map<string, Set<string>>()

  /**
   * åˆå§‹åŒ–Socket.IOæœåŠ¡å™¨
   */
  static initialize(server: HTTPServer) {
    this.io = new SocketIOServer(server, {
      cors: {
        origin: process.env.NODE_ENV === 'production'
          ? process.env.ALLOWED_ORIGINS?.split(',')
          : ['http://localhost:3000'],
        methods: ['GET', 'POST'],
      },
    })

    this.io.on('connection', (socket) => {
      console.log('User connected:', socket.id)

      // ç”¨æˆ·è®¤è¯
      socket.on('authenticate', async (data: { userId: string; tenantId: string; token: string }) => {
        try {
          // è¿™é‡Œåº”è¯¥éªŒè¯token
          const { userId, tenantId } = data

          // å°†socket IDä¸ç”¨æˆ·å…³è”
          if (!this.connectedUsers.has(`${tenantId}:${userId}`)) {
            this.connectedUsers.set(`${tenantId}:${userId}`, new Set())
          }
          this.connectedUsers.get(`${tenantId}:${userId}`)!.add(socket.id)

          // åŠ å…¥ç§Ÿæˆ·æˆ¿é—´
          socket.join(`tenant:${tenantId}`)
          // åŠ å…¥ç”¨æˆ·æˆ¿é—´
          socket.join(`user:${userId}`)

          socket.emit('authenticated', { success: true })

          // å‘é€æœªè¯»é€šçŸ¥
          await this.sendUnreadNotifications(userId, tenantId)
        } catch (error) {
          socket.emit('authenticated', { success: false, error: 'Authentication failed' })
        }
      })

      // å¤„ç†æ–­å¼€è¿æ¥
      socket.on('disconnect', () => {
        console.log('User disconnected:', socket.id)

        // æ¸…ç†è¿æ¥æ˜ å°„
        for (const [key, sockets] of this.connectedUsers.entries()) {
          sockets.delete(socket.id)
          if (sockets.size === 0) {
            this.connectedUsers.delete(key)
          }
        }
      })

      // æ ‡è®°é€šçŸ¥ä¸ºå·²è¯»
      socket.on('mark_notification_read', async (notificationId: string) => {
        try {
          const [tenantId, userId] = this.getUserFromSocket(socket)
          if (tenantId && userId) {
            await this.markNotificationRead(notificationId, tenantId, userId)
            socket.emit('notification_marked_read', { notificationId })
          }
        } catch (error) {
          socket.emit('error', { message: 'Failed to mark notification as read' })
        }
      })

      // è·å–é€šçŸ¥åˆ—è¡¨
      socket.on('get_notifications', async (data: { page?: number; limit?: number }) => {
        try {
          const [tenantId, userId] = this.getUserFromSocket(socket)
          if (tenantId && userId) {
            const notifications = await this.getNotifications(
              userId,
              tenantId,
              data.page || 1,
              data.limit || 20
            )
            socket.emit('notifications', notifications)
          }
        } catch (error) {
          socket.emit('error', { message: 'Failed to get notifications' })
        }
      })
    })
  }

  /**
   * å‘é€å®æ—¶é€šçŸ¥
   */
  static async sendNotification(data: NotificationData) {
    const { userId, tenantId, type, title, content, metadata } = data

    try {
      // ä¿å­˜åˆ°æ•°æ®åº“
      const tenantDb = getTenantPrisma(tenantId)
      const notification = await tenantDb.notification.create({
        data: {
          userId,
          type,
          title,
          content,
          metadata,
        },
      })

      // å‘é€å®æ—¶é€šçŸ¥
      const userSockets = this.connectedUsers.get(`${tenantId}:${userId}`)
      if (userSockets && userSockets.size > 0) {
        this.io.to(`user:${userId}`).emit('notification', {
          id: notification.id,
          type: notification.type,
          title: notification.title,
          content: notification.content,
          metadata: notification.metadata,
          isRead: notification.isRead,
          createdAt: notification.createdAt,
        })
      }

      // å‘é€é‚®ä»¶é€šçŸ¥ï¼ˆå¦‚æœéœ€è¦ï¼‰
      if (this.shouldSendEmail(type)) {
        const user = await tenantDb.user.findUnique({ where: { id: userId } })
        if (user) {
          await this.sendEmailNotification({
            to: user.email,
            subject: title,
            template: this.getEmailTemplate(type),
            data: {
              userName: user.name,
              title,
              content,
              metadata,
            },
          })
        }
      }

      return notification
    } catch (error) {
      console.error('Failed to send notification:', error)
      throw error
    }
  }

  /**
   * å‘é€å¹¿æ’­é€šçŸ¥ï¼ˆç§Ÿæˆ·çº§åˆ«ï¼‰
   */
  static async sendBroadcastNotification(
    tenantId: string,
    data: Omit<NotificationData, 'userId'>
  ) {
    const { type, title, content, metadata } = data

    try {
      // è·å–ç§Ÿæˆ·æ‰€æœ‰ç”¨æˆ·
      const tenantDb = getTenantPrisma(tenantId)
      const users = await tenantDb.user.findMany({
        where: { status: 'ACTIVE' },
      })

      // ä¸ºæ¯ä¸ªç”¨æˆ·åˆ›å»ºé€šçŸ¥
      const notifications = await Promise.all(
        users.map(user =>
          tenantDb.notification.create({
            data: {
              userId: user.id,
              type,
              title,
              content,
              metadata,
            },
          })
        )
      )

      // å‘é€å®æ—¶é€šçŸ¥
      this.io.to(`tenant:${tenantId}`).emit('broadcast_notification', {
        type,
        title,
        content,
        metadata,
        createdAt: new Date(),
      })

      return notifications
    } catch (error) {
      console.error('Failed to send broadcast notification:', error)
      throw error
    }
  }

  /**
   * æ ‡è®°é€šçŸ¥ä¸ºå·²è¯»
   */
  static async markNotificationRead(
    notificationId: string,
    tenantId: string,
    userId: string
  ) {
    const tenantDb = getTenantPrisma(tenantId)

    const notification = await tenantDb.notification.updateMany({
      where: {
        id: notificationId,
        userId,
      },
      data: {
        isRead: true,
      },
    })

    return notification.count > 0
  }

  /**
   * æ ‡è®°æ‰€æœ‰é€šçŸ¥ä¸ºå·²è¯»
   */
  static async markAllNotificationsRead(tenantId: string, userId: string) {
    const tenantDb = getTenantPrisma(tenantId)

    const result = await tenantDb.notification.updateMany({
      where: {
        userId,
        isRead: false,
      },
      data: {
        isRead: true,
      },
    })

    return result.count
  }

  /**
   * è·å–é€šçŸ¥åˆ—è¡¨
   */
  static async getNotifications(
    userId: string,
    tenantId: string,
    page: number = 1,
    limit: number = 20
  ) {
    const tenantDb = getTenantPrisma(tenantId)

    const [notifications, total] = await Promise.all([
      tenantDb.notification.findMany({
        where: {
          userId,
        },
        orderBy: {
          createdAt: 'desc',
        },
        skip: (page - 1) * limit,
        take: limit,
      }),
      tenantDb.notification.count({
        where: {
          userId,
          isRead: false,
        },
      }),
    ])

    return {
      notifications,
      unreadCount: total,
      pagination: {
        page,
        limit,
        total: notifications.length,
      },
    }
  }

  /**
   * å‘é€æœªè¯»é€šçŸ¥
   */
  private static async sendUnreadNotifications(userId: string, tenantId: string) {
    const notifications = await this.getNotifications(userId, tenantId, 1, 50)

    if (notifications.notifications.length > 0) {
      this.io.to(`user:${userId}`).emit('unread_notifications', {
        notifications: notifications.notifications,
        unreadCount: notifications.unreadCount,
      })
    }
  }

  /**
   * ä»socketè·å–ç”¨æˆ·ä¿¡æ¯
   */
  private static getUserFromSocket(socket: any): [string | null, string | null] {
    for (const [key, sockets] of this.connectedUsers.entries()) {
      if (sockets.has(socket.id)) {
        return key.split(':')
      }
    }
    return [null, null]
  }

  /**
   * åˆ¤æ–­æ˜¯å¦éœ€è¦å‘é€é‚®ä»¶
   */
  private static shouldSendEmail(type: NotificationType): boolean {
    const emailTypes = [
      NotificationType.BILLING,
      NotificationType.INVITATION,
      NotificationType.SECURITY,
    ]

    return emailTypes.includes(type)
  }

  /**
   * è·å–é‚®ä»¶æ¨¡æ¿
   */
  private static getEmailTemplate(type: NotificationType): string {
    const templates: Record<NotificationType, string> = {
      [NotificationType.SYSTEM]: 'system-notification',
      [NotificationType.BILLING]: 'billing-notification',
      [NotificationType.PROJECT]: 'project-notification',
      [NotificationType.INVITATION]: 'invitation-notification',
      [NotificationType.SECURITY]: 'security-notification',
    }

    return templates[type] || 'default-notification'
  }

  /**
   * å‘é€é‚®ä»¶é€šçŸ¥
   */
  private static async sendEmailNotification(data: EmailNotificationData) {
    // è¿™é‡Œåº”è¯¥é›†æˆé‚®ä»¶æœåŠ¡ï¼Œå¦‚Resend
    console.log('Sending email notification:', data)
    // å®é™…å®ç°ä¸­åº”è¯¥è°ƒç”¨é‚®ä»¶æœåŠ¡API
  }
}
```

### æ­¥éª¤ä¸‰ï¼šé«˜çº§ç‰¹æ€§å®ç°

#### 3.1 å®ç°ç™½æ ‡å®šåˆ¶åŠŸèƒ½
**lib/branding/branding-service.ts**:
```typescript
import { prisma } from '@/lib/db/prisma'

export interface BrandingConfig {
  logo?: string
  primaryColor?: string
  secondaryColor?: string
  accentColor?: string
  fontFamily?: string
  customCSS?: string
  favicon?: string
  domain?: string
  title?: string
  description?: string
  customDomain?: string
  footerText?: string
  socialLinks?: {
    twitter?: string
    linkedin?: string
    facebook?: string
  }
}

export interface BrandingCustomization {
  id: string
  tenantId: string
  config: BrandingConfig
  isActive: boolean
  createdAt: Date
  updatedAt: Date
}

export class BrandingService {
  /**
   * è·å–ç§Ÿæˆ·çš„å“ç‰Œé…ç½®
   */
  static async getTenantBranding(tenantId: string): Promise<BrandingConfig> {
    const tenant = await prisma.tenant.findUnique({
      where: { id: tenantId },
      select: { branding: true },
    })

    if (!tenant) {
      throw new Error('Tenant not found')
    }

    return {
      // é»˜è®¤é…ç½®
      primaryColor: '#3b82f6',
      secondaryColor: '#64748b',
      accentColor: '#f59e0b',
      fontFamily: 'Inter, sans-serif',
      title: 'SaaS Platform',
      description: 'A powerful SaaS platform for your business',
      footerText: 'Â© 2024 Your Company. All rights reserved.',
      ...tenant.branding,
    } as BrandingConfig
  }

  /**
   * æ›´æ–°ç§Ÿæˆ·å“ç‰Œé…ç½®
   */
  static async updateTenantBranding(
    tenantId: string,
    config: Partial<BrandingConfig>
  ): Promise<BrandingConfig> {
    // éªŒè¯é…ç½®
    const validatedConfig = this.validateBrandingConfig(config)

    const tenant = await prisma.tenant.update({
      where: { id: tenantId },
      data: {
        branding: validatedConfig,
      },
    })

    return tenant.branding as BrandingConfig
  }

  /**
   * ç”ŸæˆCSSå˜é‡
   */
  static generateCSSVariables(config: BrandingConfig): string {
    const variables = [
      `--brand-primary: ${config.primaryColor || '#3b82f6'}`,
      `--brand-secondary: ${config.secondaryColor || '#64748b'}`,
      `--brand-accent: ${config.accentColor || '#f59e0b'}`,
      `--brand-font-family: ${config.fontFamily || 'Inter, sans-serif'}`,
    ]

    if (config.customCSS) {
      variables.push(config.customCSS)
    }

    return variables.join(';\n')
  }

  /**
   * ç”Ÿæˆå“ç‰ŒåŒ–ç»„ä»¶
   */
  static generateBrandedComponents(config: BrandingConfig): string {
    return `
      .brand-header {
        background-color: ${config.primaryColor || '#3b82f6'};
        font-family: ${config.fontFamily || 'Inter, sans-serif'};
      }

      .brand-button-primary {
        background-color: ${config.primaryColor || '#3b82f6'};
        border-color: ${config.primaryColor || '#3b82f6'};
      }

      .brand-button-secondary {
        background-color: ${config.secondaryColor || '#64748b'};
        border-color: ${config.secondaryColor || '#64748b'};
      }

      .brand-accent {
        color: ${config.accentColor || '#f59e0b'};
      }

      .brand-footer {
        background-color: ${config.secondaryColor || '#64748b'};
        color: white;
      }
    `
  }

  /**
   * ä¸Šä¼ å“ç‰Œèµ„æº
   */
  static async uploadBrandAsset(
    tenantId: string,
    type: 'logo' | 'favicon',
    file: File
  ): Promise<string> {
    // è¿™é‡Œåº”è¯¥å®ç°æ–‡ä»¶ä¸Šä¼ é€»è¾‘
    // å¯ä»¥ä½¿ç”¨AWS S3ã€Cloudinaryç­‰æœåŠ¡

    const fileName = `${tenantId}-${type}-${Date.now()}.${file.type.split('/')[1]}`
    const url = `/uploads/branding/${fileName}`

    // ä¿å­˜åˆ°ç§Ÿæˆ·é…ç½®
    await this.updateTenantBranding(tenantId, {
      [type]: url,
    })

    return url
  }

  /**
   * è®¾ç½®è‡ªå®šä¹‰åŸŸå
   */
  static async setCustomDomain(
    tenantId: string,
    domain: string
  ): Promise<{ status: 'pending' | 'active' | 'error'; message: string }> {
    try {
      // éªŒè¯åŸŸåæ ¼å¼
      if (!this.isValidDomain(domain)) {
        return {
          status: 'error',
          message: 'Invalid domain format',
        }
      }

      // æ£€æŸ¥åŸŸåæ˜¯å¦å·²è¢«ä½¿ç”¨
      const existingTenant = await prisma.tenant.findFirst({
        where: { domain },
      })

      if (existingTenant && existingTenant.id !== tenantId) {
        return {
          status: 'error',
          message: 'Domain is already in use',
        }
      }

      // æ›´æ–°ç§Ÿæˆ·åŸŸå
      await prisma.tenant.update({
        where: { id: tenantId },
        data: { domain },
      })

      // è¿™é‡Œåº”è¯¥é…ç½®DNSå’ŒSSLè¯ä¹¦
      // å®é™…å®ç°ä¸­éœ€è¦è°ƒç”¨åŸŸåæœåŠ¡å•†çš„API

      return {
        status: 'pending',
        message: 'Domain configuration in progress',
      }
    } catch (error) {
      return {
        status: 'error',
        message: 'Failed to configure custom domain',
      }
    }
  }

  /**
   * ç”Ÿæˆå“ç‰ŒåŒ–é‚®ä»¶æ¨¡æ¿
   */
  static generateEmailTemplate(
    config: BrandingConfig,
    templateType: 'welcome' | 'invoice' | 'notification'
  ): string {
    const baseStyles = `
      <style>
        .brand-header {
          background-color: ${config.primaryColor || '#3b82f6'};
          padding: 20px;
          text-align: center;
        }
        .brand-logo {
          max-height: 40px;
        }
        .brand-footer {
          background-color: ${config.secondaryColor || '#64748b'};
          color: white;
          padding: 20px;
          text-align: center;
        }
        .brand-button {
          background-color: ${config.primaryColor || '#3b82f6'};
          color: white;
          padding: 12px 24px;
          border-radius: 4px;
          text-decoration: none;
          display: inline-block;
        }
      </style>
    `

    const templates = {
      welcome: `
        ${baseStyles}
        <div class="brand-header">
          ${config.logo ? `<img src="${config.logo}" alt="Logo" class="brand-logo">` : `<h1>${config.title || 'Welcome'}</h1>`}
        </div>
        <div style="padding: 20px;">
          <h2>Welcome to ${config.title || 'our platform'}!</h2>
          <p>Thank you for joining us. We're excited to have you on board.</p>
          <a href="#" class="brand-button">Get Started</a>
        </div>
        <div class="brand-footer">
          <p>${config.footerText || 'Â© 2024 Your Company'}</p>
        </div>
      `,
      invoice: `
        ${baseStyles}
        <div class="brand-header">
          ${config.logo ? `<img src="${config.logo}" alt="Logo" class="brand-logo">` : `<h1>Invoice</h1>`}
        </div>
        <div style="padding: 20px;">
          <h2>Invoice from ${config.title || 'our platform'}</h2>
          <p>Your invoice is ready for review.</p>
          <a href="#" class="brand-button">View Invoice</a>
        </div>
        <div class="brand-footer">
          <p>${config.footerText || 'Â© 2024 Your Company'}</p>
        </div>
      `,
      notification: `
        ${baseStyles}
        <div class="brand-header">
          ${config.logo ? `<img src="${config.logo}" alt="Logo" class="brand-logo">` : `<h1>Notification</h1>`}
        </div>
        <div style="padding: 20px;">
          <h2>You have a new notification</h2>
          <p>Something important requires your attention.</p>
          <a href="#" class="brand-button">View Details</a>
        </div>
        <div class="brand-footer">
          <p>${config.footerText || 'Â© 2024 Your Company'}</p>
        </div>
      `,
    }

    return templates[templateType] || templates.notification
  }

  /**
   * éªŒè¯å“ç‰Œé…ç½®
   */
  private static validateBrandingConfig(config: Partial<BrandingConfig>): Partial<BrandingConfig> {
    const validated: Partial<BrandingConfig> = {}

    if (config.primaryColor && this.isValidColor(config.primaryColor)) {
      validated.primaryColor = config.primaryColor
    }

    if (config.secondaryColor && this.isValidColor(config.secondaryColor)) {
      validated.secondaryColor = config.secondaryColor
    }

    if (config.accentColor && this.isValidColor(config.accentColor)) {
      validated.accentColor = config.accentColor
    }

    if (config.fontFamily) {
      validated.fontFamily = config.fontFamily
    }

    if (config.title && config.title.length <= 100) {
      validated.title = config.title
    }

    if (config.description && config.description.length <= 500) {
      validated.description = config.description
    }

    if (config.footerText && config.footerText.length <= 200) {
      validated.footerText = config.footerText
    }

    if (config.logo && this.isValidUrl(config.logo)) {
      validated.logo = config.logo
    }

    if (config.favicon && this.isValidUrl(config.favicon)) {
      validated.favicon = config.favicon
    }

    if (config.customDomain && this.isValidDomain(config.customDomain)) {
      validated.customDomain = config.customDomain
    }

    if (config.customCSS && config.customCSS.length <= 10000) {
      validated.customCSS = config.customCSS
    }

    return validated
  }

  /**
   * éªŒè¯é¢œè‰²æ ¼å¼
   */
  private static isValidColor(color: string): boolean {
    const colorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/
    return colorRegex.test(color)
  }

  /**
   * éªŒè¯URLæ ¼å¼
   */
  private static isValidUrl(url: string): boolean {
    try {
      new URL(url)
      return true
    } catch {
      return false
    }
  }

  /**
   * éªŒè¯åŸŸåæ ¼å¼
   */
  private static isValidDomain(domain: string): boolean {
    const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9](?:\.[a-zA-Z]{2,})+$/
    return domainRegex.test(domain)
  }

  /**
   * é¢„è§ˆå“ç‰Œé…ç½®
   */
  static async previewBranding(
    tenantId: string,
    config: Partial<BrandingConfig>
  ): Promise<{
    cssVariables: string
    components: string
    emailTemplate: string
  }> {
    const currentConfig = await this.getTenantBranding(tenantId)
    const previewConfig = { ...currentConfig, ...config }

    return {
      cssVariables: this.generateCSSVariables(previewConfig),
      components: this.generateBrandedComponents(previewConfig),
      emailTemplate: this.generateEmailTemplate(previewConfig, 'welcome'),
    }
  }
}
```

#### 3.2 å®ç°APIé›†æˆç³»ç»Ÿ
**lib/integrations/integration-service.ts**:
```typescript
import { prisma } from '@/lib/db/prisma'

export interface IntegrationConfig {
  type: IntegrationType
  name: string
  description?: string
  credentials: Record<string, any>
  settings: Record<string, any>
  webhookUrl?: string
  isActive: boolean
}

export enum IntegrationType {
  SLACK = 'slack',
  GOOGLE_ANALYTICS = 'google_analytics',
  ZAPIER = 'zapier',
  WEBHOOK = 'webhook',
  STRIPE = 'stripe',
  SENDGRID = 'sendgrid',
  CUSTOM = 'custom',
}

export interface IntegrationEvent {
  type: string
  data: Record<string, any>
  tenantId: string
  userId?: string
  timestamp: Date
}

export class IntegrationService {
  /**
   * åˆ›å»ºé›†æˆ
   */
  static async createIntegration(
    tenantId: string,
    config: Omit<IntegrationConfig, 'isActive'>
  ): Promise<any> {
    // éªŒè¯é›†æˆé…ç½®
    this.validateIntegrationConfig(config.type, config.credentials, config.settings)

    const integration = await prisma.integration.create({
      data: {
        tenantId,
        type: config.type,
        name: config.name,
        description: config.description,
        credentials: config.credentials,
        settings: config.settings,
        webhookUrl: config.webhookUrl,
        isActive: true,
      },
    })

    // æµ‹è¯•é›†æˆè¿æ¥
    await this.testIntegration(integration.id)

    return integration
  }

  /**
   * è§¦å‘é›†æˆäº‹ä»¶
   */
  static async triggerEvent(event: IntegrationEvent): Promise<void> {
    // è·å–ç§Ÿæˆ·çš„æ‰€æœ‰æ´»è·ƒé›†æˆ
    const integrations = await prisma.integration.findMany({
      where: {
        tenantId: event.tenantId,
        isActive: true,
      },
    })

    // å¹¶è¡Œå¤„ç†æ‰€æœ‰é›†æˆ
    await Promise.allSettled(
      integrations.map(integration =>
        this.processIntegrationEvent(integration, event)
      )
    )
  }

  /**
   * å¤„ç†å•ä¸ªé›†æˆäº‹ä»¶
   */
  private static async processIntegrationEvent(
    integration: any,
    event: IntegrationEvent
  ): Promise<void> {
    try {
      switch (integration.type) {
        case IntegrationType.SLACK:
          await this.sendSlackNotification(integration, event)
          break
        case IntegrationType.GOOGLE_ANALYTICS:
          await this.sendGoogleAnalyticsEvent(integration, event)
          break
        case IntegrationType.ZAPIER:
          await this.sendZapierWebhook(integration, event)
          break
        case IntegrationType.WEBHOOK:
          await this.sendCustomWebhook(integration, event)
          break
        case IntegrationType.STRIPE:
          await this.processStripeEvent(integration, event)
          break
        case IntegrationType.SENDGRID:
          await this.sendSendgridEmail(integration, event)
          break
        case IntegrationType.CUSTOM:
          await this.processCustomIntegration(integration, event)
          break
        default:
          console.warn(`Unknown integration type: ${integration.type}`)
      }
    } catch (error) {
      console.error(`Failed to process event for integration ${integration.id}:`, error)

      // è®°å½•é”™è¯¯æ—¥å¿—
      await this.logIntegrationError(integration.id, event, error)
    }
  }

  /**
   * å‘é€Slacké€šçŸ¥
   */
  private static async sendSlackNotification(
    integration: any,
    event: IntegrationEvent
  ): Promise<void> {
    const { webhookUrl, settings } = integration.credentials
    const { channel, username, icon_emoji } = settings

    const payload = {
      channel: channel || '#general',
      username: username || 'SaaS Platform',
      icon_emoji: icon_emoji || ':robot_face:',
      text: this.formatSlackMessage(event),
      attachments: this.createSlackAttachments(event),
    }

    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    })

    if (!response.ok) {
      throw new Error(`Slack webhook failed: ${response.statusText}`)
    }
  }

  /**
   * å‘é€Google Analyticsäº‹ä»¶
   */
  private static async sendGoogleAnalyticsEvent(
    integration: any,
    event: IntegrationEvent
  ): Promise<void> {
    const { measurementId, apiSecret } = integration.credentials

    const payload = {
      client_id: event.tenantId,
      events: [
        {
          name: event.type,
          parameters: {
            tenant_id: event.tenantId,
            user_id: event.userId,
            timestamp: event.timestamp.toISOString(),
            ...event.data,
          },
        },
      ],
    }

    const url = `https://www.google-analytics.com/mp/collect?measurement_id=${measurementId}&api_secret=${apiSecret}`

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    })

    if (!response.ok) {
      throw new Error(`Google Analytics request failed: ${response.statusText}`)
    }
  }

  /**
   * å‘é€Zapier Webhook
   */
  private static async sendZapierWebhook(
    integration: any,
    event: IntegrationEvent
  ): Promise<void> {
    const { webhookUrl } = integration.credentials

    const payload = {
      event_type: event.type,
      tenant_id: event.tenantId,
      user_id: event.userId,
      timestamp: event.timestamp.toISOString(),
      data: event.data,
    }

    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    })

    if (!response.ok) {
      throw new Error(`Zapier webhook failed: ${response.statusText}`)
    }
  }

  /**
   * å‘é€è‡ªå®šä¹‰Webhook
   */
  private static async sendCustomWebhook(
    integration: any,
    event: IntegrationEvent
  ): Promise<void> {
    const { url, method = 'POST', headers = {}, auth } = integration.credentials
    const { retryCount = 3, timeout = 10000 } = integration.settings

    const payload = {
      event: event.type,
      tenant_id: event.tenantId,
      user_id: event.userId,
      timestamp: event.timestamp.toISOString(),
      data: event.data,
    }

    const requestHeaders = {
      'Content-Type': 'application/json',
      ...headers,
    }

    // æ·»åŠ è®¤è¯å¤´
    if (auth?.type === 'bearer') {
      requestHeaders.Authorization = `Bearer ${auth.token}`
    } else if (auth?.type === 'basic') {
      requestHeaders.Authorization = `Basic ${Buffer.from(`${auth.username}:${auth.password}`).toString('base64')}`
    }

    let lastError: Error | null = null

    for (let attempt = 1; attempt <= retryCount; attempt++) {
      try {
        const controller = new AbortController()
        const timeoutId = setTimeout(() => controller.abort(), timeout)

        const response = await fetch(url, {
          method,
          headers: requestHeaders,
          body: JSON.stringify(payload),
          signal: controller.signal,
        })

        clearTimeout(timeoutId)

        if (!response.ok) {
          throw new Error(`Webhook failed: ${response.statusText}`)
        }

        return // æˆåŠŸï¼Œé€€å‡ºé‡è¯•å¾ªç¯
      } catch (error) {
        lastError = error as Error
        console.warn(`Webhook attempt ${attempt} failed:`, error)

        if (attempt < retryCount) {
          // æŒ‡æ•°é€€é¿
          await new Promise(resolve =>
            setTimeout(resolve, Math.pow(2, attempt) * 1000)
          )
        }
      }
    }

    throw lastError || new Error('Webhook failed after all retries')
  }

  /**
   * æµ‹è¯•é›†æˆè¿æ¥
   */
  static async testIntegration(integrationId: string): Promise<boolean> {
    const integration = await prisma.integration.findUnique({
      where: { id: integrationId },
    })

    if (!integration) {
      throw new Error('Integration not found')
    }

    try {
      const testEvent: IntegrationEvent = {
        type: 'integration_test',
        data: { test: true },
        tenantId: integration.tenantId,
        timestamp: new Date(),
      }

      await this.processIntegrationEvent(integration, testEvent)
      return true
    } catch (error) {
      console.error('Integration test failed:', error)
      return false
    }
  }

  /**
   * è·å–é›†æˆç±»å‹æ¨¡æ¿
   */
  static getIntegrationTemplate(type: IntegrationType): {
    fields: Array<{
      key: string
      label: string
      type: 'text' | 'password' | 'url' | 'number' | 'boolean'
      required: boolean
      placeholder?: string
      description?: string
    }>
    settings: Array<{
      key: string
      label: string
      type: 'text' | 'number' | 'boolean' | 'select'
      required: boolean
      options?: string[]
      defaultValue?: any
    }>
  } {
    const templates = {
      [IntegrationType.SLACK]: {
        fields: [
          {
            key: 'webhookUrl',
            label: 'Webhook URL',
            type: 'url',
            required: true,
            description: 'Your Slack incoming webhook URL',
          },
        ],
        settings: [
          {
            key: 'channel',
            label: 'Default Channel',
            type: 'text',
            required: false,
            defaultValue: '#general',
          },
          {
            key: 'username',
            label: 'Bot Username',
            type: 'text',
            required: false,
            defaultValue: 'SaaS Platform',
          },
        ],
      },
      [IntegrationType.GOOGLE_ANALYTICS]: {
        fields: [
          {
            key: 'measurementId',
            label: 'Measurement ID',
            type: 'text',
            required: true,
            placeholder: 'G-XXXXXXXXXX',
          },
          {
            key: 'apiSecret',
            label: 'API Secret',
            type: 'password',
            required: true,
          },
        ],
        settings: [],
      },
      [IntegrationType.WEBHOOK]: {
        fields: [
          {
            key: 'url',
            label: 'Webhook URL',
            type: 'url',
            required: true,
          },
        ],
        settings: [
          {
            key: 'method',
            label: 'HTTP Method',
            type: 'select',
            required: false,
            options: ['POST', 'PUT', 'PATCH'],
            defaultValue: 'POST',
          },
          {
            key: 'retryCount',
            label: 'Retry Count',
            type: 'number',
            required: false,
            defaultValue: 3,
          },
        ],
      },
    }

    return templates[type] || { fields: [], settings: [] }
  }

  /**
   * éªŒè¯é›†æˆé…ç½®
   */
  private static validateIntegrationConfig(
    type: IntegrationType,
    credentials: Record<string, any>,
    settings: Record<string, any>
  ): void {
    const template = this.getIntegrationTemplate(type)

    // éªŒè¯å¿…å¡«å­—æ®µ
    for (const field of template.fields) {
      if (field.required && !credentials[field.key]) {
        throw new Error(`Required field '${field.label}' is missing`)
      }
    }

    // éªŒè¯å­—æ®µæ ¼å¼
    for (const field of template.fields) {
      const value = credentials[field.key]
      if (value && field.type === 'url' && !this.isValidUrl(value)) {
        throw new Error(`Field '${field.label}' must be a valid URL`)
      }
    }
  }

  /**
   * æ ¼å¼åŒ–Slackæ¶ˆæ¯
   */
  private static formatSlackMessage(event: IntegrationEvent): string {
    const eventTypeMap: Record<string, string> = {
      user_created: 'ğŸ‘¤ New User Created',
      subscription_created: 'ğŸ’³ New Subscription',
      project_created: 'ğŸ“ New Project Created',
      invoice_paid: 'ğŸ’° Invoice Paid',
    }

    return eventTypeMap[event.type] || `ğŸ“¢ ${event.type}`
  }

  /**
   * åˆ›å»ºSlacké™„ä»¶
   */
  private static createSlackAttachments(event: IntegrationEvent): any[] {
    return [
      {
        color: this.getEventColor(event.type),
        fields: [
          {
            title: 'Tenant ID',
            value: event.tenantId,
            short: true,
          },
          {
            title: 'Timestamp',
            value: event.timestamp.toLocaleString(),
            short: true,
          },
        ],
      },
    ]
  }

  /**
   * è·å–äº‹ä»¶é¢œè‰²
   */
  private static getEventColor(eventType: string): string {
    const colorMap: Record<string, string> = {
      user_created: 'good',
      subscription_created: 'good',
      project_created: 'good',
      invoice_paid: 'good',
      user_deleted: 'danger',
      subscription_cancelled: 'warning',
      payment_failed: 'danger',
    }

    return colorMap[eventType] || 'good'
  }

  /**
   * éªŒè¯URLæ ¼å¼
   */
  private static isValidUrl(url: string): boolean {
    try {
      new URL(url)
      return true
    } catch {
      return false
    }
  }

  /**
   * è®°å½•é›†æˆé”™è¯¯
   */
  private static async logIntegrationError(
    integrationId: string,
    event: IntegrationEvent,
    error: any
  ): Promise<void> {
    // è¿™é‡Œåº”è¯¥è®°å½•åˆ°æ•°æ®åº“æˆ–æ—¥å¿—ç³»ç»Ÿ
    console.error('Integration error:', {
      integrationId,
      eventType: event.type,
      tenantId: event.tenantId,
      error: error.message,
      stack: error.stack,
    })
  }

  /**
   * å¤„ç†Stripeäº‹ä»¶ï¼ˆå ä½ç¬¦ï¼‰
   */
  private static async processStripeEvent(
    integration: any,
    event: IntegrationEvent
  ): Promise<void> {
    // Stripeç‰¹å®šçš„å¤„ç†é€»è¾‘
  }

  /**
   * å‘é€SendGridé‚®ä»¶ï¼ˆå ä½ç¬¦ï¼‰
   */
  private static async sendSendgridEmail(
    integration: any,
    event: IntegrationEvent
  ): Promise<void> {
    // SendGridç‰¹å®šçš„å¤„ç†é€»è¾‘
  }

  /**
   * å¤„ç†è‡ªå®šä¹‰é›†æˆï¼ˆå ä½ç¬¦ï¼‰
   */
  private static async processCustomIntegration(
    integration: any,
    event: IntegrationEvent
  ): Promise<void> {
    // è‡ªå®šä¹‰é›†æˆå¤„ç†é€»è¾‘
  }
}
```

### æ­¥éª¤å››ï¼šæµ‹è¯•å’Œä¼˜åŒ–

#### 4.1 å¤šç§Ÿæˆ·æµ‹è¯•ç­–ç•¥
**__tests__/multi-tenant/tenant-isolation.test.ts**:
```typescript
import { describe, it, expect, beforeEach, afterEach } from '@jest/globals'
import { prisma } from '@/lib/db/prisma'
import { getTenantPrisma, cleanupTenantPrisma } from '@/lib/db/tenant-prisma'

describe('Multi-Tenant Data Isolation', () => {
  let tenant1Id: string
  let tenant2Id: string
  let user1Id: string
  let user2Id: string

  beforeEach(async () => {
    // åˆ›å»ºæµ‹è¯•ç§Ÿæˆ·
    const tenant1 = await prisma.tenant.create({
      data: {
        platformId: 'test-platform',
        name: 'Tenant 1',
        slug: 'tenant-1',
      },
    })

    const tenant2 = await prisma.tenant.create({
      data: {
        platformId: 'test-platform',
        name: 'Tenant 2',
        slug: 'tenant-2',
      },
    })

    tenant1Id = tenant1.id
    tenant2Id = tenant2.id

    // ä¸ºæ¯ä¸ªç§Ÿæˆ·åˆ›å»ºç”¨æˆ·
    const tenant1Db = getTenantPrisma(tenant1Id)
    const tenant2Db = getTenantPrisma(tenant2Id)

    const user1 = await tenant1Db.user.create({
      data: {
        email: 'user1@tenant1.com',
        name: 'User 1',
        platformUserId: 'platform-user-1',
      },
    })

    const user2 = await tenant2Db.user.create({
      data: {
        email: 'user1@tenant2.com',
        name: 'User 2',
        platformUserId: 'platform-user-1',
      },
    })

    user1Id = user1.id
    user2Id = user2.id
  })

  afterEach(async () => {
    // æ¸…ç†æµ‹è¯•æ•°æ®
    await prisma.tenant.deleteMany({
      where: {
        id: { in: [tenant1Id, tenant2Id] },
      },
    })

    cleanupTenantPrisma(tenant1Id)
    cleanupTenantPrisma(tenant2Id)
  })

  it('should isolate user data between tenants', async () => {
    const tenant1Db = getTenantPrisma(tenant1Id)
    const tenant2Db = getTenantPrisma(tenant2Id)

    // è·å–å„è‡ªç§Ÿæˆ·çš„ç”¨æˆ·
    const tenant1Users = await tenant1Db.user.findMany()
    const tenant2Users = await tenant2Db.user.findMany()

    expect(tenant1Users).toHaveLength(1)
    expect(tenant2Users).toHaveLength(1)
    expect(tenant1Users[0].id).not.toBe(tenant2Users[0].id)
  })

  it('should prevent cross-tenant data access', async () => {
    const tenant1Db = getTenantPrisma(tenant1Id)

    // å°è¯•ä»ç§Ÿæˆ·1è®¿é—®ç§Ÿæˆ·2çš„ç”¨æˆ·ID
    const user = await tenant1Db.user.findUnique({
      where: { id: user2Id },
    })

    expect(user).toBeNull()
  })

  it('should maintain separate project spaces', async () => {
    const tenant1Db = getTenantPrisma(tenant1Id)
    const tenant2Db = getTenantPrisma(tenant2Id)

    // åœ¨ä¸åŒç§Ÿæˆ·åˆ›å»ºåŒåé¡¹ç›®
    await tenant1Db.project.create({
      data: {
        name: 'Shared Project',
        description: 'Project in tenant 1',
      },
    })

    await tenant2Db.project.create({
      data: {
        name: 'Shared Project',
        description: 'Project in tenant 2',
      },
    })

    const tenant1Projects = await tenant1Db.project.findMany()
    const tenant2Projects = await tenant2Db.project.findMany()

    expect(tenant1Projects).toHaveLength(1)
    expect(tenant2Projects).toHaveLength(1)
    expect(tenant1Projects[0].description).toBe('Project in tenant 1')
    expect(tenant2Projects[0].description).toBe('Project in tenant 2')
  })
})
```

#### 4.2 æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–
**lib/monitoring/performance-monitor.ts**:
```typescript
export interface PerformanceMetrics {
  responseTime: number
  memoryUsage: number
  cpuUsage: number
  activeConnections: number
  errorRate: number
  timestamp: Date
}

export interface AlertThresholds {
  responseTime: number
  memoryUsage: number
  cpuUsage: number
  errorRate: number
}

export class PerformanceMonitor {
  private static metrics: PerformanceMetrics[] = []
  private static alertThresholds: AlertThresholds = {
    responseTime: 1000, // 1ç§’
    memoryUsage: 80,   // 80%
    cpuUsage: 80,      // 80%
    errorRate: 5,      // 5%
  }

  /**
   * è®°å½•æ€§èƒ½æŒ‡æ ‡
   */
  static recordMetrics(metrics: Partial<PerformanceMetrics>): void {
    const fullMetrics: PerformanceMetrics = {
      responseTime: 0,
      memoryUsage: 0,
      cpuUsage: 0,
      activeConnections: 0,
      errorRate: 0,
      timestamp: new Date(),
      ...metrics,
    }

    this.metrics.push(fullMetrics)

    // ä¿ç•™æœ€è¿‘1å°æ—¶çš„æ•°æ®
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000)
    this.metrics = this.metrics.filter(m => m.timestamp > oneHourAgo)

    // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘é€è­¦æŠ¥
    this.checkAlerts(fullMetrics)
  }

  /**
   * è·å–æ€§èƒ½æŒ‡æ ‡
   */
  static getMetrics(timeRange?: { start: Date; end: Date }): PerformanceMetrics[] {
    if (!timeRange) {
      return [...this.metrics]
    }

    return this.metrics.filter(
      m => m.timestamp >= timeRange.start && m.timestamp <= timeRange.end
    )
  }

  /**
   * è·å–æ€§èƒ½ç»Ÿè®¡
   */
  static getPerformanceStats(): {
    avgResponseTime: number
    maxResponseTime: number
    avgMemoryUsage: number
    maxMemoryUsage: number
    avgCpuUsage: number
    maxCpuUsage: number
    avgErrorRate: number
    totalRequests: number
  } {
    if (this.metrics.length === 0) {
      return {
        avgResponseTime: 0,
        maxResponseTime: 0,
        avgMemoryUsage: 0,
        maxMemoryUsage: 0,
        avgCpuUsage: 0,
        maxCpuUsage: 0,
        avgErrorRate: 0,
        totalRequests: 0,
      }
    }

    const responseTimes = this.metrics.map(m => m.responseTime)
    const memoryUsages = this.metrics.map(m => m.memoryUsage)
    const cpuUsages = this.metrics.map(m => m.cpuUsage)
    const errorRates = this.metrics.map(m => m.errorRate)

    return {
      avgResponseTime: responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length,
      maxResponseTime: Math.max(...responseTimes),
      avgMemoryUsage: memoryUsages.reduce((a, b) => a + b, 0) / memoryUsages.length,
      maxMemoryUsage: Math.max(...memoryUsages),
      avgCpuUsage: cpuUsages.reduce((a, b) => a + b, 0) / cpuUsages.length,
      maxCpuUsage: Math.max(...cpuUsages),
      avgErrorRate: errorRates.reduce((a, b) => a + b, 0) / errorRates.length,
      totalRequests: this.metrics.length,
    }
  }

  /**
   * è®¾ç½®è­¦æŠ¥é˜ˆå€¼
   */
  static setAlertThresholds(thresholds: Partial<AlertThresholds>): void {
    this.alertThresholds = { ...this.alertThresholds, ...thresholds }
  }

  /**
   * æ£€æŸ¥è­¦æŠ¥
   */
  private static checkAlerts(metrics: PerformanceMetrics): void {
    const alerts = []

    if (metrics.responseTime > this.alertThresholds.responseTime) {
      alerts.push({
        type: 'response_time',
        message: `Response time exceeded threshold: ${metrics.responseTime}ms`,
        severity: 'warning',
      })
    }

    if (metrics.memoryUsage > this.alertThresholds.memoryUsage) {
      alerts.push({
        type: 'memory_usage',
        message: `Memory usage exceeded threshold: ${metrics.memoryUsage}%`,
        severity: 'critical',
      })
    }

    if (metrics.cpuUsage > this.alertThresholds.cpuUsage) {
      alerts.push({
        type: 'cpu_usage',
        message: `CPU usage exceeded threshold: ${metrics.cpuUsage}%`,
        severity: 'warning',
      })
    }

    if (metrics.errorRate > this.alertThresholds.errorRate) {
      alerts.push({
        type: 'error_rate',
        message: `Error rate exceeded threshold: ${metrics.errorRate}%`,
        severity: 'critical',
      })
    }

    // å‘é€è­¦æŠ¥
    alerts.forEach(alert => this.sendAlert(alert))
  }

  /**
   * å‘é€è­¦æŠ¥
   */
  private static async sendAlert(alert: {
    type: string
    message: string
    severity: string
  }): Promise<void> {
    console.error(`[ALERT] ${alert.severity.toUpperCase()}: ${alert.message}`)

    // è¿™é‡Œå¯ä»¥é›†æˆè­¦æŠ¥æœåŠ¡ï¼Œå¦‚ï¼š
    // - å‘é€é‚®ä»¶é€šçŸ¥
    // - å‘é€Slacké€šçŸ¥
    // - å‘é€SMSé€šçŸ¥
    // - é›†æˆç›‘æ§æœåŠ¡ï¼ˆå¦‚Sentryã€DataDogç­‰ï¼‰
  }

  /**
   * ç›‘æ§APIå“åº”æ—¶é—´
   */
  static monitorApiResponse(
    req: Request,
    res: Response,
    startTime: number
  ): void {
    const responseTime = Date.now() - startTime

    this.recordMetrics({
      responseTime,
      timestamp: new Date(),
    })
  }

  /**
   * ç›‘æ§å†…å­˜ä½¿ç”¨
   */
  static monitorMemoryUsage(): void {
    if (typeof process !== 'undefined' && process.memoryUsage) {
      const memoryUsage = process.memoryUsage()
      const usedMemory = memoryUsage.heapUsed / 1024 / 1024 // MB
      const totalMemory = memoryUsage.heapTotal / 1024 / 1024 // MB
      const memoryUsagePercent = (usedMemory / totalMemory) * 100

      this.recordMetrics({
        memoryUsage: Math.round(memoryUsagePercent),
        timestamp: new Date(),
      })
    }
  }

  /**
   * ç›‘æ§CPUä½¿ç”¨
   */
  static monitorCpuUsage(): void {
    // CPUä½¿ç”¨ç‡ç›‘æ§éœ€è¦ç³»ç»Ÿç‰¹å®šçš„å®ç°
    // è¿™é‡Œå¯ä»¥ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨æˆ–ç¬¬ä¸‰æ–¹åº“
    const cpuUsage = this.getCpuUsage()

    this.recordMetrics({
      cpuUsage,
      timestamp: new Date(),
    })
  }

  /**
   * è·å–CPUä½¿ç”¨ç‡ï¼ˆç®€åŒ–å®ç°ï¼‰
   */
  private static getCpuUsage(): number {
    // å®é™…å®ç°ä¸­åº”è¯¥ä½¿ç”¨ç³»ç»ŸAPIæˆ–ç¬¬ä¸‰æ–¹åº“
    // è¿™é‡Œè¿”å›ä¸€ä¸ªæ¨¡æ‹Ÿå€¼
    return Math.random() * 100
  }

  /**
   * å¯åŠ¨æ€§èƒ½ç›‘æ§
   */
  static startMonitoring(): void {
    // æ¯30ç§’è®°å½•ä¸€æ¬¡å†…å­˜ä½¿ç”¨
    setInterval(() => {
      this.monitorMemoryUsage()
    }, 30000)

    // æ¯60ç§’è®°å½•ä¸€æ¬¡CPUä½¿ç”¨
    setInterval(() => {
      this.monitorCpuUsage()
    }, 60000)

    console.log('Performance monitoring started')
  }

  /**
   * åœæ­¢æ€§èƒ½ç›‘æ§
   */
  static stopMonitoring(): void {
    console.log('Performance monitoring stopped')
  }

  /**
   * ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
   */
  static generateReport(timeRange?: { start: Date; end: Date }): {
    summary: any
    metrics: PerformanceMetrics[]
    recommendations: string[]
  } {
    const metrics = this.getMetrics(timeRange)
    const stats = this.getPerformanceStats()

    const recommendations = []

    if (stats.avgResponseTime > 500) {
      recommendations.push('Consider optimizing API responses or implementing caching')
    }

    if (stats.maxMemoryUsage > 85) {
      recommendations.push('High memory usage detected. Check for memory leaks')
    }

    if (stats.avgErrorRate > 1) {
      recommendations.push('High error rate detected. Review error logs and fix issues')
    }

    return {
      summary: stats,
      metrics,
      recommendations,
    }
  }
}
```

### æ­¥éª¤äº”ï¼šéƒ¨ç½²å’Œä¸Šçº¿

#### 5.1 ç”Ÿäº§ç¯å¢ƒé…ç½®
**.env.production**:
```bash
# Database
DATABASE_URL="postgresql://username:password@host:5432/saas_prod"

# NextAuth
NEXTAUTH_URL="https://yourdomain.com"
NEXTAUTH_SECRET="your-super-secret-key"

# Stripe
STRIPE_SECRET_KEY="sk_live_..."
STRIPE_WEBHOOK_SECRET="whsec_..."
STRIPE_CONNECT_CLIENT_ID="ca_..."

# Email
RESEND_API_KEY="re_..."

# File Storage
AWS_ACCESS_KEY_ID="your-aws-access-key"
AWS_SECRET_ACCESS_KEY="your-aws-secret-key"
AWS_REGION="us-east-1"
AWS_S3_BUCKET="your-s3-bucket"

# Redis
REDIS_URL="redis://your-redis-host:6379"

# Monitoring
SENTRY_DSN="https://your-sentry-dsn"
LOGROCKET_APP_ID="your-logrocket-id"

# Analytics
GOOGLE_ANALYTICS_ID="GA-XXXXXXXXX"

# Features
ENABLE_MULTITENANT=true
ENABLE_BILLING=true
ENABLE_INTEGRATIONS=true
ENABLE_WHITE_LABEL=true

# Security
CORS_ORIGINS="https://yourdomain.com,https://app.yourdomain.com"
RATE_LIMIT_MAX=100
RATE_LIMIT_WINDOW=900000

# Performance
ENABLE_CACHING=true
CACHE_TTL=3600
COMPRESSION=true
```

#### 5.2 éƒ¨ç½²é…ç½®
**next.config.js**:
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    appDir: true,
    serverComponentsExternalPackages: ['@prisma/client', 'stripe'],
  },
  images: {
    domains: [
      'localhost',
      'your-domain.com',
      'your-s3-bucket.s3.amazonaws.com',
    ],
    formats: ['image/webp', 'image/avif'],
  },
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },
  poweredByHeader: false,
  compress: true,
  generateEtags: true,

  // å®‰å…¨å¤´
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin',
          },
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=()',
          },
        ],
      },
      {
        source: '/api/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'no-store, must-revalidate',
          },
        ],
      },
    ]
  },

  // é‡å®šå‘è§„åˆ™
  async redirects() {
    return [
      {
        source: '/home',
        destination: '/dashboard',
        permanent: true,
      },
    ]
  },

  // Webpacké…ç½®
  webpack: (config, { isServer, dev }) => {
    if (!dev && !isServer) {
      // ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–
      config.optimization.splitChunks = {
        chunks: 'all',
        cacheGroups: {
          default: {
            minChunks: 2,
            priority: -20,
            reuseExistingChunk: true,
          },
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            priority: -10,
            chunks: 'all',
          },
          common: {
            name: 'common',
            minChunks: 2,
            priority: -30,
            chunks: 'all',
            reuseExistingChunk: true,
          },
        },
      }
    }

    return config
  },
}

module.exports = nextConfig
```

## ğŸ’¡ å…³é”®æŠ€æœ¯ç‚¹

### 1. å¤šç§Ÿæˆ·æ¶æ„
- æ•°æ®éš”ç¦»ç­–ç•¥ï¼ˆSchemaåˆ†ç¦» vs Row Level Securityï¼‰
- ç§Ÿæˆ·è¯†åˆ«å’Œè·¯ç”±
- èµ„æºå…±äº«å’Œéš”ç¦»
- æ€§èƒ½ä¼˜åŒ–å’Œæ‰©å±•

### 2. è®¢é˜…è®¡è´¹ç³»ç»Ÿ
- Stripe Billingé›†æˆ
- è®¢é˜…ç”Ÿå‘½å‘¨æœŸç®¡ç†
- ä½¿ç”¨é‡é™åˆ¶å’Œç›‘æ§
- è®¡è´¹äº‹ä»¶å¤„ç†

### 3. æƒé™æ§åˆ¶ç³»ç»Ÿ
- RBACæ¨¡å‹å®ç°
- ç»†ç²’åº¦æƒé™æ§åˆ¶
- åŠ¨æ€æƒé™æ£€æŸ¥
- å®¡è®¡æ—¥å¿—

### 4. ç™½æ ‡è§£å†³æ–¹æ¡ˆ
- å“ç‰Œå®šåˆ¶ç³»ç»Ÿ
- åŸŸåé…ç½®ç®¡ç†
- CSSå˜é‡å’Œä¸»é¢˜
- é‚®ä»¶æ¨¡æ¿å®šåˆ¶

### 5. é›†æˆå’ŒAPIç®¡ç†
- ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆ
- Webhookå¤„ç†
- äº‹ä»¶é©±åŠ¨æ¶æ„
- é”™è¯¯å¤„ç†å’Œé‡è¯•

## ğŸ¨ UI/UXè®¾è®¡

### SaaSå¹³å°è®¾è®¡åŸåˆ™
- **ä¸€è‡´æ€§**: ç»Ÿä¸€çš„è®¾è®¡è¯­è¨€å’Œäº¤äº’æ¨¡å¼
- **å¯è®¿é—®æ€§**: ç¬¦åˆWCAGæ ‡å‡†çš„æ— éšœç¢è®¾è®¡
- **å›½é™…åŒ–**: å¤šè¯­è¨€å’Œåœ°åŒºæ”¯æŒ
- **å¯å®šåˆ¶æ€§**: å“ç‰Œå’Œä¸»é¢˜å®šåˆ¶èƒ½åŠ›

### å…³é”®é¡µé¢è®¾è®¡
1. **ç™»å½•/æ³¨å†Œ**: ç®€æ´çš„è®¤è¯æµç¨‹
2. **ä»ªè¡¨æ¿**: æ¸…æ™°çš„æ•°æ®å±•ç¤ºå’Œå¯¼èˆª
3. **è®¾ç½®é¡µé¢**: åˆ†ç»„çš„è®¾ç½®é€‰é¡¹
4. **è®¡è´¹é¡µé¢**: é€æ˜çš„å®šä»·å’Œè®¢é˜…ç®¡ç†
5. **ç”¨æˆ·ç®¡ç†**: ç›´è§‚çš„ç”¨æˆ·å’Œæƒé™ç®¡ç†

## ğŸ“± å“åº”å¼è®¾è®¡

### ç§»åŠ¨ç«¯é€‚é…
- è§¦æ‘¸å‹å¥½çš„äº¤äº’è®¾è®¡
- ç§»åŠ¨ç«¯å¯¼èˆªä¼˜åŒ–
- å“åº”å¼è¡¨æ ¼å’Œæ•°æ®å±•ç¤º
- ç¦»çº¿åŠŸèƒ½æ”¯æŒ

### å…³é”®æ–­ç‚¹
- Mobile: < 640px
- Tablet: 640px - 1024px
- Desktop: > 1024px

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. å‰ç«¯ä¼˜åŒ–
- ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
- å›¾ç‰‡ä¼˜åŒ–å’ŒCDN
- ç¼“å­˜ç­–ç•¥
- æœåŠ¡ç«¯æ¸²æŸ“

### 2. åç«¯ä¼˜åŒ–
- æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- è¿æ¥æ± ç®¡ç†
- APIå“åº”ç¼“å­˜
- è´Ÿè½½å‡è¡¡

### 3. SaaSç‰¹å®šä¼˜åŒ–
- å¤šç§Ÿæˆ·èµ„æºéš”ç¦»
- æ•°æ®åº“è¿æ¥ç®¡ç†
- è®¡é˜…é™åˆ¶æ£€æŸ¥
- ä½¿ç”¨é‡ç›‘æ§

## ğŸ”’ å®‰å…¨è€ƒè™‘

### 1. å¤šç§Ÿæˆ·å®‰å…¨
- æ•°æ®éš”ç¦»éªŒè¯
- è·¨ç§Ÿæˆ·æ”»å‡»é˜²æŠ¤
- ç§Ÿæˆ·é…ç½®å®‰å…¨
- å®¡è®¡å’Œç›‘æ§

### 2. åº”ç”¨å®‰å…¨
- è®¤è¯å’Œæˆæƒ
- APIå®‰å…¨
- æ•°æ®åŠ å¯†
- å®‰å…¨å¤´é…ç½®

### 3. åˆè§„æ€§
- GDPRåˆè§„
- æ•°æ®ä¿æŠ¤
- éšç§æ”¿ç­–
- å®‰å…¨å®¡è®¡

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### æµ‹è¯•ç±»å‹
1. **å•å…ƒæµ‹è¯•**: ç»„ä»¶å’Œå‡½æ•°æµ‹è¯•
2. **é›†æˆæµ‹è¯•**: APIå’Œæ•°æ®æµæµ‹è¯•
3. **E2Eæµ‹è¯•**: å®Œæ•´ç”¨æˆ·æµç¨‹æµ‹è¯•
4. **å¤šç§Ÿæˆ·æµ‹è¯•**: æ•°æ®éš”ç¦»æµ‹è¯•
5. **æ€§èƒ½æµ‹è¯•**: è´Ÿè½½å’Œå‹åŠ›æµ‹è¯•
6. **å®‰å…¨æµ‹è¯•**: æ¼æ´æ‰«æå’Œæ¸—é€æµ‹è¯•

### æµ‹è¯•å·¥å…·
- Jest: å•å…ƒæµ‹è¯•æ¡†æ¶
- Playwright: E2Eæµ‹è¯•
- Artillery: æ€§èƒ½æµ‹è¯•
- OWASP ZAP: å®‰å…¨æµ‹è¯•

## ğŸš€ éƒ¨ç½²æ–¹æ¡ˆ

### ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
- **å‰ç«¯**: Vercelè‡ªåŠ¨éƒ¨ç½²
- **åç«¯**: Railwayå®¹å™¨éƒ¨ç½²
- **æ•°æ®åº“**: Supabaseæ‰˜ç®¡æ•°æ®åº“
- **æ–‡ä»¶å­˜å‚¨**: AWS S3
- **ç¼“å­˜**: Redis Cloud
- **ç›‘æ§**: Sentry + LogRocket

### æ‰©å±•ç­–ç•¥
- æ°´å¹³æ‰©å±•å’Œè´Ÿè½½å‡è¡¡
- æ•°æ®åº“è¯»å†™åˆ†ç¦»
- CDNåŠ é€Ÿ
- å¾®æœåŠ¡æ¶æ„æ¼”è¿›

## ğŸ”„ æ–‡æ¡£äº¤å‰å¼•ç”¨

### ç›¸å…³æ–‡æ¡£
- ğŸ“„ **[01-corporate-landing.md](./01-corporate-landing.md)**: ä¼ä¸šå®˜ç½‘é¡¹ç›®å®æˆ˜
- ğŸ“„ **[02-ecommerce-store.md](./02-ecommerce-store.md)**: ç”µå•†åº”ç”¨é¡¹ç›®å®æˆ˜
- ğŸ“„ **[03-dashboard-analytics.md](./03-dashboard-analytics.md)**: æ•°æ®ä»ªè¡¨æ¿é¡¹ç›®å®æˆ˜

### å‚è€ƒç« èŠ‚
- ğŸ“– **[Framework Deep Dive - Next.js](../frameworks/nextjs-core.md)**: Next.jsæ ¸å¿ƒç‰¹æ€§æ·±åº¦å­¦ä¹ 
- ğŸ“– **[Database - Multi-tenant Architecture](../knowledge-points/database/multi-tenant.md)**: å¤šç§Ÿæˆ·æ¶æ„æœ€ä½³å®è·µ
- ğŸ“– **[Authentication - NextAuth](../knowledge-points/auth/nextauth.md)**: NextAuth.jsé«˜çº§é…ç½®

## ğŸ“ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹å›é¡¾
1. **å¤šç§Ÿæˆ·æ¶æ„**: æŒæ¡ä¼ä¸šçº§SaaSå¹³å°çš„æ ¸å¿ƒæ¶æ„æ¨¡å¼
2. **è®¢é˜…è®¡è´¹**: å®ç°å®Œæ•´çš„å•†ä¸šæ¨¡å¼å’Œè®¡è´¹ç³»ç»Ÿ
3. **æƒé™ç®¡ç†**: æ„å»ºçµæ´»çš„æƒé™æ§åˆ¶å’Œè®¿é—®ç®¡ç†ç³»ç»Ÿ
4. **å“ç‰Œå®šåˆ¶**: å¼€å‘å¯å®šåˆ¶çš„ç™½æ ‡è§£å†³æ–¹æ¡ˆ
5. **æ€§èƒ½ä¼˜åŒ–**: SaaSåº”ç”¨çš„æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–ç­–ç•¥

### å­¦ä¹ æˆæœæ£€æŸ¥
- [ ] èƒ½å¤Ÿè®¾è®¡å’Œå®ç°å¤šç§Ÿæˆ·SaaSæ¶æ„
- [ ] æŒæ¡è®¢é˜…è®¡è´¹å’Œå•†ä¸šæ¨¡å¼å®ç°
- [ ] æ„å»ºå®Œæ•´çš„æƒé™ç®¡ç†å’Œè®¿é—®æ§åˆ¶ç³»ç»Ÿ
- [ ] å¼€å‘å¯å®šåˆ¶çš„å“ç‰Œå’Œç™½æ ‡è§£å†³æ–¹æ¡ˆ
- [ ] éƒ¨ç½²å’Œè¿ç»´ç”Ÿäº§çº§SaaSåº”ç”¨

## ğŸ¤ è´¡çŒ®ä¸åé¦ˆ

### è´¡çŒ®æŒ‡å—
æ¬¢è¿å¯¹æœ¬é¡¹ç›®å®æˆ˜æ–‡æ¡£æå‡ºæ”¹è¿›å»ºè®®ï¼š
- ğŸ› **BugæŠ¥å‘Š**: å‘ç°æ–‡æ¡£é”™è¯¯æˆ–ä¸å‡†ç¡®ä¹‹å¤„
- ğŸ’¡ **åŠŸèƒ½å»ºè®®**: æå‡ºæ–°çš„SaaSåŠŸèƒ½æˆ–å•†ä¸šæ¨¡å¼
- ğŸ“ **å†…å®¹è´¡çŒ®**: åˆ†äº«æ‚¨çš„SaaSå¼€å‘ç»éªŒ

### åé¦ˆæ¸ é“
- GitHub Issues: [é¡¹ç›®Issuesé¡µé¢]
- Email: dev-quest@example.com
- ç¤¾åŒºè®¨è®º: [å¼€å‘è€…ç¤¾åŒºé“¾æ¥]

## ğŸ”— å¤–éƒ¨èµ„æº

### å®˜æ–¹æ–‡æ¡£
- [Next.js 15 Documentation](https://nextjs.org/docs)
- [Stripe Billing Documentation](https://stripe.com/docs/billing)
- [Prisma Multi-tenant Guide](https://www.prisma.io/docs/guides/performance-and-optimization/multi-tenant-architecture)
- [NextAuth.js Documentation](https://next-auth.js.org/)

### å­¦ä¹ èµ„æº
- [SaaS Architecture Patterns](https://aws.amazon.com/saas/)
- [Multi-tenant SaaS Architecture](https://docs.microsoft.com/en-us/azure/architecture/patterns/multi-tenant-saas)
- [Building SaaS Products](https://www.saasclub.io/)

### å·¥å…·å’Œå¹³å°
- [Vercel](https://vercel.com/) - éƒ¨ç½²å¹³å°
- [Stripe](https://stripe.com/) - æ”¯ä»˜å’Œè®¡è´¹
- [Supabase](https://supabase.com/) - åç«¯å³æœåŠ¡
- [Sentry](https://sentry.io/) - é”™è¯¯ç›‘æ§

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ | ğŸš§ è¿›è¡Œä¸­ | ğŸ“‹ è®¡åˆ’ä¸­
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ
**ç‰ˆæœ¬**: v1.0.0