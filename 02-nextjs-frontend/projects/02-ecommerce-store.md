# Next.js 15 ç”µå•†åº”ç”¨å¼€å‘å®æˆ˜

> é€šè¿‡æ„å»ºä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„ç”µå•†åº”ç”¨ï¼ŒæŒæ¡ç°ä»£Webç”µå•†å¼€å‘çš„æ ¸å¿ƒæŠ€æœ¯ã€‚æœ¬é¡¹ç›®æ¶µç›–å•†å“å±•ç¤ºã€è´­ç‰©è½¦ã€è®¢å•ç®¡ç†ã€æ”¯ä»˜é›†æˆã€åº“å­˜ç®¡ç†ç­‰ç”µå•†ç³»ç»Ÿçš„å…³é”®åŠŸèƒ½æ¨¡å—ã€‚

**ç›®æ ‡è¯»è€…**: æœ‰Next.jsåŸºç¡€ï¼Œå¸Œæœ›å­¦ä¹ ä¼ä¸šçº§ç”µå•†åº”ç”¨å¼€å‘çš„å¼€å‘è€…
**å‰ç½®çŸ¥è¯†**: Next.jsåŸºç¡€ã€ReactçŠ¶æ€ç®¡ç†ã€APIè®¾è®¡ã€æ•°æ®åº“åŸºç¡€
**é¢„è®¡æ—¶é•¿**: 3-4å‘¨

## ğŸ“š æ–‡æ¡£å…ƒæ•°æ®
| å±æ€§ | å†…å®¹ |
|------|------|
| **æ¨¡å—** | `02-nextjs-frontend` |
| **åˆ†ç±»** | `projects` |
| **éš¾åº¦** | â­â­â­â­â­ (5/5æ˜Ÿ) |
| **æ ‡ç­¾** | `Next.js 15` `React 19` `TypeScript 5` `ç”µå•†ç³»ç»Ÿ` `æ”¯ä»˜é›†æˆ` `Stripe` |
| **æ›´æ–°æ—¥æœŸ** | `2025å¹´10æœˆ` |
| **ä½œè€…** | Dev Quest Team |
| **çŠ¶æ€** | âœ… å·²å®Œæˆ |

## ğŸ¯ å­¦ä¹ ç›®æ ‡
- æ„å»ºå®Œæ•´çš„ç”µå•†å‰ç«¯åº”ç”¨æ¶æ„
- å®ç°è´­ç‰©è½¦å’Œå•†å“ç®¡ç†ç³»ç»Ÿ
- é›†æˆStripeæ”¯ä»˜ç³»ç»Ÿ
- å¼€å‘ç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†
- å®ç°è®¢å•å¤„ç†å’Œåº“å­˜ç®¡ç†
- æŒæ¡ç”µå•†SEOå’Œæ€§èƒ½ä¼˜åŒ–
- éƒ¨ç½²ç”Ÿäº§çº§ç”µå•†åº”ç”¨

## ğŸ“– é¡¹ç›®æ¦‚è¿°

### é¡¹ç›®èƒŒæ™¯
ç”µå•†åº”ç”¨æ˜¯ç°ä»£å•†ä¸šçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œéœ€è¦å¤„ç†å¤æ‚çš„ä¸šåŠ¡é€»è¾‘ã€é«˜å¹¶å‘è®¿é—®ã€å®‰å…¨æ”¯ä»˜ç­‰æŒ‘æˆ˜ã€‚æœ¬é¡¹ç›®å°†æ„å»ºä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„B2Cç”µå•†å¹³å°ã€‚

### æ ¸å¿ƒåŠŸèƒ½
- ğŸ›ï¸ å•†å“å±•ç¤ºå’Œæœç´¢ç³»ç»Ÿ
- ğŸ›’ è´­ç‰©è½¦å’Œæ”¶è—å¤¹åŠŸèƒ½
- ğŸ‘¤ ç”¨æˆ·æ³¨å†Œç™»å½•å’Œä¸ªäººä¸­å¿ƒ
- ğŸ’³ å¤šç§æ”¯ä»˜æ–¹å¼é›†æˆ
- ğŸ“¦ è®¢å•ç®¡ç†å’Œç‰©æµè¿½è¸ª
- ğŸ·ï¸ ä¼˜æƒ åˆ¸å’Œä¿ƒé”€ç³»ç»Ÿ
- ğŸ“Š æ•°æ®åˆ†æå’ŒæŠ¥è¡¨
- ğŸ”” å®æ—¶é€šçŸ¥å’Œæ¶ˆæ¯ç³»ç»Ÿ

### æŠ€æœ¯æ ˆ
- **å‰ç«¯æ¡†æ¶**: Next.js 15 + React 19
- **å¼€å‘è¯­è¨€**: TypeScript 5
- **çŠ¶æ€ç®¡ç†**: Zustand + React Query
- **UIç»„ä»¶åº“**: Radix UI + Tailwind CSS
- **æ•°æ®åº“**: PostgreSQL + Prisma ORM
- **æ”¯ä»˜ç³»ç»Ÿ**: Stripe + Webhookå¤„ç†
- **è®¤è¯**: NextAuth.js v5
- **æ–‡ä»¶å­˜å‚¨**: AWS S3/Cloudinary
- **éƒ¨ç½²**: Vercel + Railway/Supabase

## ğŸ—ï¸ é¡¹ç›®æ¶æ„

### ç›®å½•ç»“æ„
```
ecommerce-store/
â”œâ”€â”€ app/                          # App Routerç›®å½•
â”‚   â”œâ”€â”€ (auth)/                   # è®¤è¯ç›¸å…³è·¯ç”±ç»„
â”‚   â”‚   â”œâ”€â”€ login/               # ç™»å½•é¡µé¢
â”‚   â”‚   â”œâ”€â”€ register/            # æ³¨å†Œé¡µé¢
â”‚   â”‚   â””â”€â”€ layout.tsx           # è®¤è¯å¸ƒå±€
â”‚   â”œâ”€â”€ (shop)/                  # å•†åº—ç›¸å…³è·¯ç”±ç»„
â”‚   â”‚   â”œâ”€â”€ products/            # å•†å“é¡µé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ [slug]/         # å•†å“è¯¦æƒ…
â”‚   â”‚   â”‚   â””â”€â”€ category/[category]/ # åˆ†ç±»é¡µé¢
â”‚   â”‚   â”œâ”€â”€ cart/               # è´­ç‰©è½¦
â”‚   â”‚   â”œâ”€â”€ checkout/           # ç»“è´¦æµç¨‹
â”‚   â”‚   â””â”€â”€ layout.tsx          # å•†åº—å¸ƒå±€
â”‚   â”œâ”€â”€ account/                 # ç”¨æˆ·ä¸­å¿ƒ
â”‚   â”‚   â”œâ”€â”€ orders/             # è®¢å•ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ profile/            # ä¸ªäººèµ„æ–™
â”‚   â”‚   â”œâ”€â”€ wishlist/           # æ”¶è—å¤¹
â”‚   â”‚   â””â”€â”€ layout.tsx          # è´¦æˆ·å¸ƒå±€
â”‚   â”œâ”€â”€ admin/                   # ç®¡ç†åå°
â”‚   â”‚   â”œâ”€â”€ products/           # å•†å“ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ orders/             # è®¢å•ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ customers/          # å®¢æˆ·ç®¡ç†
â”‚   â”‚   â””â”€â”€ layout.tsx          # ç®¡ç†å¸ƒå±€
â”‚   â”œâ”€â”€ api/                     # APIè·¯ç”±
â”‚   â”‚   â”œâ”€â”€ auth/               # è®¤è¯API
â”‚   â”‚   â”œâ”€â”€ products/           # å•†å“API
â”‚   â”‚   â”œâ”€â”€ cart/               # è´­ç‰©è½¦API
â”‚   â”‚   â”œâ”€â”€ orders/             # è®¢å•API
â”‚   â”‚   â”œâ”€â”€ payments/           # æ”¯ä»˜API
â”‚   â”‚   â””â”€â”€ webhooks/           # Webhookå¤„ç†
â”‚   â”œâ”€â”€ globals.css             # å…¨å±€æ ·å¼
â”‚   â”œâ”€â”€ layout.tsx              # æ ¹å¸ƒå±€
â”‚   â””â”€â”€ page.tsx                # é¦–é¡µ
â”œâ”€â”€ components/                  # ç»„ä»¶åº“
â”‚   â”œâ”€â”€ ui/                     # UIåŸºç¡€ç»„ä»¶
â”‚   â”œâ”€â”€ shop/                   # å•†åº—ç»„ä»¶
â”‚   â”œâ”€â”€ account/                # è´¦æˆ·ç»„ä»¶
â”‚   â”œâ”€â”€ admin/                  # ç®¡ç†ç»„ä»¶
â”‚   â”œâ”€â”€ layout/                 # å¸ƒå±€ç»„ä»¶
â”‚   â””â”€â”€ forms/                  # è¡¨å•ç»„ä»¶
â”œâ”€â”€ lib/                        # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ db/                     # æ•°æ®åº“é…ç½®
â”‚   â”œâ”€â”€ auth/                   # è®¤è¯é…ç½®
â”‚   â”œâ”€â”€ payments/               # æ”¯ä»˜å¤„ç†
â”‚   â”œâ”€â”€ email/                  # é‚®ä»¶æœåŠ¡
â”‚   â”œâ”€â”€ validations/            # è¡¨å•éªŒè¯
â”‚   â””â”€â”€ utils/                  # é€šç”¨å·¥å…·
â”œâ”€â”€ hooks/                      # è‡ªå®šä¹‰Hooks
â”œâ”€â”€ store/                      # çŠ¶æ€ç®¡ç†
â”œâ”€â”€ types/                      # TypeScriptç±»å‹
â”œâ”€â”€ prisma/                     # Prismaé…ç½®
â”‚   â”œâ”€â”€ schema.prisma           # æ•°æ®åº“æ¨¡å‹
â”‚   â””â”€â”€ migrations/             # æ•°æ®åº“è¿ç§»
â”œâ”€â”€ public/                     # é™æ€èµ„æº
â””â”€â”€ middleware.ts              # ä¸­é—´ä»¶
```

### æ•°æ®åº“è®¾è®¡
```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  password  String
  role      Role     @default(CUSTOMER)
  avatar    String?
  phone     String?
  address   Address[]
  orders    Order[]
  cartItems CartItem[]
  wishlist  WishlistItem[]
  reviews   Review[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Address {
  id         String  @id @default(cuid())
  userId     String
  type       AddressType
  street     String
  city       String
  state      String
  zipCode    String
  country    String
  isDefault  Boolean @default(false)
  user       User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders     Order[]
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("addresses")
}

model Product {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  price       Float
  comparePrice Float?
  cost        Float?
  sku         String   @unique
  trackInventory Boolean @default(true)
  status      ProductStatus @default(ACTIVE)
  categoryId  String
  category    Category @relation(fields: [categoryId], references: [id])
  images      ProductImage[]
  variants    ProductVariant[]
  cartItems   CartItem[]
  orderItems  OrderItem[]
  reviews     Review[]
  wishlist    WishlistItem[]
  inventory   Inventory?
  tags        ProductTag[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("products")
}

model Category {
  id          String     @id @default(cuid())
  name        String
  slug        String     @unique
  description String?
  image       String?
  parentId    String?
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  products    Product[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@map("categories")
}

model ProductVariant {
  id        String   @id @default(cuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  name      String
  sku       String   @unique
  price     Float
  inventory Int      @default(0)
  options   VariantOption[]
  cartItems CartItem[]
  orderItems OrderItem[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("product_variants")
}

model VariantOption {
  id               String           @id @default(cuid())
  productVariantId String
  productVariant   ProductVariant   @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  name             String
  value            String
  createdAt        DateTime         @default(now())

  @@map("variant_options")
}

model ProductImage {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  url       String
  alt       String?
  position  Int     @default(0)
  createdAt DateTime @default(now())

  @@map("product_images")
}

model Cart {
  id        String     @id @default(cuid())
  userId    String?    @unique
  sessionId String?    @unique
  items     CartItem[]
  expiresAt DateTime   @default(dbnow()) + interval '7 days'
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@map("carts")
}

model CartItem {
  id              String          @id @default(cuid())
  cartId          String
  cart            Cart            @relation(fields: [cartId], references: [id], onDelete: Cascade)
  productId       String
  product         Product         @relation(fields: [productId], references: [id])
  productVariantId String?
  productVariant  ProductVariant? @relation(fields: [productVariantId], references: [id])
  quantity        Int
  unitPrice       Float
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@map("cart_items")
}

model Order {
  id              String     @id @default(cuid())
  orderNumber     String     @unique
  userId          String?
  user            User?      @relation(fields: [userId], references: [id])
  email           String
  status          OrderStatus @default(PENDING)
  paymentStatus   PaymentStatus @default(PENDING)
  paymentMethod   String?
  currency        String     @default("USD")
  subtotal        Float
  tax             Float
  shipping        Float
  discount        Float      @default(0)
  total           Float
  shippingAddress Address?
  billingAddress  Address?
  items           OrderItem[]
  transactions    PaymentTransaction[]
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@map("orders")
}

model OrderItem {
  id              String          @id @default(cuid())
  orderId         String
  order           Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId       String
  product         Product         @relation(fields: [productId], references: [id])
  productVariantId String?
  productVariant  ProductVariant? @relation(fields: [productVariantId], references: [id])
  quantity        Int
  unitPrice       Float
  total           Float
  createdAt       DateTime        @default(now())

  @@map("order_items")
}

model PaymentTransaction {
  id                String               @id @default(cuid())
  orderId           String
  order             Order                @relation(fields: [orderId], references: [id], onDelete: Cascade)
  paymentIntentId   String?              @unique
  amount            Float
  currency          String
  status            PaymentTransactionStatus
  paymentMethod     String
  provider          String               @default("stripe")
  metadata          Json?
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt

  @@map("payment_transactions")
}

model Review {
  id        String   @id @default(cuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  rating    Int
  title     String?
  content   String?
  verified  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([productId, userId])
  @@map("reviews")
}

model WishlistItem {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, productId])
  @@map("wishlist_items")
}

model Coupon {
  id          String       @id @default(cuid())
  code        String       @unique
  type        CouponType
  value       Float
  minAmount   Float?
  maxUsage    Int?
  usedCount   Int          @default(0)
  expiresAt   DateTime?
  isActive    Boolean      @default(true)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@map("coupons")
}

enum Role {
  CUSTOMER
  ADMIN
  SUPER_ADMIN
}

enum ProductStatus {
  ACTIVE
  DRAFT
  ARCHIVED
}

enum AddressType {
  SHIPPING
  BILLING
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

enum PaymentTransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum CouponType {
  PERCENTAGE
  FIXED_AMOUNT
}
```

## ğŸ› ï¸ å®æˆ˜æ­¥éª¤

### æ­¥éª¤ä¸€ï¼šé¡¹ç›®åˆå§‹åŒ–

#### 1.1 åˆ›å»ºNext.jsé¡¹ç›®
```bash
# åˆ›å»ºNext.js 15é¡¹ç›®
npx create-next-app@latest ecommerce-store --typescript --tailwind --eslint --app

# è¿›å…¥é¡¹ç›®ç›®å½•
cd ecommerce-store

# å®‰è£…å¿…è¦ä¾èµ–
npm install @prisma/client prisma
npm install @auth/prisma-adapter next-auth
npm install @radix-ui/react-dialog @radix-ui/react-dropdown-menu
npm install @radix-ui/react-select @radix-ui/react-tabs
npm install @radix-ui/react-toast @radix-ui/react-tooltip
npm install @hookform/resolvers react-hook-form zod
npm install @tanstack/react-query zustand
npm install stripe lucide-react clsx tailwind-merge
npm install date-fns rehype-highlight remark-gfm
npm install @types/stripe @types/node

# å®‰è£…å¼€å‘ä¾èµ–
npm install -D @tailwindcss/typography
npm install -D eslint-config-prettier prettier
```

#### 1.2 é…ç½®Prisma
```bash
# åˆå§‹åŒ–Prisma
npx prisma init

# åˆ›å»ºæ•°æ®åº“å¹¶ç”Ÿæˆè¿ç§»
npx prisma migrate dev --name init

# ç”ŸæˆPrismaå®¢æˆ·ç«¯
npx prisma generate
```

#### 1.3 é…ç½®Tailwind CSSæ‰©å±•
**tailwind.config.ts**:
```typescript
import type { Config } from 'tailwindcss'
import typography from '@tailwindcss/typography'

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          200: '#bae6fd',
          300: '#7dd3fc',
          400: '#38bdf8',
          500: '#0ea5e9',
          600: '#0284c7',
          700: '#0369a1',
          800: '#075985',
          900: '#0c4a6e',
        },
        secondary: {
          50: '#f8fafc',
          100: '#f1f5f9',
          200: '#e2e8f0',
          300: '#cbd5e1',
          400: '#94a3b8',
          500: '#64748b',
          600: '#475569',
          700: '#334155',
          800: '#1e293b',
          900: '#0f172a',
        },
        success: {
          50: '#f0fdf4',
          500: '#22c55e',
          600: '#16a34a',
        },
        warning: {
          50: '#fffbeb',
          500: '#f59e0b',
          600: '#d97706',
        },
        error: {
          50: '#fef2f2',
          500: '#ef4444',
          600: '#dc2626',
        },
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
      },
      animation: {
        'fade-in': 'fadeIn 0.5s ease-in-out',
        'slide-up': 'slideUp 0.5s ease-out',
        'scale-in': 'scaleIn 0.2s ease-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { transform: 'translateY(20px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
        scaleIn: {
          '0%': { transform: 'scale(0.95)', opacity: '0' },
          '100%': { transform: 'scale(1)', opacity: '1' },
        },
      },
    },
  },
  plugins: [typography],
}
export default config
```

### æ­¥éª¤äºŒï¼šæ ¸å¿ƒåŠŸèƒ½å¼€å‘

#### 2.1 å®ç°è®¤è¯ç³»ç»Ÿ
**lib/auth/config.ts**:
```typescript
import { NextAuthConfig } from 'next-auth'
import { PrismaAdapter } from '@auth/prisma-adapter'
import Google from 'next-auth/providers/google'
import Credentials from 'next-auth/providers/credentials'
import { z } from 'zod'
import { prisma } from '@/lib/db/prisma'
import bcrypt from 'bcryptjs'

const credentialsSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
})

export const authConfig: NextAuthConfig = {
  adapter: PrismaAdapter(prisma),
  providers: [
    Google({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    Credentials({
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        const parsedCredentials = credentialsSchema.safeParse(credentials)

        if (!parsedCredentials.success) {
          return null
        }

        const { email, password } = parsedCredentials.data

        const user = await prisma.user.findUnique({
          where: { email },
        })

        if (!user || !user.password) {
          return null
        }

        const isPasswordValid = await bcrypt.compare(password, user.password)

        if (!isPasswordValid) {
          return null
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
        }
      },
    }),
  ],
  pages: {
    signIn: '/login',
    signUp: '/register',
    error: '/auth/error',
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.role = user.role
      }
      return token
    },
    async session({ session, token }) {
      if (token.sub) {
        session.user.id = token.sub
      }
      if (token.role) {
        session.user.role = token.role as string
      }
      return session
    },
  },
  session: {
    strategy: 'jwt',
  },
}
```

**app/api/auth/[...nextauth]/route.ts**:
```typescript
import NextAuth from 'next-auth'
import { authConfig } from '@/lib/auth/config'

const handler = NextAuth(authConfig)

export { handler as GET, handler as POST }
```

#### 2.2 å®ç°å•†å“ç®¡ç†
**app/api/products/route.ts**:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db/prisma'
import { z } from 'zod'

const productQuerySchema = z.object({
  page: z.string().optional().transform(val => val ? parseInt(val) : 1),
  limit: z.string().optional().transform(val => val ? parseInt(val) : 12),
  category: z.string().optional(),
  search: z.string().optional(),
  sort: z.enum(['name', 'price', 'createdAt']).optional(),
  order: z.enum(['asc', 'desc']).optional(),
  minPrice: z.string().optional().transform(val => val ? parseFloat(val) : undefined),
  maxPrice: z.string().optional().transform(val => val ? parseFloat(val) : undefined),
})

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const query = productQuerySchema.parse(Object.fromEntries(searchParams))

    const where: any = {
      status: 'ACTIVE',
    }

    if (query.category) {
      where.category = {
        slug: query.category,
      }
    }

    if (query.search) {
      where.OR = [
        { name: { contains: query.search, mode: 'insensitive' } },
        { description: { contains: query.search, mode: 'insensitive' } },
      ]
    }

    if (query.minPrice !== undefined || query.maxPrice !== undefined) {
      where.price = {}
      if (query.minPrice !== undefined) {
        where.price.gte = query.minPrice
      }
      if (query.maxPrice !== undefined) {
        where.price.lte = query.maxPrice
      }
    }

    const orderBy: any = {}
    if (query.sort) {
      orderBy[query.sort] = query.order || 'asc'
    } else {
      orderBy.createdAt = 'desc'
    }

    const [products, total] = await Promise.all([
      prisma.product.findMany({
        where,
        include: {
          category: true,
          images: {
            orderBy: { position: 'asc' },
          },
          variants: {
            include: {
              options: true,
            },
          },
          reviews: {
            select: {
              rating: true,
            },
          },
        },
        orderBy,
        skip: (query.page - 1) * query.limit,
        take: query.limit,
      }),
      prisma.product.count({ where }),
    ])

    // è®¡ç®—å¹³å‡è¯„åˆ†
    const productsWithRating = products.map(product => ({
      ...product,
      averageRating: product.reviews.length > 0
        ? product.reviews.reduce((sum, review) => sum + review.rating, 0) / product.reviews.length
        : 0,
      reviewCount: product.reviews.length,
      reviews: undefined, // ç§»é™¤åŸå§‹è¯„è®ºæ•°æ®
    }))

    return NextResponse.json({
      products: productsWithRating,
      pagination: {
        page: query.page,
        limit: query.limit,
        total,
        pages: Math.ceil(total / query.limit),
      },
    })
  } catch (error) {
    console.error('Products API error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

const createProductSchema = z.object({
  name: z.string().min(1),
  slug: z.string().min(1),
  description: z.string().optional(),
  price: z.number().positive(),
  comparePrice: z.number().positive().optional(),
  cost: z.number().positive().optional(),
  sku: z.string().min(1),
  categoryId: z.string(),
  trackInventory: z.boolean().default(true),
  images: z.array(z.object({
    url: z.string().url(),
    alt: z.string().optional(),
    position: z.number().default(0),
  })).optional(),
  variants: z.array(z.object({
    name: z.string(),
    sku: z.string(),
    price: z.number().positive(),
    inventory: z.number().default(0),
    options: z.array(z.object({
      name: z.string(),
      value: z.string(),
    })),
  })).optional(),
})

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const validatedData = createProductSchema.parse(body)

    const product = await prisma.product.create({
      data: {
        ...validatedData,
        images: {
          create: validatedData.images || [],
        },
        variants: {
          create: validatedData.variants || [],
        },
      },
      include: {
        category: true,
        images: {
          orderBy: { position: 'asc' },
        },
        variants: {
          include: {
            options: true,
          },
        },
      },
    })

    return NextResponse.json(product, { status: 201 })
  } catch (error) {
    console.error('Create product error:', error)
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid data', details: error.errors },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

#### 2.3 å®ç°è´­ç‰©è½¦åŠŸèƒ½
**lib/cart/cart.ts**:
```typescript
import { prisma } from '@/lib/db/prisma'
import { getServerSession } from 'next-auth'
import { authConfig } from '@/lib/auth/config'
import { cookies } from 'next/headers'

export interface CartItem {
  id: string
  productId: string
  productVariantId?: string
  quantity: number
  unitPrice: number
  product: {
    id: string
    name: string
    slug: string
    images: { url: string; alt?: string }[]
  }
  productVariant?: {
    id: string
    name: string
    sku: string
    options: { name: string; value: string }[]
  }
}

export interface Cart {
  id: string
  items: CartItem[]
  subtotal: number
  total: number
}

export async function getCart(): Promise<Cart> {
  const session = await getServerSession(authConfig)
  const cookieStore = cookies()
  const cartId = cookieStore.get('cartId')?.value

  let cart

  if (session?.user?.id) {
    // ç”¨æˆ·å·²ç™»å½•ï¼Œè·å–ç”¨æˆ·è´­ç‰©è½¦
    cart = await prisma.cart.findUnique({
      where: { userId: session.user.id },
      include: {
        items: {
          include: {
            product: {
              include: {
                images: {
                  orderBy: { position: 'asc' },
                  take: 1,
                },
              },
            },
            productVariant: {
              include: {
                options: true,
              },
            },
          },
        },
      },
    })
  } else if (cartId) {
    // æ¸¸å®¢ç”¨æˆ·ï¼Œè·å–ä¼šè¯è´­ç‰©è½¦
    cart = await prisma.cart.findUnique({
      where: { sessionId: cartId },
      include: {
        items: {
          include: {
            product: {
              include: {
                images: {
                  orderBy: { position: 'asc' },
                  take: 1,
                },
              },
            },
            productVariant: {
              include: {
                options: true,
              },
            },
          },
        },
      },
    })
  }

  if (!cart) {
    return {
      id: '',
      items: [],
      subtotal: 0,
      total: 0,
    }
  }

  const subtotal = cart.items.reduce(
    (sum, item) => sum + item.unitPrice * item.quantity,
    0
  )

  return {
    id: cart.id,
    items: cart.items.map(item => ({
      ...item,
      product: {
        id: item.product.id,
        name: item.product.name,
        slug: item.product.slug,
        images: item.product.images,
      },
    })),
    subtotal,
    total: subtotal, // è¿™é‡Œå¯ä»¥æ·»åŠ ç¨è´¹å’Œè¿è´¹è®¡ç®—
  }
}

export async function addToCart(
  productId: string,
  quantity: number,
  productVariantId?: string
): Promise<Cart> {
  const session = await getServerSession(authConfig)
  const cookieStore = cookies()
  const cartId = cookieStore.get('cartId')?.value

  // è·å–äº§å“ä¿¡æ¯
  const product = await prisma.product.findUnique({
    where: { id: productId },
    include: {
      variants: true,
    },
  })

  if (!product) {
    throw new Error('Product not found')
  }

  let variant
  if (productVariantId) {
    variant = product.variants.find(v => v.id === productVariantId)
    if (!variant) {
      throw new Error('Product variant not found')
    }
  }

  const unitPrice = variant?.price || product.price

  let cart

  if (session?.user?.id) {
    // ç”¨æˆ·å·²ç™»å½•
    cart = await prisma.cart.upsert({
      where: { userId: session.user.id },
      update: {},
      create: {
        userId: session.user.id,
      },
      include: {
        items: true,
      },
    })
  } else {
    // æ¸¸å®¢ç”¨æˆ·
    if (!cartId) {
      // åˆ›å»ºæ–°è´­ç‰©è½¦
      const newCart = await prisma.cart.create({
        data: {
          sessionId: crypto.randomUUID(),
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7å¤©åè¿‡æœŸ
        },
      })

      cookieStore.set('cartId', newCart.sessionId!, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60, // 7å¤©
      })

      cart = newCart
    } else {
      cart = await prisma.cart.findUnique({
        where: { sessionId: cartId },
        include: { items: true },
      })
    }
  }

  if (!cart) {
    throw new Error('Failed to create or retrieve cart')
  }

  // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„å•†å“
  const existingItem = cart.items.find(
    item =>
      item.productId === productId &&
      item.productVariantId === productVariantId
  )

  if (existingItem) {
    // æ›´æ–°æ•°é‡
    await prisma.cartItem.update({
      where: { id: existingItem.id },
      data: {
        quantity: existingItem.quantity + quantity,
      },
    })
  } else {
    // æ·»åŠ æ–°å•†å“
    await prisma.cartItem.create({
      data: {
        cartId: cart.id,
        productId,
        productVariantId,
        quantity,
        unitPrice,
      },
    })
  }

  return getCart()
}

export async function updateCartItem(
  itemId: string,
  quantity: number
): Promise<Cart> {
  if (quantity <= 0) {
    await prisma.cartItem.delete({
      where: { id: itemId },
    })
  } else {
    await prisma.cartItem.update({
      where: { id: itemId },
      data: { quantity },
    })
  }

  return getCart()
}

export async function removeFromCart(itemId: string): Promise<Cart> {
  await prisma.cartItem.delete({
    where: { id: itemId },
  })

  return getCart()
}

export async function clearCart(): Promise<void> {
  const session = await getServerSession(authConfig)
  const cookieStore = cookies()
  const cartId = cookieStore.get('cartId')?.value

  if (session?.user?.id) {
    await prisma.cartItem.deleteMany({
      where: {
        cart: {
          userId: session.user.id,
        },
      },
    })
  } else if (cartId) {
    await prisma.cartItem.deleteMany({
      where: {
        cart: {
          sessionId: cartId,
        },
      },
    })
  }
}
```

**app/api/cart/route.ts**:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getCart } from '@/lib/cart/cart'

export async function GET() {
  try {
    const cart = await getCart()
    return NextResponse.json(cart)
  } catch (error) {
    console.error('Get cart error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

**app/api/cart/add/route.ts**:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { addToCart } from '@/lib/cart/cart'

const addToCartSchema = z.object({
  productId: z.string(),
  quantity: z.number().positive(),
  productVariantId: z.string().optional(),
})

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { productId, quantity, productVariantId } = addToCartSchema.parse(body)

    const cart = await addToCart(productId, quantity, productVariantId)

    return NextResponse.json(cart)
  } catch (error) {
    console.error('Add to cart error:', error)
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid data', details: error.errors },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

#### 2.4 å®ç°æ”¯ä»˜é›†æˆ
**lib/payments/stripe.ts**:
```typescript
import Stripe from 'stripe'
import { prisma } from '@/lib/db/prisma'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-06-20',
})

export interface CreatePaymentIntentParams {
  orderId: string
  amount: number
  currency?: string
}

export async function createPaymentIntent({
  orderId,
  amount,
  currency = 'usd',
}: CreatePaymentIntentParams) {
  try {
    // åˆ›å»ºæ”¯ä»˜æ„å›¾
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(amount * 100), // Stripeä½¿ç”¨åˆ†ä¸ºå•ä½
      currency,
      metadata: {
        orderId,
      },
      automatic_payment_methods: {
        enabled: true,
      },
    })

    // ä¿å­˜äº¤æ˜“è®°å½•
    await prisma.paymentTransaction.create({
      data: {
        orderId,
        paymentIntentId: paymentIntent.id,
        amount,
        currency,
        status: 'PENDING',
        paymentMethod: 'stripe',
        provider: 'stripe',
      },
    })

    return {
      clientSecret: paymentIntent.client_secret,
      paymentIntentId: paymentIntent.id,
    }
  } catch (error) {
    console.error('Create payment intent error:', error)
    throw new Error('Failed to create payment intent')
  }
}

export async function confirmPayment(paymentIntentId: string) {
  try {
    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId)

    if (paymentIntent.status === 'succeeded') {
      // æ›´æ–°äº¤æ˜“çŠ¶æ€
      await prisma.paymentTransaction.updateMany({
        where: {
          paymentIntentId,
        },
        data: {
          status: 'COMPLETED',
        },
      })

      // æ›´æ–°è®¢å•çŠ¶æ€
      const orderId = paymentIntent.metadata.orderId
      if (orderId) {
        await prisma.order.update({
          where: { id: orderId },
          data: {
            status: 'CONFIRMED',
            paymentStatus: 'COMPLETED',
          },
        })
      }
    }

    return paymentIntent
  } catch (error) {
    console.error('Confirm payment error:', error)
    throw new Error('Failed to confirm payment')
  }
}

export async function handleStripeWebhook(
  payload: string,
  signature: string
) {
  let event: Stripe.Event

  try {
    event = stripe.webhooks.constructEvent(
      payload,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    )
  } catch (error) {
    console.error('Webhook signature verification failed:', error)
    throw new Error('Invalid signature')
  }

  switch (event.type) {
    case 'payment_intent.succeeded':
      await handlePaymentSucceeded(event.data.object as Stripe.PaymentIntent)
      break
    case 'payment_intent.payment_failed':
      await handlePaymentFailed(event.data.object as Stripe.PaymentIntent)
      break
    default:
      console.log(`Unhandled event type: ${event.type}`)
  }

  return event
}

async function handlePaymentSucceeded(paymentIntent: Stripe.PaymentIntent) {
  const orderId = paymentIntent.metadata.orderId

  if (!orderId) {
    console.error('No order ID in payment intent metadata')
    return
  }

  await prisma.$transaction(async (tx) => {
    // æ›´æ–°æ”¯ä»˜äº¤æ˜“çŠ¶æ€
    await tx.paymentTransaction.updateMany({
      where: {
        paymentIntentId: paymentIntent.id,
      },
      data: {
        status: 'COMPLETED',
      },
    })

    // æ›´æ–°è®¢å•çŠ¶æ€
    await tx.order.update({
      where: { id: orderId },
      data: {
        status: 'CONFIRMED',
        paymentStatus: 'COMPLETED',
      },
    })

    // å‡å°‘åº“å­˜
    const order = await tx.order.findUnique({
      where: { id: orderId },
      include: {
        items: true,
      },
    })

    if (order) {
      for (const item of order.items) {
        if (item.productVariantId) {
          await tx.productVariant.update({
            where: { id: item.productVariantId },
            data: {
              inventory: {
                decrement: item.quantity,
              },
            },
          })
        } else {
          // å¦‚æœæ²¡æœ‰å˜ä½“ï¼Œå‡å°‘ä¸»äº§å“åº“å­˜
          await tx.product.update({
            where: { id: item.productId },
            data: {
              // è¿™é‡Œéœ€è¦åœ¨äº§å“è¡¨ä¸­æ·»åŠ inventoryå­—æ®µ
              // inventory: { decrement: item.quantity },
            },
          })
        }
      }
    }
  })

  // å‘é€ç¡®è®¤é‚®ä»¶ï¼ˆè¿™é‡Œéœ€è¦å®ç°é‚®ä»¶å‘é€é€»è¾‘ï¼‰
  console.log(`Payment succeeded for order: ${orderId}`)
}

async function handlePaymentFailed(paymentIntent: Stripe.PaymentIntent) {
  const orderId = paymentIntent.metadata.orderId

  if (!orderId) {
    console.error('No order ID in payment intent metadata')
    return
  }

  await prisma.$transaction(async (tx) => {
    // æ›´æ–°æ”¯ä»˜äº¤æ˜“çŠ¶æ€
    await tx.paymentTransaction.updateMany({
      where: {
        paymentIntentId: paymentIntent.id,
      },
      data: {
        status: 'FAILED',
      },
    })

    // æ›´æ–°è®¢å•çŠ¶æ€
    await tx.order.update({
      where: { id: orderId },
      data: {
        status: 'CANCELLED',
        paymentStatus: 'FAILED',
      },
    })
  })

  // å‘é€å¤±è´¥é€šçŸ¥é‚®ä»¶
  console.log(`Payment failed for order: ${orderId}`)
}
```

**app/api/payments/create-intent/route.ts**:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authConfig } from '@/lib/auth/config'
import { createPaymentIntent } from '@/lib/payments/stripe'
import { prisma } from '@/lib/db/prisma'
import { z } from 'zod'

const createIntentSchema = z.object({
  orderId: z.string(),
})

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authConfig)
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const body = await request.json()
    const { orderId } = createIntentSchema.parse(body)

    // è·å–è®¢å•ä¿¡æ¯
    const order = await prisma.order.findUnique({
      where: { id: orderId },
    })

    if (!order) {
      return NextResponse.json(
        { error: 'Order not found' },
        { status: 404 }
      )
    }

    if (order.userId !== session.user.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    if (order.paymentStatus !== 'PENDING') {
      return NextResponse.json(
        { error: 'Order already paid or cancelled' },
        { status: 400 }
      )
    }

    const result = await createPaymentIntent({
      orderId,
      amount: order.total,
      currency: order.currency,
    })

    return NextResponse.json(result)
  } catch (error) {
    console.error('Create payment intent error:', error)
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid data', details: error.errors },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

#### 2.5 å®ç°è®¢å•ç®¡ç†
**lib/orders/order.ts**:
```typescript
import { prisma } from '@/lib/db/prisma'
import { getCart } from '@/lib/cart/cart'
import { clearCart } from '@/lib/cart/cart'

export interface CreateOrderParams {
  email: string
  shippingAddressId: string
  billingAddressId?: string
  paymentMethod: string
  couponCode?: string
}

export async function createOrder({
  email,
  shippingAddressId,
  billingAddressId,
  paymentMethod,
  couponCode,
}: CreateOrderParams) {
  const cart = await getCart()

  if (cart.items.length === 0) {
    throw new Error('Cart is empty')
  }

  // éªŒè¯åœ°å€
  const shippingAddress = await prisma.address.findUnique({
    where: { id: shippingAddressId },
  })

  if (!shippingAddress) {
    throw new Error('Shipping address not found')
  }

  const billingAddress = billingAddressId
    ? await prisma.address.findUnique({
        where: { id: billingAddressId },
      })
    : shippingAddress

  if (!billingAddress) {
    throw new Error('Billing address not found')
  }

  // è®¡ç®—è®¢å•æ€»é¢
  const subtotal = cart.subtotal
  let tax = subtotal * 0.08 // 8% ç¨ç‡
  let shipping = 0
  let discount = 0

  // åº”ç”¨ä¼˜æƒ åˆ¸
  if (couponCode) {
    const coupon = await prisma.coupon.findUnique({
      where: {
        code: couponCode.toUpperCase(),
        isActive: true,
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: new Date() } },
        ],
      },
    })

    if (coupon) {
      if (coupon.minAmount && subtotal < coupon.minAmount) {
        throw new Error(`Minimum order amount is $${coupon.minAmount}`)
      }

      if (coupon.maxUsage && coupon.usedCount >= coupon.maxUsage) {
        throw new Error('Coupon has reached maximum usage')
      }

      if (coupon.type === 'PERCENTAGE') {
        discount = subtotal * (coupon.value / 100)
      } else {
        discount = Math.min(coupon.value, subtotal)
      }

      // å¢åŠ ä¼˜æƒ åˆ¸ä½¿ç”¨æ¬¡æ•°
      await prisma.coupon.update({
        where: { id: coupon.id },
        data: {
          usedCount: {
            increment: 1,
          },
        },
      })
    } else {
      throw new Error('Invalid or expired coupon')
    }
  }

  // è®¡ç®—è¿è´¹
  if (subtotal < 50) {
    shipping = 10
  }

  const total = subtotal + tax + shipping - discount

  const order = await prisma.$transaction(async (tx) => {
    // ç”Ÿæˆè®¢å•å·
    const orderNumber = generateOrderNumber()

    // åˆ›å»ºè®¢å•
    const newOrder = await tx.order.create({
      data: {
        orderNumber,
        email,
        status: 'PENDING',
        paymentStatus: 'PENDING',
        paymentMethod,
        currency: 'USD',
        subtotal,
        tax,
        shipping,
        discount,
        total,
        shippingAddressId: shippingAddress.id,
        billingAddressId: billingAddress.id,
        items: {
          create: cart.items.map(item => ({
            productId: item.productId,
            productVariantId: item.productVariantId,
            quantity: item.quantity,
            unitPrice: item.unitPrice,
            total: item.unitPrice * item.quantity,
          })),
        },
      },
      include: {
        items: {
          include: {
            product: true,
            productVariant: true,
          },
        },
      },
    })

    // æ£€æŸ¥åº“å­˜
    for (const item of cart.items) {
      if (item.productVariantId) {
        const variant = await tx.productVariant.findUnique({
          where: { id: item.productVariantId },
        })

        if (!variant || variant.inventory < item.quantity) {
          throw new Error(`Insufficient inventory for ${item.product.name}`)
        }
      }
    }

    // é¢„ç•™åº“å­˜ï¼ˆå¯é€‰ï¼‰
    // è¿™é‡Œå¯ä»¥å®ç°åº“å­˜é¢„ç•™é€»è¾‘

    return newOrder
  })

  // æ¸…ç©ºè´­ç‰©è½¦
  await clearCart()

  return order
}

function generateOrderNumber(): string {
  const timestamp = Date.now().toString()
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0')
  return `ORD-${timestamp.slice(-6)}-${random}`
}

export async function getOrder(orderId: string, userId?: string) {
  const order = await prisma.order.findUnique({
    where: { id: orderId },
    include: {
      items: {
        include: {
          product: {
            include: {
              images: {
                orderBy: { position: 'asc' },
                take: 1,
              },
            },
          },
          productVariant: {
            include: {
              options: true,
            },
          },
        },
      },
      shippingAddress: true,
      billingAddress: true,
      transactions: true,
    },
  })

  if (!order) {
    throw new Error('Order not found')
  }

  if (userId && order.userId !== userId) {
    throw new Error('Unauthorized')
  }

  return order
}

export async function getUserOrders(userId: string, page = 1, limit = 10) {
  const skip = (page - 1) * limit

  const [orders, total] = await Promise.all([
    prisma.order.findMany({
      where: { userId },
      include: {
        items: {
          include: {
            product: {
              include: {
                images: {
                  orderBy: { position: 'asc' },
                  take: 1,
                },
              },
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
      skip,
      take: limit,
    }),
    prisma.order.count({
      where: { userId },
    }),
  ])

  return {
    orders,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
    },
  }
}
```

### æ­¥éª¤ä¸‰ï¼šé«˜çº§ç‰¹æ€§å®ç°

#### 3.1 å®ç°æœç´¢åŠŸèƒ½
**lib/search/search.ts**:
```typescript
import { prisma } from '@/lib/db/prisma'

export interface SearchParams {
  query: string
  category?: string
  minPrice?: number
  maxPrice?: number
  sortBy?: 'name' | 'price' | 'rating' | 'createdAt'
  sortOrder?: 'asc' | 'desc'
  page?: number
  limit?: number
}

export interface SearchResult {
  products: any[]
  categories: any[]
  pagination: {
    page: number
    limit: number
    total: number
    pages: number
  }
}

export async function searchProducts(params: SearchParams): Promise<SearchResult> {
  const {
    query,
    category,
    minPrice,
    maxPrice,
    sortBy = 'createdAt',
    sortOrder = 'desc',
    page = 1,
    limit = 12,
  } = params

  const skip = (page - 1) * limit

  // æ„å»ºæœç´¢æ¡ä»¶
  const where: any = {
    status: 'ACTIVE',
  }

  if (query) {
    where.OR = [
      { name: { contains: query, mode: 'insensitive' } },
      { description: { contains: query, mode: 'insensitive' } },
      { sku: { contains: query, mode: 'insensitive' } },
      {
        tags: {
          some: {
            tag: {
              name: { contains: query, mode: 'insensitive' },
            },
          },
        },
      },
    ]
  }

  if (category) {
    where.category = {
      slug: category,
    }
  }

  if (minPrice !== undefined || maxPrice !== undefined) {
    where.price = {}
    if (minPrice !== undefined) {
      where.price.gte = minPrice
    }
    if (maxPrice !== undefined) {
      where.price.lte = maxPrice
    }
  }

  // æ„å»ºæ’åºæ¡ä»¶
  const orderBy: any = {}
  if (sortBy === 'rating') {
    // æŒ‰è¯„åˆ†æ’åºéœ€è¦ç‰¹æ®Šå¤„ç†
    orderBy.reviews = {
      _avg: {
        rating: sortOrder,
      },
    }
  } else {
    orderBy[sortBy] = sortOrder
  }

  const [products, total, categories] = await Promise.all([
    prisma.product.findMany({
      where,
      include: {
        category: true,
        images: {
          orderBy: { position: 'asc' },
          take: 1,
        },
        variants: {
          include: {
            options: true,
          },
        },
        reviews: {
          select: {
            rating: true,
          },
        },
        _count: {
          select: {
            reviews: true,
          },
        },
      },
      orderBy,
      skip,
      take: limit,
    }),
    prisma.product.count({ where }),
    // è·å–ç›¸å…³åˆ†ç±»
    prisma.category.findMany({
      where: {
        products: {
          some: where,
        },
      },
      include: {
        _count: {
          select: {
            products: {
              where,
            },
          },
        },
      },
      orderBy: {
        name: 'asc',
      },
    }),
  ])

  // å¤„ç†äº§å“æ•°æ®
  const processedProducts = products.map(product => ({
    ...product,
    averageRating: product.reviews.length > 0
      ? product.reviews.reduce((sum, review) => sum + review.rating, 0) / product.reviews.length
      : 0,
    reviewCount: product._count.reviews,
    reviews: undefined,
    _count: undefined,
  }))

  return {
    products: processedProducts,
    categories: categories.map(category => ({
      ...category,
      productCount: category._count.products,
      _count: undefined,
    })),
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
    },
  }
}

export async function getSuggestions(query: string, limit = 5) {
  if (!query || query.length < 2) {
    return { products: [], categories: [] }
  }

  const [products, categories] = await Promise.all([
    prisma.product.findMany({
      where: {
        status: 'ACTIVE',
        name: {
          contains: query,
          mode: 'insensitive',
        },
      },
      select: {
        id: true,
        name: true,
        slug: true,
        images: {
          select: {
            url: true,
          },
          orderBy: { position: 'asc' },
          take: 1,
        },
      },
      take: limit,
    }),
    prisma.category.findMany({
      where: {
        name: {
          contains: query,
          mode: 'insensitive',
        },
      },
      select: {
        id: true,
        name: true,
        slug: true,
        image: true,
      },
      take: Math.floor(limit / 2),
    }),
  ])

  return { products, categories }
}
```

#### 3.2 å®ç°æ¨èç³»ç»Ÿ
**lib/recommendations/recommendations.ts**:
```typescript
import { prisma } from '@/lib/db/prisma'

export interface RecommendationParams {
  userId?: string
  productId?: string
  categoryIds?: string[]
  limit?: number
}

export async function getRecommendations({
  userId,
  productId,
  categoryIds,
  limit = 10,
}: RecommendationParams) {
  const recommendations = []

  // åŸºäºç”¨æˆ·è¡Œä¸ºçš„æ¨è
  if (userId) {
    const userRecommendations = await getUserBasedRecommendations(userId, limit)
    recommendations.push(...userRecommendations)
  }

  // åŸºäºå•†å“çš„ååŒè¿‡æ»¤æ¨è
  if (productId) {
    const collaborativeRecommendations = await getCollaborativeRecommendations(productId, limit)
    recommendations.push(...collaborativeRecommendations)
  }

  // åŸºäºåˆ†ç±»çš„æ¨è
  if (categoryIds && categoryIds.length > 0) {
    const categoryRecommendations = await getCategoryBasedRecommendations(categoryIds, limit)
    recommendations.push(...categoryRecommendations)
  }

  // çƒ­é—¨å•†å“æ¨è
  if (recommendations.length < limit) {
    const popularProducts = await getPopularProducts(limit - recommendations.length)
    recommendations.push(...popularProducts)
  }

  // å»é‡å¹¶é™åˆ¶æ•°é‡
  const uniqueRecommendations = recommendations
    .filter((product, index, self) =>
      self.findIndex(p => p.id === product.id) === index
    )
    .slice(0, limit)

  return uniqueRecommendations
}

async function getUserBasedRecommendations(userId: string, limit: number) {
  // è·å–ç”¨æˆ·è´­ä¹°å†å²
  const userOrders = await prisma.order.findMany({
    where: { userId },
    include: {
      items: {
        include: {
          product: {
            include: {
              category: true,
            },
          },
        },
      },
    },
  })

  // æå–ç”¨æˆ·åå¥½çš„åˆ†ç±»
  const categoryPreferences = userOrders.flatMap(order =>
    order.items.map(item => item.product.categoryId)
  )

  const uniqueCategoryIds = [...new Set(categoryPreferences)]

  // è·å–è¿™äº›åˆ†ç±»ä¸­çš„å…¶ä»–å•†å“
  const recommendations = await prisma.product.findMany({
    where: {
      categoryId: { in: uniqueCategoryIds },
      status: 'ACTIVE',
      // æ’é™¤å·²è´­ä¹°çš„å•†å“
      id: {
        notIn: userOrders.flatMap(order =>
          order.items.map(item => item.productId)
        ),
      },
    },
    include: {
      category: true,
      images: {
        orderBy: { position: 'asc' },
        take: 1,
      },
      reviews: {
        select: { rating: true },
      },
      _count: {
        select: { reviews: true },
      },
    },
    orderBy: [
      { reviews: { _avg: { rating: 'desc' } } },
      { _count: { reviews: 'desc' } },
    ],
    take: limit,
  })

  return recommendations.map(product => ({
    ...product,
    averageRating: product.reviews.length > 0
      ? product.reviews.reduce((sum, review) => sum + review.rating, 0) / product.reviews.length
      : 0,
    reviewCount: product._count.reviews,
    reviews: undefined,
    _count: undefined,
  }))
}

async function getCollaborativeRecommendations(productId: string, limit: number) {
  // æ‰¾åˆ°è´­ä¹°è¿‡æ­¤å•†å“çš„ç”¨æˆ·è¿˜è´­ä¹°äº†å“ªäº›å…¶ä»–å•†å“
  const relatedProducts = await prisma.orderItem.findMany({
    where: {
      productId,
    },
    include: {
      order: {
        include: {
          items: {
            include: {
              product: {
                include: {
                  category: true,
                  images: {
                    orderBy: { position: 'asc' },
                    take: 1,
                  },
                  reviews: {
                    select: { rating: true },
                  },
                  _count: {
                    select: { reviews: true },
                  },
                },
              },
            },
          },
        },
      },
    },
  })

  // ç»Ÿè®¡å…¶ä»–å•†å“çš„è´­ä¹°æ¬¡æ•°
  const productFrequency = new Map<string, number>()

  relatedProducts.forEach(orderItem => {
    orderItem.order.items.forEach(item => {
      if (item.productId !== productId) {
        const current = productFrequency.get(item.productId) || 0
        productFrequency.set(item.productId, current + 1)
      }
    })
  })

  // è·å–æœ€é¢‘ç¹è´­ä¹°çš„å•†å“
  const sortedProductIds = Array.from(productFrequency.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, limit)
    .map(([productId]) => productId)

  if (sortedProductIds.length === 0) {
    return []
  }

  const recommendations = await prisma.product.findMany({
    where: {
      id: { in: sortedProductIds },
      status: 'ACTIVE',
    },
    include: {
      category: true,
      images: {
        orderBy: { position: 'asc' },
        take: 1,
      },
      reviews: {
        select: { rating: true },
      },
      _count: {
        select: { reviews: true },
      },
    },
  })

  // æŒ‰ç…§è´­ä¹°é¢‘ç‡æ’åº
  const productOrder = new Map(sortedProductIds.map((id, index) => [id, index]))

  return recommendations
    .sort((a, b) => (productOrder.get(a.id) || 0) - (productOrder.get(b.id) || 0))
    .map(product => ({
      ...product,
      averageRating: product.reviews.length > 0
        ? product.reviews.reduce((sum, review) => sum + review.rating, 0) / product.reviews.length
        : 0,
      reviewCount: product._count.reviews,
      reviews: undefined,
      _count: undefined,
    }))
}

async function getCategoryBasedRecommendations(categoryIds: string[], limit: number) {
  const recommendations = await prisma.product.findMany({
    where: {
      categoryId: { in: categoryIds },
      status: 'ACTIVE',
    },
    include: {
      category: true,
      images: {
        orderBy: { position: 'asc' },
        take: 1,
      },
      reviews: {
        select: { rating: true },
      },
      _count: {
        select: { reviews: true },
      },
    },
    orderBy: [
      { reviews: { _avg: { rating: 'desc' } } },
      { _count: { reviews: 'desc' } },
    ],
    take: limit,
  })

  return recommendations.map(product => ({
    ...product,
    averageRating: product.reviews.length > 0
      ? product.reviews.reduce((sum, review) => sum + review.rating, 0) / product.reviews.length
      : 0,
    reviewCount: product._count.reviews,
    reviews: undefined,
    _count: undefined,
  }))
}

async function getPopularProducts(limit: number) {
  const recommendations = await prisma.product.findMany({
    where: {
      status: 'ACTIVE',
    },
    include: {
      category: true,
      images: {
        orderBy: { position: 'asc' },
        take: 1,
      },
      reviews: {
        select: { rating: true },
      },
      _count: {
        select: { reviews: true, orderItems: true },
      },
    },
    orderBy: [
      { _count: { orderItems: 'desc' } },
      { reviews: { _avg: { rating: 'desc' } } },
    ],
    take: limit,
  })

  return recommendations.map(product => ({
    ...product,
    averageRating: product.reviews.length > 0
      ? product.reviews.reduce((sum, review) => sum + review.rating, 0) / product.reviews.length
      : 0,
    reviewCount: product._count.reviews,
    reviews: undefined,
    _count: undefined,
  }))
}
```

### æ­¥éª¤å››ï¼šæµ‹è¯•å’Œä¼˜åŒ–

#### 4.1 APIæµ‹è¯•
**__tests__/api/products.test.ts**:
```typescript
import { createMocks } from 'node-mocks-http'
import handler from '@/app/api/products/route'

describe('/api/products', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe('GET', () => {
    it('should return products with pagination', async () => {
      const { req, res } = createMocks({
        method: 'GET',
        query: {
          page: '1',
          limit: '10',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(200)
      const data = JSON.parse(res._getData())
      expect(data).toHaveProperty('products')
      expect(data).toHaveProperty('pagination')
    })

    it('should filter products by category', async () => {
      const { req, res } = createMocks({
        method: 'GET',
        query: {
          category: 'electronics',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(200)
      const data = JSON.parse(res._getData())
      expect(data.products).toBeDefined()
    })

    it('should search products by name', async () => {
      const { req, res } = createMocks({
        method: 'GET',
        query: {
          search: 'laptop',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(200)
      const data = JSON.parse(res._getData())
      expect(data.products).toBeDefined()
    })
  })

  describe('POST', () => {
    it('should create a new product', async () => {
      const productData = {
        name: 'Test Product',
        slug: 'test-product',
        description: 'A test product',
        price: 99.99,
        sku: 'TEST-001',
        categoryId: 'category-id',
      }

      const { req, res } = createMocks({
        method: 'POST',
        body: productData,
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(201)
      const data = JSON.parse(res._getData())
      expect(data.name).toBe(productData.name)
    })

    it('should validate product data', async () => {
      const invalidProductData = {
        name: '',
        price: -10,
      }

      const { req, res } = createMocks({
        method: 'POST',
        body: invalidProductData,
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(400)
      const data = JSON.parse(res._getData())
      expect(data).toHaveProperty('error')
    })
  })
})
```

#### 4.2 æ€§èƒ½ä¼˜åŒ–
**lib/cache/cache.ts**:
```typescript
import { unstable_cache } from 'next/cache'

// ç¼“å­˜äº§å“æ•°æ®
export const getCachedProducts = unstable_cache(
  async (params: any) => {
    // è¿™é‡Œå®ç°è·å–äº§å“æ•°æ®çš„é€»è¾‘
    return [] // è¿”å›äº§å“æ•°æ®
  },
  ['products'],
  {
    revalidate: 3600, // 1å°æ—¶ç¼“å­˜
    tags: ['products'],
  }
)

// ç¼“å­˜åˆ†ç±»æ•°æ®
export const getCachedCategories = unstable_cache(
  async () => {
    // è¿™é‡Œå®ç°è·å–åˆ†ç±»æ•°æ®çš„é€»è¾‘
    return [] // è¿”å›åˆ†ç±»æ•°æ®
  },
  ['categories'],
  {
    revalidate: 86400, // 24å°æ—¶ç¼“å­˜
    tags: ['categories'],
  }
)

// æ¸…é™¤äº§å“ç¼“å­˜
export function revalidateProducts() {
  revalidateTag('products')
}

// æ¸…é™¤åˆ†ç±»ç¼“å­˜
export function revalidateCategories() {
  revalidateTag('categories')
}
```

### æ­¥éª¤äº”ï¼šéƒ¨ç½²å’Œä¸Šçº¿

#### 5.1 ç¯å¢ƒå˜é‡é…ç½®
**.env.local**:
```bash
# Database
DATABASE_URL="postgresql://username:password@localhost:5432/ecommerce_db"

# NextAuth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-secret-key"

# Google OAuth
GOOGLE_CLIENT_ID="your-google-client-id"
GOOGLE_CLIENT_SECRET="your-google-client-secret"

# Stripe
STRIPE_SECRET_KEY="sk_test_..."
STRIPE_PUBLISHABLE_KEY="pk_test_..."
STRIPE_WEBHOOK_SECRET="whsec_..."

# Email
SMTP_HOST="smtp.gmail.com"
SMTP_PORT=587
SMTP_USER="your-email@gmail.com"
SMTP_PASS="your-app-password"
SMTP_FROM="noreply@yourstore.com"

# File Storage
CLOUDINARY_CLOUD_NAME="your-cloud-name"
CLOUDINARY_API_KEY="your-api-key"
CLOUDINARY_API_SECRET="your-api-secret"

# Redis (å¯é€‰ï¼Œç”¨äºç¼“å­˜)
REDIS_URL="redis://localhost:6379"

# Analytics
NEXT_PUBLIC_GA_ID="G-XXXXXXXXXX"
```

#### 5.2 Dockeré…ç½®
**Dockerfile**:
```dockerfile
# å¤šé˜¶æ®µæ„å»º
FROM node:18-alpine AS base

# å®‰è£…ä¾èµ–é˜¶æ®µ
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

# å¤åˆ¶åŒ…ç®¡ç†æ–‡ä»¶
COPY package.json package-lock.json* ./
RUN npm ci --only=production

# æ„å»ºé˜¶æ®µ
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# ç”ŸæˆPrismaå®¢æˆ·ç«¯
RUN npx prisma generate

# æ„å»ºåº”ç”¨
ENV NEXT_TELEMETRY_DISABLED 1
RUN npm run build

# è¿è¡Œé˜¶æ®µ
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# å¤åˆ¶æ„å»ºäº§ç‰©
COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

# å¤åˆ¶Prismaç›¸å…³æ–‡ä»¶
COPY --from=builder /app/prisma ./prisma
COPY --from=builder /app/node_modules/.prisma ./node_modules/.prisma

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
```

**docker-compose.yml**:
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/ecommerce_db
      - NEXTAUTH_URL=http://localhost:3000
    depends_on:
      - db
      - redis
    volumes:
      - ./uploads:/app/uploads

  db:
    image: postgres:15
    environment:
      POSTGRES_DB: ecommerce_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

## ğŸ’¡ å…³é”®æŠ€æœ¯ç‚¹

### 1. ç”µå•†æ¶æ„è®¾è®¡
- æ¨¡å—åŒ–çš„ç³»ç»Ÿæ¶æ„
- æ•°æ®åº“è®¾è®¡å’Œå…³ç³»å»ºæ¨¡
- å¾®æœåŠ¡åŒ–æ€è€ƒ

### 2. æ”¯ä»˜ç³»ç»Ÿé›†æˆ
- Stripeæ”¯ä»˜é›†æˆ
- Webhookå¤„ç†
- äº¤æ˜“å®‰å…¨å’ŒéªŒè¯

### 3. è´­ç‰©è½¦å’Œè®¢å•ç®¡ç†
- å¤æ‚çš„è´­ç‰©è½¦é€»è¾‘
- è®¢å•çŠ¶æ€æµè½¬
- åº“å­˜ç®¡ç†

### 4. æœç´¢å’Œæ¨è
- å…¨æ–‡æœç´¢å®ç°
- ä¸ªæ€§åŒ–æ¨èç®—æ³•
- æ€§èƒ½ä¼˜åŒ–

### 5. ç”¨æˆ·è®¤è¯å’Œæƒé™
- å¤šç§ç™»å½•æ–¹å¼
- æƒé™æ§åˆ¶
- å®‰å…¨æœ€ä½³å®è·µ

## ğŸ¨ UI/UXè®¾è®¡

### ç”µå•†è®¾è®¡åŸåˆ™
- **ç”¨æˆ·ä¸­å¿ƒ**: ä»¥ç”¨æˆ·éœ€æ±‚ä¸ºä¸­å¿ƒçš„è®¾è®¡
- **è½¬åŒ–å¯¼å‘**: ä¼˜åŒ–è´­ä¹°æµç¨‹å’Œè½¬åŒ–ç‡
- **ä¿¡ä»»å»ºç«‹**: é€šè¿‡è®¾è®¡å»ºç«‹ç”¨æˆ·ä¿¡ä»»
- **ç§»åŠ¨ä¼˜å…ˆ**: å“åº”å¼è®¾è®¡å’Œç§»åŠ¨ä½“éªŒ

### å…³é”®é¡µé¢è®¾è®¡
1. **é¦–é¡µ**: å“ç‰Œå±•ç¤ºã€äº§å“æ¨èã€ä¿ƒé”€æ´»åŠ¨
2. **å•†å“åˆ—è¡¨**: ç­›é€‰ã€æ’åºã€æœç´¢åŠŸèƒ½
3. **å•†å“è¯¦æƒ…**: äº§å“ä¿¡æ¯ã€è¯„ä»·ã€è´­ä¹°é€‰é¡¹
4. **è´­ç‰©è½¦**: å•†å“ç®¡ç†ã€ä»·æ ¼è®¡ç®—
5. **ç»“è´¦æµç¨‹**: ç®€åŒ–çš„å¤šæ­¥ç»“è´¦
6. **ç”¨æˆ·ä¸­å¿ƒ**: è®¢å•ç®¡ç†ã€ä¸ªäººä¿¡æ¯

## ğŸ“± å“åº”å¼è®¾è®¡

### ç§»åŠ¨ç«¯ä¼˜åŒ–
- è§¦æ‘¸å‹å¥½çš„äº¤äº’è®¾è®¡
- ç§»åŠ¨ç«¯å¯¼èˆªä¼˜åŒ–
- ç§»åŠ¨ç«¯ç»“è´¦æµç¨‹ç®€åŒ–
- PWAæ”¯æŒ

### å…³é”®æ–­ç‚¹è®¾è®¡
- æ‰‹æœº: < 640px
- å¹³æ¿: 640px - 1024px
- æ¡Œé¢: > 1024px

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. å‰ç«¯ä¼˜åŒ–
- ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
- å›¾ç‰‡ä¼˜åŒ–å’ŒCDN
- ç¼“å­˜ç­–ç•¥
- é¢„åŠ è½½å’Œé¢„å–

### 2. åç«¯ä¼˜åŒ–
- æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- APIå“åº”ç¼“å­˜
- æ•°æ®åº“è¿æ¥æ± 
- Redisç¼“å­˜

### 3. SEOä¼˜åŒ–
- æœåŠ¡ç«¯æ¸²æŸ“
- ç»“æ„åŒ–æ•°æ®
- å…ƒæ ‡ç­¾ä¼˜åŒ–
- ç«™ç‚¹åœ°å›¾

## ğŸ”’ å®‰å…¨è€ƒè™‘

### 1. æ”¯ä»˜å®‰å…¨
- PCI DSSåˆè§„
- æ•°æ®åŠ å¯†
- å®‰å…¨çš„æ”¯ä»˜æµç¨‹
- é˜²æ¬ºè¯ˆæªæ–½

### 2. æ•°æ®å®‰å…¨
- ç”¨æˆ·æ•°æ®ä¿æŠ¤
- GDPRåˆè§„
- å®‰å…¨çš„æ•°æ®ä¼ è¾“
- æ•°æ®å¤‡ä»½

### 3. åº”ç”¨å®‰å…¨
- SQLæ³¨å…¥é˜²æŠ¤
- XSSé˜²æŠ¤
- CSRFä¿æŠ¤
- å®‰å…¨çš„è®¤è¯

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### æµ‹è¯•ç±»å‹
1. **å•å…ƒæµ‹è¯•**: ç»„ä»¶å’Œå‡½æ•°æµ‹è¯•
2. **é›†æˆæµ‹è¯•**: APIå’Œæ•°æ®åº“æµ‹è¯•
3. **E2Eæµ‹è¯•**: å®Œæ•´ç”¨æˆ·æµç¨‹æµ‹è¯•
4. **æ€§èƒ½æµ‹è¯•**: è´Ÿè½½å’Œå‹åŠ›æµ‹è¯•
5. **å®‰å…¨æµ‹è¯•**: æ¼æ´æ‰«æ

### æµ‹è¯•å·¥å…·
- Jest: å•å…ƒæµ‹è¯•æ¡†æ¶
- React Testing Library: Reactç»„ä»¶æµ‹è¯•
- Playwright: E2Eæµ‹è¯•
- Artillery: æ€§èƒ½æµ‹è¯•

## ğŸš€ éƒ¨ç½²æ–¹æ¡ˆ

### ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
- Vercel: å‰ç«¯åº”ç”¨éƒ¨ç½²
- Railway/Heroku: åç«¯APIéƒ¨ç½²
- Supabase/PlanetScale: æ•°æ®åº“æ‰˜ç®¡
- Cloudinary: æ–‡ä»¶å­˜å‚¨

### CI/CDæµç¨‹
- GitHub Actions: è‡ªåŠ¨åŒ–æ„å»ºå’Œéƒ¨ç½²
- ä»£ç è´¨é‡æ£€æŸ¥
- è‡ªåŠ¨åŒ–æµ‹è¯•
- ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

### ç›‘æ§å’Œåˆ†æ
- åº”ç”¨æ€§èƒ½ç›‘æ§
- é”™è¯¯è¿½è¸ª
- ç”¨æˆ·è¡Œä¸ºåˆ†æ
- ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§

## ğŸ”„ æ–‡æ¡£äº¤å‰å¼•ç”¨

### ç›¸å…³æ–‡æ¡£
- ğŸ“„ **[01-corporate-landing.md](./01-corporate-landing.md)**: ä¼ä¸šå®˜ç½‘é¡¹ç›®å®æˆ˜
- ğŸ“„ **[03-dashboard-analytics.md](./03-dashboard-analytics.md)**: æ•°æ®ä»ªè¡¨æ¿é¡¹ç›®å®æˆ˜
- ğŸ“„ **[04-saas-platform.md](./04-saas-platform.md)**: SaaSå¹³å°é¡¹ç›®å®æˆ˜

### å‚è€ƒç« èŠ‚
- ğŸ“– **[Framework Deep Dive - Next.js](../frameworks/nextjs-core.md)**: Next.jsæ ¸å¿ƒç‰¹æ€§æ·±åº¦å­¦ä¹ 
- ğŸ“– **[Database - Prisma ORM](../knowledge-points/database/prisma.md)**: Prisma ORMå¿«é€Ÿå‚è€ƒ
- ğŸ“– **[Authentication - NextAuth](../knowledge-points/auth/nextauth.md)**: NextAuth.jsæœ€ä½³å®è·µ

## ğŸ“ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹å›é¡¾
1. **ç”µå•†æ¶æ„**: æŒæ¡å®Œæ•´çš„ç”µå•†ç³»ç»Ÿæ¶æ„è®¾è®¡
2. **æ”¯ä»˜é›†æˆ**: å®ç°å®‰å…¨å¯é çš„æ”¯ä»˜ç³»ç»Ÿ
3. **æ•°æ®ç®¡ç†**: å¤æ‚çš„ä¸šåŠ¡æ•°æ®å»ºæ¨¡å’Œç®¡ç†
4. **æ€§èƒ½ä¼˜åŒ–**: ç”µå•†ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–ç­–ç•¥
5. **å®‰å…¨é˜²æŠ¤**: ç”µå•†å®‰å…¨æœ€ä½³å®è·µ

### å­¦ä¹ æˆæœæ£€æŸ¥
- [ ] èƒ½å¤Ÿç‹¬ç«‹è®¾è®¡å’Œå®ç°ç”µå•†ç³»ç»Ÿæ¶æ„
- [ ] æŒæ¡æ”¯ä»˜ç³»ç»Ÿé›†æˆå’Œå¤„ç†æµç¨‹
- [ ] å®ç°å®Œæ•´çš„è´­ç‰©è½¦å’Œè®¢å•ç®¡ç†ç³»ç»Ÿ
- [ ] å¼€å‘é«˜æ•ˆçš„æœç´¢å’Œæ¨èåŠŸèƒ½
- [ ] éƒ¨ç½²å’Œè¿ç»´ç”Ÿäº§çº§ç”µå•†åº”ç”¨

## ğŸ¤ è´¡çŒ®ä¸åé¦ˆ

### è´¡çŒ®æŒ‡å—
æ¬¢è¿å¯¹æœ¬é¡¹ç›®å®æˆ˜æ–‡æ¡£æå‡ºæ”¹è¿›å»ºè®®ï¼š
- ğŸ› **BugæŠ¥å‘Š**: å‘ç°æ–‡æ¡£é”™è¯¯æˆ–ä¸å‡†ç¡®ä¹‹å¤„
- ğŸ’¡ **åŠŸèƒ½å»ºè®®**: æå‡ºæ–°çš„å®æˆ˜åœºæ™¯æˆ–æŠ€æœ¯ç‚¹
- ğŸ“ **å†…å®¹è´¡çŒ®**: åˆ†äº«æ‚¨çš„ç”µå•†å¼€å‘ç»éªŒ

### åé¦ˆæ¸ é“
- GitHub Issues: [é¡¹ç›®Issuesé¡µé¢]
- Email: dev-quest@example.com
- ç¤¾åŒºè®¨è®º: [å¼€å‘è€…ç¤¾åŒºé“¾æ¥]

## ğŸ”— å¤–éƒ¨èµ„æº

### å®˜æ–¹æ–‡æ¡£
- [Next.js 15 Documentation](https://nextjs.org/docs)
- [Stripe API Documentation](https://stripe.com/docs/api)
- [Prisma Documentation](https://www.prisma.io/docs/)
- [NextAuth.js Documentation](https://next-auth.js.org/)

### å­¦ä¹ èµ„æº
- [Building E-commerce with Next.js](https://vercel.com/guides/nextjs-ecommerce)
- [Stripe Integration Guide](https://stripe.com/docs/payments/accept-a-payment)
- [E-commerce Best Practices](https://web.dev/ecommerce/)

### å·¥å…·å’Œå¹³å°
- [Vercel Commerce](https://github.com/vercel/commerce)
- [MedusaJS](https://medusajs.com/)
- [Saleor](https://saleor.io/)

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ | ğŸš§ è¿›è¡Œä¸­ | ğŸ“‹ è®¡åˆ’ä¸­
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ
**ç‰ˆæœ¬**: v1.0.0