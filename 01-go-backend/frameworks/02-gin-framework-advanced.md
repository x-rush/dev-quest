# Ginæ¡†æ¶é«˜çº§ç‰¹æ€§

> **æ–‡æ¡£ç®€ä»‹**: æ·±å…¥å­¦ä¹ Ginæ¡†æ¶çš„é«˜çº§ç‰¹æ€§ï¼ŒæŒæ¡ä¸­é—´ä»¶å¼€å‘ã€è·¯ç”±ä¼˜åŒ–ã€æ€§èƒ½è°ƒä¼˜ç­‰ä¼ä¸šçº§å¼€å‘æŠ€èƒ½

> **ç›®æ ‡è¯»è€…**: å·²æŒæ¡GinåŸºç¡€ï¼Œå¸Œæœ›æ·±å…¥ç†è§£æ¡†æ¶åŸç†å’Œé«˜çº§ç”¨æ³•çš„Goåç«¯å¼€å‘è€…

> **å‰ç½®çŸ¥è¯†**: Goè¯­è¨€åŸºç¡€ã€Ginæ¡†æ¶åŸºç¡€ã€HTTPåè®®ã€ä¸­é—´ä»¶æ¦‚å¿µ

> **é¢„è®¡æ—¶é•¿**: 4-5å°æ—¶å­¦ä¹  + 2-3å°æ—¶å®è·µ

## ğŸ“š æ–‡æ¡£å…ƒæ•°æ®

| å±æ€§ | å†…å®¹ |
|------|------|
| **æ¨¡å—** | `01-go-backend` |
| **åˆ†ç±»** | `frameworks/web-development` |
| **éš¾åº¦** | â­â­â­â­ (4/5) |
| **æ ‡ç­¾** | `#Ginæ¡†æ¶` `#ä¸­é—´ä»¶` `#æ€§èƒ½ä¼˜åŒ–` `#é«˜çº§è·¯ç”±` `#ä¼ä¸šçº§å¼€å‘` |
| **æ›´æ–°æ—¥æœŸ** | `2025å¹´10æœˆ` |
| **ä½œè€…** | Dev Quest Team |
| **çŠ¶æ€** | âœ… å·²å®Œæˆ |

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ¨¡å—åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… **æŒæ¡é«˜çº§ä¸­é—´ä»¶å¼€å‘**: è‡ªå®šä¹‰ä¼ä¸šçº§ä¸­é—´ä»¶ã€ä¸­é—´ä»¶é“¾ä¼˜åŒ–ã€æ€§èƒ½è°ƒä¼˜
- âœ… **ç²¾é€šé«˜çº§è·¯ç”±æŠ€æœ¯**: åŠ¨æ€è·¯ç”±ã€è·¯ç”±ç»„ä¼˜åŒ–ã€RESTful APIæœ€ä½³å®è·µ
- âœ… **æ·±å…¥æ€§èƒ½è°ƒä¼˜**: å†…å­˜ä¼˜åŒ–ã€å¹¶å‘å¤„ç†ã€Benchmarkæµ‹è¯•å’Œæ€§èƒ½åˆ†æ
- âœ… **ç†è§£æ¡†æ¶æºç **: è·¯ç”±å¼•æ“åŸç†ã€ä¸­é—´ä»¶æœºåˆ¶ã€è®¾è®¡æ€æƒ³åˆ†æ
- âœ… **ä¼ä¸šçº§åº”ç”¨**: å¤§å‹APIé¡¹ç›®æ¶æ„ã€å¾®æœåŠ¡é›†æˆã€å®‰å…¨ä¸­é—´ä»¶å®ç°

---

## ğŸ“‹ ç›®å½•

- [Ginä¸­é—´ä»¶æ·±åº¦å¼€å‘](#ginä¸­é—´ä»¶æ·±åº¦å¼€å‘)
- [é«˜çº§è·¯ç”±æŠ€æœ¯](#é«˜çº§è·¯ç”±æŠ€æœ¯)
- [Ginæ€§èƒ½è°ƒä¼˜](#ginæ€§èƒ½è°ƒä¼˜)
- [Ginæºç è§£æ](#ginæºç è§£æ)
- [Giné«˜çº§åº”ç”¨æ¡ˆä¾‹](#giné«˜çº§åº”ç”¨æ¡ˆä¾‹)
- [ä¼ä¸šçº§æœ€ä½³å®è·µ](#ä¼ä¸šçº§æœ€ä½³å®è·µ)
- [å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)

---

## ğŸ”§ Ginä¸­é—´ä»¶æ·±åº¦å¼€å‘

### ä¸­é—´ä»¶æ ¸å¿ƒæœºåˆ¶

#### ä¸­é—´ä»¶æ‰§è¡ŒåŸç†
Ginçš„ä¸­é—´ä»¶é‡‡ç”¨**é“¾å¼è°ƒç”¨**æ¨¡å¼ï¼Œæ¯ä¸ªä¸­é—´ä»¶éƒ½æœ‰æœºä¼šå¤„ç†HTTPè¯·æ±‚å’Œå“åº”ï¼š

```go
// ä¸­é—´ä»¶ç±»å‹å®šä¹‰
type HandlerFunc func(*Context)

// ä¸­é—´ä»¶é“¾æ‰§è¡Œæµç¨‹
func (engine *Engine) handleHTTPRequest(c *Context) {
    // 1. æ‰§è¡Œå…¨å±€ä¸­é—´ä»¶
    // 2. æ‰§è¡Œè·¯ç”±ç»„ä¸­é—´ä»¶
    // 3. æ‰§è¡Œè·¯ç”±å¤„ç†å™¨
    // 4. å“åº”å¤„ç†
}
```

#### è‡ªå®šä¹‰ä¸­é—´ä»¶å¼€å‘

**ç¤ºä¾‹1: ä¼ä¸šçº§æ—¥å¿—ä¸­é—´ä»¶**
```go
package middleware

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/sirupsen/logrus"
)

// AdvancedLogger é«˜çº§æ—¥å¿—ä¸­é—´ä»¶
func AdvancedLogger(logger *logrus.Logger) gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        // è®°å½•è¯·æ±‚å¼€å§‹æ—¶é—´
        start := time.Now()

        // è¯»å–è¯·æ±‚ä½“
        var requestBody []byte
        if c.Request.Body != nil {
            requestBody, _ = io.ReadAll(c.Request.Body)
            c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))
        }

        // åˆ›å»ºå“åº”å†™å…¥å™¨
        responseWriter := &responseBodyWriter{
            ResponseWriter: c.Writer,
            body:          &bytes.Buffer{},
        }
        c.Writer = responseWriter

        // å¤„ç†è¯·æ±‚
        c.Next()

        // è®¡ç®—å¤„ç†æ—¶é—´
        latency := time.Since(start)

        // è®°å½•è¯¦ç»†çš„è¯·æ±‚æ—¥å¿—
        logEntry := logger.WithFields(logrus.Fields{
            "method":      c.Request.Method,
            "path":        c.Request.URL.Path,
            "query":       c.Request.URL.RawQuery,
            "status":      c.Writer.Status(),
            "latency":     latency,
            "client_ip":   c.ClientIP(),
            "user_agent":  c.Request.UserAgent(),
            "request_id":  c.GetString("request_id"),
        })

        // æ·»åŠ è¯·æ±‚ä½“ï¼ˆä»…åœ¨DEBUGçº§åˆ«ï¼‰
        if logger.Level >= logrus.DebugLevel && len(requestBody) > 0 {
            logEntry.Data["request_body"] = json.RawMessage(requestBody)
        }

        // æ·»åŠ å“åº”ä½“ï¼ˆä»…åœ¨DEBUGçº§åˆ«ï¼‰
        if logger.Level >= logrus.DebugLevel && responseWriter.body.Len() > 0 {
            logEntry.Data["response_body"] = json.RawMessage(responseWriter.body.Bytes())
        }

        // æ ¹æ®çŠ¶æ€ç é€‰æ‹©æ—¥å¿—çº§åˆ«
        switch {
        case c.Writer.Status() >= 500:
            logEntry.Error("Internal Server Error")
        case c.Writer.Status() >= 400:
            logEntry.Warn("Client Error")
        case c.Writer.Status() >= 300:
            logEntry.Info("Redirection")
        default:
            logEntry.Info("Success")
        }
    })
}

// responseBodyWriter æ•è·å“åº”ä½“çš„è¾…åŠ©ç»“æ„
type responseBodyWriter struct {
    gin.ResponseWriter
    body *bytes.Buffer
}

func (r *responseBodyWriter) Write(b []byte) (int, error) {
    r.body.Write(b)
    return r.ResponseWriter.Write(b)
}
```

**ç¤ºä¾‹2: JWTè®¤è¯æˆæƒä¸­é—´ä»¶**
```go
package middleware

import (
    "errors"
    "strings"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
)

// JWTClaims JWTå£°æ˜ç»“æ„
type JWTClaims struct {
    UserID   uint   `json:"user_id"`
    Username string `json:"username"`
    Role     string `json:"role"`
    jwt.RegisteredClaims
}

// JWTAuth JWTè®¤è¯ä¸­é—´ä»¶
func JWTAuth(secretKey string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // è·å–Authorizationå¤´
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(401, gin.H{"error": "Authorization header is required"})
            c.Abort()
            return
        }

        // æå–Bearer token
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        if tokenString == authHeader {
            c.JSON(401, gin.H{"error": "Bearer token is required"})
            c.Abort()
            return
        }

        // è§£æJWT token
        claims := &JWTClaims{}
        token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
            if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
                return nil, errors.New("unexpected signing method")
            }
            return []byte(secretKey), nil
        })

        if err != nil || !token.Valid {
            c.JSON(401, gin.H{"error": "Invalid token"})
            c.Abort()
            return
        }

        // æ£€æŸ¥tokenæ˜¯å¦è¿‡æœŸ
        if claims.ExpiresAt.Time.Before(time.Now()) {
            c.JSON(401, gin.H{"error": "Token expired"})
            c.Abort()
            return
        }

        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åˆ°ä¸Šä¸‹æ–‡
        c.Set("user_id", claims.UserID)
        c.Set("username", claims.Username)
        c.Set("role", claims.Role)

        c.Next()
    }
}

// RoleBasedAuth åŸºäºè§’è‰²çš„æˆæƒä¸­é—´ä»¶
func RoleBasedAuth(allowedRoles ...string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userRole, exists := c.Get("role")
        if !exists {
            c.JSON(403, gin.H{"error": "User role not found"})
            c.Abort()
            return
        }

        roleStr := userRole.(string)
        for _, allowedRole := range allowedRoles {
            if roleStr == allowedRole {
                c.Next()
                return
            }
        }

        c.JSON(403, gin.H{"error": "Insufficient permissions"})
        c.Abort()
    }
}
```

**ç¤ºä¾‹3: æ™ºèƒ½é™æµä¸­é—´ä»¶**
```go
package middleware

import (
    "fmt"
    "net/http"
    "sync"
    "time"

    "github.com/gin-gonic/gin"
    "golang.org/x/time/rate"
)

// RateLimiter æ™ºèƒ½é™æµå™¨
type RateLimiter struct {
    clients map[string]*rate.Limiter
    mutex   sync.RWMutex
    rate    rate.Limit
    burst   int
}

// NewRateLimiter åˆ›å»ºæ™ºèƒ½é™æµå™¨
func NewRateLimiter(rps float64, burst int) *RateLimiter {
    return &RateLimiter{
        clients: make(map[string]*rate.Limiter),
        rate:    rate.Limit(rps),
        burst:   burst,
    }
}

// Allow æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚
func (rl *RateLimiter) Allow(clientID string) bool {
    rl.mutex.Lock()
    defer rl.mutex.Unlock()

    if limiter, exists := rl.clients[clientID]; exists {
        return limiter.Allow()
    }

    // ä¸ºæ–°å®¢æˆ·ç«¯åˆ›å»ºé™æµå™¨
    limiter := rate.NewLimiter(rl.rate, rl.burst)
    rl.clients[clientID] = limiter
    return limiter.Allow()
}

// SmartRateLimit æ™ºèƒ½é™æµä¸­é—´ä»¶
func (rl *RateLimiter) SmartRateLimit() gin.HandlerFunc {
    return func(c *gin.Context) {
        clientIP := c.ClientIP()

        // æ ¹æ®è¯·æ±‚è·¯å¾„è°ƒæ•´é™æµç­–ç•¥
        path := c.Request.URL.Path
        multiplier := 1.0

        switch {
        case strings.Contains(path, "/api/"):
            multiplier = 1.0 // APIè¯·æ±‚æ­£å¸¸é™æµ
        case strings.Contains(path, "/upload"):
            multiplier = 0.5 // ä¸Šä¼ è¯·æ±‚æ›´ä¸¥æ ¼é™æµ
        case strings.Contains(path, "/login"):
            multiplier = 0.3 // ç™»å½•è¯·æ±‚æœ€ä¸¥æ ¼é™æµ
        }

        // åŠ¨æ€è°ƒæ•´é™æµå™¨
        if !rl.Allow(clientIP) {
            c.Header("X-RateLimit-Limit", fmt.Sprintf("%.2f", rl.rate*multiplier))
            c.Header("X-RateLimit-Remaining", "0")
            c.Header("X-RateLimit-Reset", fmt.Sprintf("%d", time.Now().Add(time.Second).Unix()))

            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "Rate limit exceeded",
                "retry_after": 1,
                "limit_type": "smart",
            })
            c.Abort()
            return
        }

        c.Next()
    }
}
```

### ä¸­é—´ä»¶æ€§èƒ½ä¼˜åŒ–

#### ä¸­é—´ä»¶æ‰§è¡Œé¡ºåºä¼˜åŒ–
```go
// æœ€ä½³ä¸­é—´ä»¶æ‰§è¡Œé¡ºåº
func setupMiddleware(engine *gin.Engine) {
    // 1. åŸºç¡€ä¸­é—´ä»¶ï¼ˆæœ€å¤–å±‚ï¼‰
    engine.Use(recoveryMiddleware())           // æ¢å¤panic
    engine.Use(corsMiddleware())               // CORSå¤„ç†
    engine.Use(requestIDMiddleware())          // è¯·æ±‚ID

    // 2. å®‰å…¨å’Œé™æµä¸­é—´ä»¶ï¼ˆå°½æ—©è¿‡æ»¤ï¼‰
    engine.Use(rateLimitMiddleware())          // é™æµ
    engine.Use(securityHeadersMiddleware())    // å®‰å…¨å¤´
    engine.Use(compressionMiddleware())        // å‹ç¼©å“åº”

    // 3. ç›‘æ§å’Œæ—¥å¿—ä¸­é—´ä»¶
    engine.Use(prometheusMiddleware())         // æŒ‡æ ‡æ”¶é›†
    engine.Use(loggingMiddleware())            // æ—¥å¿—è®°å½•
}
```

---

## ğŸ›£ï¸ é«˜çº§è·¯ç”±æŠ€æœ¯

### åŠ¨æ€è·¯ç”±å’Œå‚æ•°éªŒè¯

#### é«˜çº§å‚æ•°å¤„ç†å’ŒéªŒè¯
```go
package routes

import (
    "fmt"
    "net/http"
    "regexp"
    "strconv"
    "strings"

    "github.com/gin-gonic/gin"
    "github.com/go-playground/validator/v10"
)

// CustomValidator è‡ªå®šä¹‰éªŒè¯å™¨
type CustomValidator struct {
    validator *validator.Validate
}

func NewCustomValidator() *CustomValidator {
    v := validator.New()

    // æ³¨å†Œè‡ªå®šä¹‰éªŒè¯å‡½æ•°
    v.RegisterValidation("slug", validateSlug)
    v.RegisterValidation("phone", validatePhone)
    v.RegisterValidation("strong_password", validateStrongPassword)

    return &CustomValidator{validator: v}
}

func (cv *CustomValidator) Validate(i interface{}) error {
    return cv.validator.Struct(i)
}

// validateSlug éªŒè¯slugæ ¼å¼
func validateSlug(fl validator.FieldLevel) bool {
    slug := fl.Field().String()
    matched, _ := regexp.MatchString(`^[a-z0-9-]+$`, slug)
    return matched
}

// validatePhone éªŒè¯æ‰‹æœºå·æ ¼å¼ï¼ˆæ”¯æŒå›½é™…æ ¼å¼ï¼‰
func validatePhone(fl validator.FieldLevel) bool {
    phone := fl.Field().String()
    // æ”¯æŒä¸­å›½æ‰‹æœºå·
    matched, _ := regexp.MatchString(`^1[3-9]\d{9}$|^(\+86)?1[3-9]\d{9}$`, phone)
    return matched
}

// validateStrongPassword éªŒè¯å¼ºå¯†ç 
func validateStrongPassword(fl validator.FieldLevel) bool {
    password := fl.Field().String()

    // è‡³å°‘8ä½ï¼ŒåŒ…å«å¤§å°å†™å­—æ¯ã€æ•°å­—å’Œç‰¹æ®Šå­—ç¬¦
    if len(password) < 8 {
        return false
    }

    hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
    hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
    hasDigit := regexp.MustCompile(`\d`).MatchString(password)
    hasSpecial := regexp.MustCompile(`[!@#$%^&*(),.?":{}|<>]`).MatchString(password)

    return hasUpper && hasLower && hasDigit && hasSpecial
}

// SetupAdvancedRoutes è®¾ç½®é«˜çº§è·¯ç”±
func SetupAdvancedRoutes(r *gin.Engine, validator *CustomValidator) {
    // APIç‰ˆæœ¬åˆ†ç»„
    v1 := r.Group("/api/v1")
    {
        // ç”¨æˆ·ç›¸å…³è·¯ç”±
        users := v1.Group("/users")
        {
            // å¤æ‚å‚æ•°è·¯ç”±
            users.GET("/:id([0-9]+)/posts/:post_id([0-9]+)/comments", getUserPostComments)

            // å¯é€‰å‚æ•°è·¯ç”±
            users.GET("/search", searchUsers)

            // é€šé…ç¬¦è·¯ç”±
            users.GET("/files/*filepath", serveUserFiles)

            // å¤šå‚æ•°è·¯ç”±
            users.GET("/stats/:period([a-z]+)/:year([0-9]{4})", getUserStats)
        }

        // äº§å“ç›¸å…³è·¯ç”±
        products := v1.Group("/products")
        {
            // å‚æ•°éªŒè¯è·¯ç”±
            products.POST("/", createProduct(validator))
            products.PUT("/:id([0-9]+)", updateProduct(validator))
            products.GET("/category/:category_slug", getProductsByCategory)
        }
    }
}

// å¤æ‚å‚æ•°å¤„ç†ç¤ºä¾‹
func getUserPostComments(c *gin.Context) {
    userID := c.Param("id")
    postID := c.Param("post_id")

    // å‚æ•°ç±»å‹è½¬æ¢å’ŒéªŒè¯
    uid, err := strconv.ParseUint(userID, 10, 32)
    if err != nil {
        c.JSON(400, gin.H{"error": "Invalid user ID"})
        return
    }

    pid, err := strconv.ParseUint(postID, 10, 32)
    if err != nil {
        c.JSON(400, gin.H{"error": "Invalid post ID"})
        return
    }

    // æŸ¥è¯¢å‚æ•°å¤„ç†
    queryParams := struct {
        Page     int    `form:"page" binding:"min=1"`
        Limit    int    `form:"limit" binding:"min=1,max=100"`
        Sort     string `form:"sort" binding:"oneof=created_at updated_at score"`
        Order    string `form:"order" binding:"oneof=asc desc"`
        Include  string `form:"include" binding:"oneof=author replies likes"`
    }{
        Page:  1,
        Limit: 10,
        Sort:  "created_at",
        Order: "desc",
    }

    if err := c.ShouldBindQuery(&queryParams); err != nil {
        c.JSON(400, gin.H{"error": "Invalid query parameters", "details": err.Error()})
        return
    }

    // ä¸šåŠ¡é€»è¾‘å¤„ç†...
    c.JSON(200, gin.H{
        "user_id":  uid,
        "post_id": pid,
        "params":  queryParams,
        "data":    "comments data...",
    })
}
```

### RESTful APIæœ€ä½³å®è·µ

#### å®Œæ•´çš„CRUDè·¯ç”±è®¾è®¡
```go
package api

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"
)

// UserAPI ç”¨æˆ·APIç»“æ„
type UserAPI struct {
    userService UserService
    validator   *CustomValidator
}

// NewUserAPI åˆ›å»ºç”¨æˆ·API
func NewUserAPI(userService UserService, validator *CustomValidator) *UserAPI {
    return &UserAPI{
        userService: userService,
        validator:   validator,
    }
}

// RegisterRoutes æ³¨å†Œç”¨æˆ·è·¯ç”±
func (api *UserAPI) RegisterRoutes(router *gin.RouterGroup) {
    users := router.Group("/users")
    {
        // ç”¨æˆ·CRUDæ“ä½œ
        users.POST("", api.CreateUser)                    // POST /users
        users.GET("", api.GetUsers)                       // GET /users
        users.GET("/:id", api.GetUserByID)                // GET /users/:id
        users.PUT("/:id", api.UpdateUser)                 // PUT /users/:id
        users.PATCH("/:id", api.PatchUser)                // PATCH /users/:id
        users.DELETE("/:id", api.DeleteUser)              // DELETE /users/:id

        // ç”¨æˆ·èµ„æºè·¯ç”±
        users.GET("/:id/posts", api.GetUserPosts)         // GET /users/:id/posts
        users.GET("/:id/profile", api.GetUserProfile)     // GET /users/:id/profile
        users.PUT("/:id/profile", api.UpdateUserProfile)  // PUT /users/:id/profile

        // æ‰¹é‡æ“ä½œ
        users.POST("/batch", api.BatchCreateUsers)        // POST /users/batch
        users.DELETE("/batch", api.BatchDeleteUsers)      // DELETE /users/batch

        // é«˜çº§æŸ¥è¯¢
        users.GET("/search", api.SearchUsers)             // GET /users/search
        users.GET("/export", api.ExportUsers)             // GET /users/export
    }
}

// CreateUser åˆ›å»ºç”¨æˆ· - å®Œæ•´å®ç°
func (api *UserAPI) CreateUser(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error":   "Invalid request body",
            "details": err.Error(),
            "code":    "INVALID_REQUEST_BODY",
        })
        return
    }

    // è‡ªå®šä¹‰éªŒè¯
    if err := api.validator.Validate(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error":   "Validation failed",
            "details": err.Error(),
            "code":    "VALIDATION_FAILED",
        })
        return
    }

    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    exists, err := api.userService.UsernameExists(c.Request.Context(), req.Username)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to check username",
            "code":  "USERNAME_CHECK_FAILED",
        })
        return
    }
    if exists {
        c.JSON(http.StatusConflict, gin.H{
            "error": "Username already exists",
            "code":  "USERNAME_EXISTS",
        })
        return
    }

    // åˆ›å»ºç”¨æˆ·
    user, err := api.userService.Create(c.Request.Context(), &req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error":   "Failed to create user",
            "details": err.Error(),
            "code":    "CREATE_USER_FAILED",
        })
        return
    }

    c.JSON(http.StatusCreated, gin.H{
        "data":    user,
        "message": "User created successfully",
        "code":    "USER_CREATED",
    })
}

// Request/Response ç»“æ„ä½“
type CreateUserRequest struct {
    Username string `json:"username" binding:"required,min=3,max=50" validate:"slug"`
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=8" validate:"strong_password"`
    Phone    string `json:"phone" validate:"phone"`
    Role     string `json:"role" binding:"required,oneof=admin user moderator"`
    Profile  UserProfile `json:"profile"`
}

type UserProfile struct {
    FirstName string `json:"first_name" binding:"required,min=1,max=50"`
    LastName  string `json:"last_name" binding:"required,min=1,max=50"`
    Bio       string `json:"bio" binding:"max=500"`
    Avatar    string `json:"avatar" binding:"omitempty,url"`
}

type GetUserListParams struct {
    Page     int      `form:"page" binding:"min=1"`
    Limit    int      `form:"limit" binding:"min=1,max=100"`
    Sort     string   `form:"sort" binding:"oneof=created_at updated_at username email"`
    Order    string   `form:"order" binding:"oneof=asc desc"`
    Search   string   `form:"search"`
    Status   string   `form:"status" binding:"oneof=active inactive suspended"`
    Role     string   `form:"role" binding:"oneof=admin user moderator"`
    Tags     []string `form:"tags[]"`
    Created string   `form:"created"`
}
```

---

## âš¡ Ginæ€§èƒ½è°ƒä¼˜

### å†…å­˜ä¼˜åŒ–

#### å¯¹è±¡æ± å’Œç¼“å­˜ä¼˜åŒ–
```go
package optimization

import (
    "sync"
    "sync/atomic"

    "github.com/gin-gonic/gin"
)

var (
    // Contextå¯¹è±¡æ± 
    contextPool = sync.Pool{
        New: func() interface{} {
            return make(gin.H, 10) // é¢„åˆ†é…å®¹é‡
        },
    }

    // å­—èŠ‚æ•°ç»„æ± 
    bytesPool = sync.Pool{
        New: func() interface{} {
            return make([]byte, 0, 1024) // 1KBåˆå§‹å®¹é‡
        },
    }

    // å“åº”å†™å…¥å™¨æ± 
    responseWriterPool = sync.Pool{
        New: func() interface{} {
            return &responseBodyWriter{
                body: make([]byte, 0, 512),
            }
        },
    }
)

// GetContext ä»æ± ä¸­è·å–context
func GetContext() gin.H {
    ctx := contextPool.Get().(gin.H)
    // æ¸…ç©ºcontextä½†ä¸é‡æ–°åˆ†é…ï¼Œä¿ç•™å®¹é‡
    for k := range ctx {
        delete(ctx, k)
    }
    return ctx
}

// PutContext å°†contextæ”¾å›æ± ä¸­
func PutContext(c gin.H) {
    if len(c) <= 20 { // åªå›æ”¶è¾ƒå°çš„context
        contextPool.Put(c)
    }
}

// GetBytes ä»æ± ä¸­è·å–å­—èŠ‚æ•°ç»„
func GetBytes() []byte {
    return bytesPool.Get().([]byte)
}

// PutBytes å°†å­—èŠ‚æ•°ç»„æ”¾å›æ± ä¸­
func PutBytes(b []byte) {
    if cap(b) >= 256 && cap(b) <= 4096 { // åªå›æ”¶åˆç†å¤§å°çš„æ•°ç»„
        bytesPool.Put(b[:0])
    }
}

// responseBodyWriter ä¼˜åŒ–çš„å“åº”å†™å…¥å™¨
type responseBodyWriter struct {
    gin.ResponseWriter
    body   []byte
    buffer []byte // ä½¿ç”¨é¢„åˆ†é…çš„ç¼“å†²åŒº
}

func (r *responseBodyWriter) Write(b []byte) (int, error) {
    if r.buffer == nil {
        r.buffer = GetBytes()
    }
    r.buffer = append(r.buffer, b...)
    return len(b), nil
}

func (r *responseBodyWriter) Bytes() []byte {
    return r.buffer
}

func (r *responseBodyWriter) Reset() {
    if r.buffer != nil {
        PutBytes(r.buffer)
        r.buffer = nil
    }
    r.body = r.body[:0]
}
```

### å¹¶å‘å¤„ç†ä¼˜åŒ–

#### æ— é”å¹¶å‘å®‰å…¨å®ç°
```go
package optimization

import (
    "sync/atomic"
    "time"
)

// ConcurrencyMetrics å¹¶å‘å®‰å…¨æŒ‡æ ‡
type ConcurrencyMetrics struct {
    // ä½¿ç”¨åŸå­æ“ä½œçš„å­—æ®µ
    requestCount    int64
    responseTime    int64
    activeRequests  int64
    errorCount      int64

    // è¯»å†™é”ä¿æŠ¤çš„å­—æ®µ
    lastRequests    []RequestInfo
    mutex           sync.RWMutex
}

type RequestInfo struct {
    Timestamp time.Time
    Method    string
    Path      string
    Status    int
    Duration  time.Duration
}

// RecordRequest è®°å½•è¯·æ±‚ï¼ˆæ— é”æ“ä½œï¼‰
func (m *ConcurrencyMetrics) RecordRequest(method, path string, status int, duration time.Duration) {
    atomic.AddInt64(&m.requestCount, 1)
    atomic.AddInt64(&m.responseTime, duration.Nanoseconds())

    if status >= 400 {
        atomic.AddInt64(&m.errorCount, 1)
    }

    // åªåœ¨éœ€è¦æ—¶æ‰ä½¿ç”¨é”
    if shouldTrackRequest(method, path) {
        info := RequestInfo{
            Timestamp: time.Now(),
            Method:    method,
            Path:      path,
            Status:    status,
            Duration:  duration,
        }

        m.mutex.Lock()
        m.lastRequests = append(m.lastRequests, info)
        // ä¿æŒæœ€è¿‘100ä¸ªè¯·æ±‚
        if len(m.lastRequests) > 100 {
            m.lastRequests = m.lastRequests[1:]
        }
        m.mutex.Unlock()
    }
}

func shouldTrackRequest(method, path string) bool {
    // åªè·Ÿè¸ªé‡è¦çš„è¯·æ±‚
    return method != "GET" ||
           (len(path) > 0 && path[0] == '/' &&
            (contains([]string{"api", "admin", "user"}, path) ||
             len(path) > 20))
}

// GetStats è·å–ç»Ÿè®¡ä¿¡æ¯ï¼ˆæ— é”è¯»å–ï¼‰
func (m *ConcurrencyMetrics) GetStats() map[string]interface{} {
    reqCount := atomic.LoadInt64(&m.requestCount)
    respTime := atomic.LoadInt64(&m.responseTime)
    activeReq := atomic.LoadInt64(&m.activeRequests)
    errCount := atomic.LoadInt64(&m.errorCount)

    avgResponseTime := float64(0)
    if reqCount > 0 {
        avgResponseTime = float64(respTime) / float64(reqCount) / 1e9
    }

    errorRate := float64(0)
    if reqCount > 0 {
        errorRate = float64(errCount) / float64(reqCount) * 100
    }

    return map[string]interface{}{
        "request_count":     reqCount,
        "active_requests":   activeReq,
        "error_count":       errCount,
        "error_rate":        errorRate,
        "avg_response_time": avgResponseTime,
    }
}
```

### Benchmarkæµ‹è¯•å’Œæ€§èƒ½åˆ†æ

#### å®Œæ•´çš„æ€§èƒ½æµ‹è¯•å¥—ä»¶
```go
package benchmarks

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
    "net/http/httptest"
    "runtime"
    "sync"
    "testing"

    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
)

// BenchmarkSimpleRoute æµ‹è¯•ç®€å•è·¯ç”±æ€§èƒ½
func BenchmarkSimpleRoute(b *testing.B) {
    gin.SetMode(gin.ReleaseMode)
    router := gin.New()
    router.GET("/ping", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "pong"})
    })

    req := httptest.NewRequest("GET", "/ping", nil)

    b.ResetTimer()
    b.ReportAllocs()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            w := httptest.NewRecorder()
            router.ServeHTTP(w, req)
            assert.Equal(b, 200, w.Code)
        }
    })
}

// BenchmarkMiddlewareChain æµ‹è¯•ä¸­é—´ä»¶é“¾æ€§èƒ½
func BenchmarkMiddlewareChain(b *testing.B) {
    gin.SetMode(gin.ReleaseMode)
    router := gin.New()

    // æ·»åŠ å¤šä¸ªä¸­é—´ä»¶
    router.Use(gin.Logger())
    router.Use(gin.Recovery())

    // è‡ªå®šä¹‰ä¸­é—´ä»¶
    for i := 0; i < 5; i++ {
        router.Use(func(c *gin.Context) {
            c.Set(fmt.Sprintf("key_%d", i), fmt.Sprintf("value_%d", i))
            c.Next()
        })
    }

    router.GET("/test", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "ok"})
    })

    req := httptest.NewRequest("GET", "/test", nil)

    b.ResetTimer()
    b.ReportAllocs()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            w := httptest.NewRecorder()
            router.ServeHTTP(w, req)
            assert.Equal(b, 200, w.Code)
        }
    })
}

// BenchmarkJSONSerialization æµ‹è¯•JSONåºåˆ—åŒ–æ€§èƒ½
func BenchmarkJSONSerialization(b *testing.B) {
    gin.SetMode(gin.ReleaseMode)
    router := gin.New()

    type LargeUser struct {
        ID       int      `json:"id"`
        Name     string   `json:"name"`
        Email    string   `json:"email"`
        Tags     []string `json:"tags"`
        Profile  Profile  `json:"profile"`
        Settings Settings `json:"settings"`
    }

    type Profile struct {
        Bio        string   `json:"bio"`
        Avatar     string   `json:"avatar"`
        Social     Social   `json:"social"`
        Preferences []string `json:"preferences"`
    }

    type Social struct {
        Twitter  string `json:"twitter"`
        LinkedIn string `json:"linkedin"`
        GitHub   string `json:"github"`
    }

    type Settings struct {
        Theme       string   `json:"theme"`
        Language    string   `json:"language"`
        Notifications bool   `json:"notifications"`
        Features    []string `json:"features"`
    }

    router.GET("/user", func(c *gin.Context) {
        user := LargeUser{
            ID:    1,
            Name:  "John Doe",
            Email: "john@example.com",
            Tags:  []string{"developer", "golang", "backend"},
            Profile: Profile{
                Bio:    "Software engineer with 5+ years of experience",
                Avatar: "https://example.com/avatar.jpg",
                Social: Social{
                    Twitter:  "@johndoe",
                    LinkedIn: "linkedin.com/in/johndoe",
                    GitHub:   "github.com/johndoe",
                },
                Preferences: []string{"coding", "reading", "traveling"},
            },
            Settings: Settings{
                Theme:        "dark",
                Language:     "en",
                Notifications: true,
                Features:     []string{"beta", "analytics", "backup"},
            },
        }
        c.JSON(200, user)
    })

    req := httptest.NewRequest("GET", "/user", nil)

    b.ResetTimer()
    b.ReportAllocs()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            w := httptest.NewRecorder()
            router.ServeHTTP(w, req)
            assert.Equal(b, 200, w.Code)

            // éªŒè¯å“åº”å†…å®¹
            var response LargeUser
            err := json.Unmarshal(w.Body.Bytes(), &response)
            assert.NoError(b, err)
            assert.Equal(b, "John Doe", response.Name)
        }
    })
}

// BenchmarkConcurrentRequests æµ‹è¯•å¹¶å‘è¯·æ±‚æ€§èƒ½
func BenchmarkConcurrentRequests(b *testing.B) {
    gin.SetMode(gin.ReleaseMode)
    router := gin.New()

    router.GET("/compute", func(c *gin.Context) {
        // æ¨¡æ‹Ÿä¸€äº›è®¡ç®—
        sum := 0
        for i := 0; i < 1000; i++ {
            sum += i * i
        }
        c.JSON(200, gin.H{"sum": sum})
    })

    req := httptest.NewRequest("GET", "/compute", nil)

    b.ResetTimer()

    // æµ‹è¯•ä¸åŒçš„å¹¶å‘çº§åˆ«
    for _, concurrency := range []int{1, 10, 50, 100, 500} {
        b.Run(fmt.Sprintf("Concurrency-%d", concurrency), func(b *testing.B) {
            b.SetParallelism(concurrency)
            b.ReportAllocs()

            var wg sync.WaitGroup
            b.RunParallel(func(pb *testing.PB) {
                for pb.Next() {
                    wg.Add(1)
                    go func() {
                        defer wg.Done()
                        w := httptest.NewRecorder()
                        router.ServeHTTP(w, req)
                    }()
                }
            })
            wg.Wait()
        })
    }
}

// BenchmarkMemoryUsage æµ‹è¯•å†…å­˜ä½¿ç”¨æƒ…å†µ
func BenchmarkMemoryUsage(b *testing.B) {
    gin.SetMode(gin.ReleaseMode)
    router := gin.New()

    router.POST("/process", func(c *gin.Context) {
        var data map[string]interface{}
        if err := c.ShouldBindJSON(&data); err != nil {
            c.JSON(400, gin.H{"error": err.Error()})
            return
        }

        // å¤„ç†æ•°æ®
        result := make(map[string]interface{})
        for k, v := range data {
            result[k] = fmt.Sprintf("processed_%v", v)
        }

        c.JSON(200, result)
    })

    // å‡†å¤‡æµ‹è¯•æ•°æ®
    testData := map[string]interface{}{
        "name":    "test",
        "value":   123,
        "active":  true,
        "tags":    []string{"a", "b", "c"},
        "nested":  map[string]interface{}{"key": "value"},
    }

    jsonData, _ := json.Marshal(testData)

    b.ResetTimer()
    b.ReportAllocs()

    // å¼ºåˆ¶GCä»¥è·å¾—æ›´å‡†ç¡®çš„å†…å­˜ç»Ÿè®¡
    runtime.GC()
    var m1, m2 runtime.MemStats
    runtime.ReadMemStats(&m1)

    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            req := httptest.NewRequest("POST", "/process", bytes.NewBuffer(jsonData))
            req.Header.Set("Content-Type", "application/json")

            w := httptest.NewRecorder()
            router.ServeHTTP(w, req)
            assert.Equal(b, 200, w.Code)
        }
    })

    runtime.GC()
    runtime.ReadMemStats(&m2)

    b.ReportMetric(float64(m2.TotalAlloc-m1.TotalAlloc)/1024/1024, "MB/op")
}
```

---

## ğŸ” Ginæºç è§£æ

### è·¯ç”±å¼•æ“åŸç†

#### Radix Treeè·¯ç”±ç®—æ³•æ·±åº¦è§£æ
```go
// Ginä½¿ç”¨çš„è·¯ç”±ç®—æ³•æ ¸å¿ƒæ¦‚å¿µ
package routing

import (
    "strings"
)

// Radix TreeèŠ‚ç‚¹ç±»å‹
type nodeType uint8

const (
    static   nodeType = iota // é™æ€èŠ‚ç‚¹
    root                     // æ ¹èŠ‚ç‚¹
    param                    // å‚æ•°èŠ‚ç‚¹ :param
    catchAll                 // é€šé…ç¬¦èŠ‚ç‚¹ *param
)

// è·¯ç”±èŠ‚ç‚¹ç»“æ„
type node struct {
    path      string          // å½“å‰è·¯å¾„æ®µ
    wildChild bool            // æ˜¯å¦æœ‰é€šé…ç¬¦å­èŠ‚ç‚¹
    nType     nodeType        // èŠ‚ç‚¹ç±»å‹
    indices   string          // å­èŠ‚ç‚¹ç´¢å¼•ï¼ˆç”¨äºå¿«é€ŸæŸ¥æ‰¾ï¼‰
    children  []*node         // å­èŠ‚ç‚¹
    handler   gin.HandlerFunc // å¤„ç†å‡½æ•°
    priority  uint32          // ä¼˜å…ˆçº§ï¼ˆç”¨äºèŠ‚ç‚¹æ’åºï¼‰
    fullPath  string          // å®Œæ•´è·¯å¾„
}

// addRoute æ·»åŠ è·¯ç”±çš„æ ¸å¿ƒé€»è¾‘
func (n *node) addRoute(path string, handler gin.HandlerFunc) {
    fullPath := path
    n.priority++

    // ç©ºæ ‘å¤„ç†
    if len(n.path) == 0 && len(n.children) == 0 {
        n.insertChild(path, fullPath, handler)
        return
    }

walk:
    for {
        // æŸ¥æ‰¾æœ€é•¿å…¬å…±å‰ç¼€
        i := longestCommonPrefix(path, n.path)

        // å¦‚æœæœ‰å…±åŒå‰ç¼€ä½†ä¸æ˜¯å®Œå…¨åŒ¹é…ï¼Œéœ€è¦åˆ†å‰²èŠ‚ç‚¹
        if i < len(n.path) {
            child := node{
                path:      n.path[i:],      // å‰©ä½™éƒ¨åˆ†
                wildChild: n.wildChild,
                nType:     static,
                indices:   n.indices,
                children:  n.children,
                handler:   n.handler,
                priority:  n.priority - 1, // é™ä½ä¼˜å…ˆçº§
                fullPath:  n.fullPath,
            }

            n.children = []*node{&child}
            n.indices = string([]byte{n.path[i]})
            n.path = path[:i]
            n.handler = nil
            n.wildChild = false
        }

        // æ’å…¥æ–°è·¯å¾„çš„å‰©ä½™éƒ¨åˆ†
        if i < len(path) {
            path = path[i:]

            // å¤„ç†é€šé…ç¬¦
            if n.wildChild {
                n = n.children[0]
                n.priority++

                // æ£€æŸ¥é€šé…ç¬¦å†²çª
                if len(path) >= len(n.path) && n.path == path[:len(n.path)] &&
                    (len(n.path) >= len(path) || path[len(n.path)] == '/') {
                    continue walk
                }

                panic("path segment wildcard conflict")
            }

            c := path[0]

            // å¤„ç†å‚æ•°èŠ‚ç‚¹
            if n.nType == param && c == '/' && len(n.children) == 1 {
                n = n.children[0]
                n.priority++
                continue walk
            }

            // æ£€æŸ¥ç°æœ‰å­èŠ‚ç‚¹
            for i, index := range []byte(n.indices) {
                if c == index {
                    i = n.incrementChildPrio(i)
                    n = n.children[i]
                    continue walk
                }
            }

            // æ·»åŠ æ–°å­èŠ‚ç‚¹
            if c != ':' && c != '*' {
                n.indices += string([]byte{c})
                child := &node{}
                n.children = append(n.children, child)
                n.incrementChildPrio(len(n.indices) - 1)
                n = child
            }
            n.insertChild(path, fullPath, handler)
            return
        }

        // è®¾ç½®å¤„ç†å‡½æ•°
        if n.handler != nil {
            panic("path handler conflict")
        }
        n.handler = handler
        n.fullPath = fullPath
        return
    }
}

// insertChild æ’å…¥å­èŠ‚ç‚¹
func (n *node) insertChild(path, fullPath string, handler gin.HandlerFunc) {
    for {
        // æŸ¥æ‰¾é€šé…ç¬¦
        wildcard, i, valid := findWildcard(path)
        if i < 0 {
            // æ²¡æœ‰é€šé…ç¬¦ï¼Œåˆ›å»ºé™æ€èŠ‚ç‚¹
            n.path = path
            n.handler = handler
            n.fullPath = fullPath
            return
        }

        // æ£€æŸ¥é€šé…ç¬¦æœ‰æ•ˆæ€§
        if !valid {
            panic("invalid wildcard in path")
        }

        // åˆ›å»ºé€šé…ç¬¦èŠ‚ç‚¹
        if wildcard[0] == ':' { // å‚æ•°èŠ‚ç‚¹
            if i > 0 {
                // åœ¨é€šé…ç¬¦å‰åˆ›å»ºé™æ€èŠ‚ç‚¹
                n.path = path[:i]
                path = path[i:]
            }

            n.wildChild = true
            child := &node{
                nType:    param,
                fullPath: fullPath,
            }
            n.children = []*node{child}
            n = child
            n.priority++

            // å¦‚æœé€šé…ç¬¦åæœ‰æ›´å¤šè·¯å¾„ï¼Œç»§ç»­å¤„ç†
            if len(wildcard) < len(path) {
                path = path[len(wildcard):]
                child := &node{
                    priority: 1,
                }
                n.children = []*node{child}
                n = child
                continue
            }

            // è®¾ç½®å¤„ç†å‡½æ•°å¹¶è¿”å›
            n.handler = handler
            return
        }

        // å¤„ç†é€šé…ç¬¦èŠ‚ç‚¹ (*)
        if i+len(wildcard) < len(path) {
            panic("catch-all routes are only allowed at the end of the path")
        }

        if len(n.path) > 0 && n.path[len(n.path)-1] == '/' {
            panic("catch-all conflicts with existing handle for the path segment root")
        }

        i--
        if path[i] != '/' {
            panic("no / before catch-all")
        }

        n.path = path[:i]

        // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼šè·¯å¾„ä¸ºé™æ€
        if len(n.path) > 0 {
            n.indices = string('/')
            child := &node{
                wildChild: true,
                nType:     catchAll,
                fullPath:  fullPath,
            }
            n.children = []*node{child}
            n = child
            n.priority++

            // ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼šé€šé…ç¬¦
            child = &node{
                path:     path[i:],
                nType:    catchAll,
                handler:  handler,
                priority: 1,
                fullPath: fullPath,
            }
            n.children = []*node{child}
            return
        }

        // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼šé€šé…ç¬¦
        n.wildChild = true
        child := &node{
            path:     path[i:],
            nType:    catchAll,
            handler:  handler,
            priority: 1,
            fullPath: fullPath,
        }
        n.children = []*node{child}
        return
    }
}

// è¾…åŠ©å‡½æ•°
func longestCommonPrefix(a, b string) int {
    i := 0
    max := min(len(a), len(b))
    for i < max && a[i] == b[i] {
        i++
    }
    return i
}

func findWildcard(path string) (wildcard string, i int, valid bool) {
    for start, c := range []byte(path) {
        if c != ':' && c != '*' {
            continue
        }

        valid = true
        for end, c := range []byte(path[start+1:]) {
            switch c {
            case '/':
                return path[start : start+1+end], start, valid
            case ':', '*':
                valid = false
            }
        }
        return path[start:], start, valid
    }
    return "", -1, false
}
```

### Contextæºç åˆ†æ

#### Contextç»“æ„å’Œä¸­é—´ä»¶æœºåˆ¶
```go
// Contextçš„æ ¸å¿ƒå®ç°åˆ†æ
package context

import (
    "net/http"
    "time"
)

// Contextç»“æ„ä½“ï¼ˆç®€åŒ–ç‰ˆï¼‰
type Context struct {
    writermem responseWriter
    Request   *http.Request
    Writer    ResponseWriter

    // è·¯ç”±å‚æ•°
    Params   Params
    handlers HandlersChain
    index    int8
    fullPath string

    // ç¼“å­˜
    engine *Engine
    params *Params

    // é”®å€¼å­˜å‚¨
    Keys map[string]interface{}

    // é”™è¯¯
    Errors errorMsgs

    // å…¶ä»–å­—æ®µ...
}

// HandlersChain ä¸­é—´ä»¶é“¾ç±»å‹
type HandlersChain []HandlerFunc

// Next æ‰§è¡Œä¸‹ä¸€ä¸ªä¸­é—´ä»¶çš„æ ¸å¿ƒé€»è¾‘
func (c *Context) Next() {
    c.index++
    for c.index < int8(len(c.handlers)) {
        c.handlers[c.index](c)
        c.index++
    }
}

// Abort ä¸­æ­¢ä¸­é—´ä»¶é“¾æ‰§è¡Œ
func (c *Context) Abort() {
    c.index = abortIndex
}

// AbortWithStatus ä¸­æ­¢å¹¶è®¾ç½®çŠ¶æ€ç 
func (c *Context) AbortWithStatus(code int) {
    c.Status(code)
    c.Abort()
}

// IsAborted æ£€æŸ¥æ˜¯å¦å·²ä¸­æ­¢
func (c *Context) IsAborted() bool {
    return c.index >= abortIndex
}

// Set è®¾ç½®é”®å€¼å¯¹
func (c *Context) Set(key string, value interface{}) {
    if c.Keys == nil {
        c.Keys = make(map[string]interface{})
    }
    c.Keys[key] = value
}

// Get è·å–å€¼
func (c *Context) Get(key string) (value interface{}, exists bool) {
    if c.Keys != nil {
        value, exists = c.Keys[key]
    }
    return
}

// MustGet è·å–å€¼ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™panic
func (c *Context) MustGet(key string) interface{} {
    if value, exists := c.Get(key); exists {
        return value
    }
    panic("Key \"" + key + "\" does not exist")
}

// GetString è·å–å­—ç¬¦ä¸²å€¼
func (c *Context) GetString(key string) (s string) {
    if val, ok := c.Get(key); ok {
        s, _ = val.(string)
    }
    return
}

// ä¸­é—´ä»¶æ‰§è¡Œæµç¨‹åˆ†æ
func (c *Context) reset() {
    c.Writer = &c.writermem
    c.Params = c.Params[:0]
    c.handlers = nil
    c.index = -1
    c.fullPath = ""
    c.Keys = nil
    c.Errors = c.Errors[:0]
    // é‡ç½®å…¶ä»–å­—æ®µ...
}

// ä¸­é—´ä»¶é“¾çš„å®é™…æ‰§è¡Œè¿‡ç¨‹
func (engine *Engine) handleHTTPRequest(c *Context) {
    // 1. æŸ¥æ‰¾è·¯ç”±
    httpMethod := c.Request.Method
    rPath := c.Request.URL.Path
    unescape := false

    // 2. è·¯ç”±åŒ¹é…å’Œå‚æ•°æå–
    t := engine.trees
    for i, tl := 0, len(t); i < tl; i++ {
        if t[i].method != httpMethod {
            continue
        }
        root := t[i].root
        // è·¯ç”±åŒ¹é…é€»è¾‘...
        if root != nil {
            // 3. è®¾ç½®å¤„ç†å‡½æ•°é“¾
            c.handlers = engine.allNoMethod
            c.Params = node.params
            c.fullPath = node.fullPath
            break
        }
    }

    // 4. æ‰§è¡Œä¸­é—´ä»¶é“¾
    if c.handlers != nil {
        c.handlers[0](c)
    } else {
        c.handlers = engine.allNoRoute
        handle404(c)
    }
}
```

---

## ğŸ¢ Giné«˜çº§åº”ç”¨æ¡ˆä¾‹

### å¤§å‹APIé¡¹ç›®æ¶æ„

#### åˆ†å±‚æ¶æ„å’Œä¾èµ–æ³¨å…¥
```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "gorm.io/gorm"
)

// Application åº”ç”¨ä¸»ç»“æ„
type Application struct {
    Config     *Config
    DB         *gorm.DB
    Redis      *redis.Client
    Logger     *logrus.Logger
    Metrics    *prometheus.Registry

    // æœåŠ¡å±‚ï¼ˆä¾èµ–æ³¨å…¥ï¼‰
    Container *Container
}

// Container ä¾èµ–æ³¨å…¥å®¹å™¨
type Container struct {
    // æ ¸å¿ƒæœåŠ¡
    UserService    *UserService
    ProductService *ProductService
    OrderService   *OrderService
    AuthService    *AuthService
    NotificationService *NotificationService

    // å¤–éƒ¨æœåŠ¡
    EmailService   EmailService
    PaymentService PaymentService
    SMSService     SMSService
    StorageService StorageService

    // å·¥å…·æœåŠ¡
    CacheService    *CacheService
    QueueService    *QueueService
    MetricsService  *MetricsService
}

// NewApplication åˆ›å»ºåº”ç”¨å®ä¾‹
func NewApplication(cfg *Config) (*Application, error) {
    app := &Application{
        Config: cfg,
    }

    // åˆå§‹åŒ–åŸºç¡€è®¾æ–½
    if err := app.initInfrastructure(); err != nil {
        return nil, fmt.Errorf("failed to initialize infrastructure: %w", err)
    }

    // åˆå§‹åŒ–æœåŠ¡å®¹å™¨
    if err := app.initContainer(); err != nil {
        return nil, fmt.Errorf("failed to initialize container: %w", err)
    }

    return app, nil
}

// initInfrastructure åˆå§‹åŒ–åŸºç¡€è®¾æ–½
func (app *Application) initInfrastructure() error {
    // åˆå§‹åŒ–æ•°æ®åº“
    db, err := gorm.Open(app.Config.Database.Driver, app.Config.Database.DSN)
    if err != nil {
        return fmt.Errorf("failed to connect to database: %w", err)
    }
    app.DB = db

    // åˆå§‹åŒ–Redis
    rdb := redis.NewClient(&redis.Options{
        Addr:     app.Config.Redis.Addr,
        Password: app.Config.Redis.Password,
        DB:       app.Config.Redis.DB,
    })
    if err := rdb.Ping(context.Background()).Err(); err != nil {
        return fmt.Errorf("failed to connect to redis: %w", err)
    }
    app.Redis = rdb

    // åˆå§‹åŒ–æ—¥å¿—
    logger := logrus.New()
    logger.SetLevel(logrus.Level(app.Config.LogLevel))
    app.Logger = logger

    // åˆå§‹åŒ–æŒ‡æ ‡
    app.Metrics = prometheus.NewRegistry()

    return nil
}

// initContainer åˆå§‹åŒ–æœåŠ¡å®¹å™¨
func (app *Application) initContainer() error {
    container := &Container{}

    // åˆå§‹åŒ–å·¥å…·æœåŠ¡
    container.CacheService = NewCacheService(app.Redis, app.Logger)
    container.QueueService = NewQueueService(app.Config.Queue, app.Logger)
    container.MetricsService = NewMetricsService(app.Metrics, app.Logger)
    container.StorageService = NewStorageService(app.Config.Storage, app.Logger)

    // åˆå§‹åŒ–å¤–éƒ¨æœåŠ¡
    container.EmailService = NewEmailService(app.Config.Email, app.Logger)
    container.PaymentService = NewPaymentService(app.Config.Payment, app.Logger)
    container.SMSService = NewSMSService(app.Config.SMS, app.Logger)

    // åˆå§‹åŒ–æ ¸å¿ƒæœåŠ¡ï¼ˆä¾èµ–æ³¨å…¥ï¼‰
    container.AuthService = NewAuthService(app.DB, container.CacheService, app.Config.Auth, app.Logger)
    container.UserService = NewUserService(app.DB, container.CacheService, container.NotificationService, app.Logger)
    container.ProductService = NewProductService(app.DB, container.CacheService, container.StorageService, app.Logger)
    container.OrderService = NewOrderService(app.DB, container.CacheService, container.QueueService, container.PaymentService, app.Logger)
    container.NotificationService = NewNotificationService(container.EmailService, container.SMSService, app.Logger)

    app.Container = container
    return nil
}

// SetupRouter è®¾ç½®è·¯ç”±
func (app *Application) SetupRouter() *gin.Engine {
    gin.SetMode(app.Config.GinMode)
    router := gin.New()

    // åŸºç¡€ä¸­é—´ä»¶
    router.Use(app.setupBasicMiddleware())

    // APIè·¯ç”±ç»„
    api := router.Group("/api/v1")
    {
        // å…¬å¼€è·¯ç”±
        public := api.Group("/public")
        {
            app.Container.AuthService.RegisterPublicRoutes(public)
        }

        // éœ€è¦è®¤è¯çš„è·¯ç”±
        protected := api.Group("")
        protected.Use(app.Container.AuthService.JWTAuthMiddleware())
        {
            // ç”¨æˆ·ç›¸å…³
            userGroup := protected.Group("/users")
            app.Container.UserService.RegisterRoutes(userGroup)

            // äº§å“ç›¸å…³
            productGroup := protected.Group("/products")
            app.Container.ProductService.RegisterRoutes(productGroup)

            // è®¢å•ç›¸å…³
            orderGroup := protected.Group("/orders")
            app.Container.OrderService.RegisterRoutes(orderGroup)
        }

        // ç®¡ç†å‘˜è·¯ç”±
        admin := protected.Group("/admin")
        admin.Use(app.Container.AuthService.RoleAuthMiddleware("admin"))
        {
            app.setupAdminRoutes(admin)
        }
    }

    // å¥åº·æ£€æŸ¥å’Œç›‘æ§
    app.setupHealthRoutes(router)
    app.setupMetricsRoutes(router)

    return router
}

// setupBasicMiddleware è®¾ç½®åŸºç¡€ä¸­é—´ä»¶
func (app *Application) setupBasicMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        path := c.Request.URL.Path
        raw := c.Request.URL.RawQuery

        // å¤„ç†è¯·æ±‚
        c.Next()

        // è®°å½•æŒ‡æ ‡
        latency := time.Since(start)
        clientIP := c.ClientIP()
        method := c.Request.Method
        statusCode := c.Writer.Status()

        // PrometheusæŒ‡æ ‡
        app.MetricsService.RecordHTTPRequest(method, path, statusCode, latency)

        // ç»“æ„åŒ–æ—¥å¿—
        app.Logger.WithFields(logrus.Fields{
            "method":     method,
            "path":       path,
            "query":      raw,
            "status":     statusCode,
            "latency":    latency,
            "client_ip":  clientIP,
            "user_agent": c.Request.UserAgent(),
        }).Info("Request processed")
    }
}

// setupHealthRoutes è®¾ç½®å¥åº·æ£€æŸ¥è·¯ç”±
func (app *Application) setupHealthRoutes(router *gin.Engine) {
    health := router.Group("/health")
    {
        health.GET("/live", app.livenessProbe)
        health.GET("/ready", app.readinessProbe)
        health.GET("/startup", app.startupProbe)
    }
}

// livenessProbe å­˜æ´»æ¢é’ˆ
func (app *Application) livenessProbe(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        "status": "healthy",
        "timestamp": time.Now().Unix(),
        "version": app.Config.Version,
    })
}

// readinessProbe å°±ç»ªæ¢é’ˆ
func (app *Application) readinessProbe(c *gin.Context) {
    checks := make(map[string]interface{})

    // æ•°æ®åº“æ£€æŸ¥
    if sqlDB, err := app.DB.DB(); err == nil {
        if err := sqlDB.Ping(); err == nil {
            checks["database"] = "healthy"
        } else {
            checks["database"] = fmt.Sprintf("unhealthy: %v", err)
        }
    } else {
        checks["database"] = "unavailable"
    }

    // Redisæ£€æŸ¥
    if _, err := app.Redis.Ping(context.Background()).Result(); err == nil {
        checks["redis"] = "healthy"
    } else {
        checks["redis"] = fmt.Sprintf("unhealthy: %v", err)
    }

    // åˆ¤æ–­æ•´ä½“çŠ¶æ€
    allHealthy := true
    for _, status := range checks {
        if status != "healthy" {
            allHealthy = false
            break
        }
    }

    statusCode := http.StatusOK
    if !allHealthy {
        statusCode = http.StatusServiceUnavailable
    }

    c.JSON(statusCode, gin.H{
        "status":  map[string]string{"overall": func() string {
            if allHealthy {
                return "healthy"
            }
            return "unhealthy"
        }()},
        "checks": checks,
        "timestamp": time.Now().Unix(),
    })
}
```

### å¾®æœåŠ¡é›†æˆ

#### æœåŠ¡å‘ç°å’Œè´Ÿè½½å‡è¡¡
```go
package microservices

import (
    "context"
    "fmt"
    "net/http"
    "sync"
    "time"

    "github.com/gin-gonic/gin"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

// ServiceRegistry æœåŠ¡æ³¨å†Œä¸­å¿ƒæ¥å£
type ServiceRegistry interface {
    Register(serviceName, instanceID string, addr string, metadata map[string]string) error
    Deregister(serviceName, instanceID string) error
    Discover(serviceName string) ([]ServiceInstance, error)
    Watch(serviceName string) (<-chan []ServiceInstance, error)
}

// ServiceInstance æœåŠ¡å®ä¾‹
type ServiceInstance struct {
    ID       string            `json:"id"`
    Name     string            `json:"name"`
    Address  string            `json:"address"`
    Metadata map[string]string `json:"metadata"`
    Healthy  bool              `json:"healthy"`
}

// LoadBalancer è´Ÿè½½å‡è¡¡å™¨
type LoadBalancer struct {
    registry ServiceRegistry
    services map[string][]ServiceInstance
    mutex    sync.RWMutex
    configs  map[string]LoadBalancerConfig
}

type LoadBalancerConfig struct {
    Strategy string            `json:"strategy"` // round_robin, weighted, least_connections
    Settings map[string]interface{} `json:"settings"`
}

func NewLoadBalancer(registry ServiceRegistry) *LoadBalancer {
    return &LoadBalancer{
        registry: registry,
        services: make(map[string][]ServiceInstance),
        configs:  make(map[string]LoadBalancerConfig),
    }
}

// GetServiceInstance è·å–æœåŠ¡å®ä¾‹
func (lb *LoadBalancer) GetServiceInstance(serviceName string) (*ServiceInstance, error) {
    lb.mutex.RLock()
    instances, exists := lb.services[serviceName]
    config, configExists := lb.configs[serviceName]
    lb.mutex.RUnlock()

    if !exists || len(instances) == 0 {
        // å°è¯•ä»æ³¨å†Œä¸­å¿ƒå‘ç°æœåŠ¡
        discovered, err := lb.registry.Discover(serviceName)
        if err != nil {
            return nil, fmt.Errorf("no instances available for service %s: %w", serviceName, err)
        }

        lb.mutex.Lock()
        lb.services[serviceName] = discovered
        instances = discovered
        lb.mutex.Unlock()
    }

    // è·å–è´Ÿè½½å‡è¡¡é…ç½®
    strategy := "round_robin"
    if configExists {
        strategy = config.Strategy
    }

    // æ ¹æ®ç­–ç•¥é€‰æ‹©å®ä¾‹
    var selected *ServiceInstance
    switch strategy {
    case "round_robin":
        selected = lb.roundRobinSelect(instances, serviceName)
    case "weighted":
        selected = lb.weightedSelect(instances, serviceName)
    case "least_connections":
        selected = lb.leastConnectionsSelect(instances, serviceName)
    default:
        selected = lb.roundRobinSelect(instances, serviceName)
    }

    if selected == nil {
        return nil, fmt.Errorf("no healthy instances available for service: %s", serviceName)
    }

    return selected, nil
}

// roundRobinSelect è½®è¯¢é€‰æ‹©
func (lb *LoadBalancer) roundRobinSelect(instances []ServiceInstance, serviceName string) *ServiceInstance {
    healthyInstances := make([]ServiceInstance, 0)
    for _, instance := range instances {
        if instance.Healthy {
            healthyInstances = append(healthyInstances, instance)
        }
    }

    if len(healthyInstances) == 0 {
        return nil
    }

    // ç®€å•çš„è½®è¯¢å®ç°
    index := int(time.Now().UnixNano()) % len(healthyInstances)
    return &healthyInstances[index]
}

// ServiceProxy æœåŠ¡ä»£ç†ä¸­é—´ä»¶
func (lb *LoadBalancer) ServiceProxy(serviceName string) gin.HandlerFunc {
    return func(c *gin.Context) {
        instance, err := lb.GetServiceInstance(serviceName)
        if err != nil {
            c.JSON(http.StatusServiceUnavailable, gin.H{
                "error": fmt.Sprintf("Service %s unavailable: %v", serviceName, err),
                "service": serviceName,
            })
            return
        }

        // åˆ›å»ºåå‘ä»£ç†
        targetURL := fmt.Sprintf("http://%s", instance.Address)
        proxy := &httputil.ReverseProxy{
            Director: func(req *http.Request) {
                req.URL.Scheme = "http"
                req.URL.Host = instance.Address
                req.Host = instance.Address

                // æ·»åŠ æœåŠ¡è°ƒç”¨è¿½è¸ªå¤´
                req.Header.Set("X-Forwarded-For", c.ClientIP())
                req.Header.Set("X-Forwarded-Proto", "http")
                req.Header.Set("X-Service-Instance", instance.ID)
            },
            ModifyResponse: func(resp *http.Response) error {
                // æ·»åŠ æœåŠ¡å“åº”å¤´
                resp.Header.Set("X-Service-Name", serviceName)
                resp.Header.Set("X-Service-Instance", instance.ID)
                return nil
            },
            ErrorHandler: func(w http.ResponseWriter, r *http.Request, err error) {
                lb.Logger.Printf("Proxy error for service %s: %v", serviceName, err)
                w.WriteHeader(http.StatusBadGateway)
                json.NewEncoder(w).Encode(gin.H{
                    "error": "Service temporarily unavailable",
                    "service": serviceName,
                })
            },
        }

        proxy.ServeHTTP(c.Writer, c.Request)
    }
}

// GrpcClientPool gRPCå®¢æˆ·ç«¯æ± 
type GrpcClientPool struct {
    connections map[string]*grpc.ClientConn
    clients     map[string]interface{}
    mutex       sync.RWMutex
    config      GrpcConfig
}

type GrpcConfig struct {
    MaxRetries    int           `json:"max_retries"`
    Timeout       time.Duration `json:"timeout"`
    KeepAlive     time.Duration `json:"keep_alive"`
    MaxConcurrent int           `json:"max_concurrent"`
}

func NewGrpcClientPool(config GrpcConfig) *GrpcClientPool {
    return &GrpcClientPool{
        connections: make(map[string]*grpc.ClientConn),
        clients:     make(map[string]interface{}),
        config:      config,
    }
}

// GetClient è·å–gRPCå®¢æˆ·ç«¯
func (pool *GrpcClientPool) GetClient(serviceName string) (interface{}, error) {
    pool.mutex.RLock()
    client, exists := pool.clients[serviceName]
    pool.mutex.RUnlock()

    if exists {
        return client, nil
    }

    // åˆ›å»ºæ–°è¿æ¥
    pool.mutex.Lock()
    defer pool.mutex.Unlock()

    // åŒé‡æ£€æŸ¥
    if client, exists := pool.clients[serviceName]; exists {
        return client, nil
    }

    // å‘ç°æœåŠ¡
    instances, err := pool.registry.Discover(serviceName)
    if err != nil {
        return nil, fmt.Errorf("failed to discover service %s: %w", serviceName, err)
    }

    if len(instances) == 0 {
        return nil, fmt.Errorf("no instances available for service %s", serviceName)
    }

    // é€‰æ‹©ä¸€ä¸ªå®ä¾‹
    instance := instances[0] // ç®€åŒ–é€‰æ‹©é€»è¾‘

    // å»ºç«‹è¿æ¥
    conn, err := grpc.Dial(instance.Address,
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithKeepaliveParams(keepalive.ClientParameters{
            Time:                pool.config.KeepAlive,
            Timeout:             pool.config.Timeout,
            PermitWithoutStream: true,
        }),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to connect to service %s: %w", serviceName, err)
    }

    pool.connections[serviceName] = conn

    // åˆ›å»ºå®¢æˆ·ç«¯ï¼ˆè¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“æœåŠ¡ç±»å‹ï¼‰
    client = pb.NewUserServiceClient(conn)
    pool.clients[serviceName] = client

    return client, nil
}

// Close å…³é—­æ‰€æœ‰è¿æ¥
func (pool *GrpcClientPool) Close() error {
    pool.mutex.Lock()
    defer pool.mutex.Unlock()

    var lastErr error
    for serviceName, conn := range pool.connections {
        if err := conn.Close(); err != nil {
            pool.Logger.Printf("Failed to close connection for service %s: %v", serviceName, err)
            lastErr = err
        }
    }

    pool.connections = make(map[string]*grpc.ClientConn)
    pool.clients = make(map[string]interface{})

    return lastErr
}
```

---

## âœ… ä¼ä¸šçº§æœ€ä½³å®è·µ

### å®‰å…¨æœ€ä½³å®è·µ

#### å®Œæ•´çš„å®‰å…¨ä¸­é—´ä»¶ç»„åˆ
```go
package security

import (
    "crypto/subtle"
    "strings"
    "time"

    "github.com/gin-gonic/gin"
    "golang.org/x/crypto/bcrypt"
    "github.com/pquerna/otp/totp"
)

// SecurityMiddleware ç»¼åˆå®‰å…¨ä¸­é—´ä»¶
func SecurityMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // å®‰å…¨å“åº”å¤´
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-XSS-Protection", "1; mode=block")
        c.Header("Referrer-Policy", "strict-origin-when-cross-origin")

        // HSTS (ä»…HTTPS)
        if c.Request.TLS != nil {
            c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
        }

        // CSP (å†…å®¹å®‰å…¨ç­–ç•¥)
        csp := "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self'"
        c.Header("Content-Security-Policy", csp)

        // æƒé™ç­–ç•¥ (æ›¿ä»£Feature-Policy)
        permissionsPolicy := "geolocation=(), microphone=(), camera=(), payment=(), usb=(), magnetometer=(), gyroscope=()"
        c.Header("Permissions-Policy", permissionsPolicy)

        c.Next()
    }
}

// CSRFProtection CSRFä¿æŠ¤
func CSRFProtection(secret string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // åªå¯¹çŠ¶æ€æ”¹å˜è¯·æ±‚è¿›è¡ŒCSRFæ£€æŸ¥
        if !isStateChangingRequest(c.Request.Method) {
            c.Next()
            return
        }

        token := c.GetHeader("X-CSRF-Token")
        if token == "" {
            token = c.PostForm("_csrf_token")
        }

        if token == "" {
            c.JSON(403, gin.H{"error": "CSRF token missing"})
            c.Abort()
            return
        }

        // éªŒè¯CSRF token
        if !validateCSRFToken(token, secret, c.ClientIP()) {
            c.JSON(403, gin.H{"error": "Invalid CSRF token"})
            c.Abort()
            return
        }

        c.Next()
    }
}

// RateLimitByUser åŸºäºç”¨æˆ·çš„æ™ºèƒ½é™æµ
func RateLimitByUser(userLimiter map[string]*RateLimiter, defaultRate int) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, exists := c.Get("user_id")
        if !exists {
            c.JSON(401, gin.H{"error": "User not authenticated"})
            c.Abort()
            return
        }

        userKey := fmt.Sprintf("user_%v", userID)

        // è·å–æˆ–åˆ›å»ºç”¨æˆ·é™æµå™¨
        limiter, exists := userLimiter[userKey]
        if !exists {
            // æ ¹æ®ç”¨æˆ·è§’è‰²è®¾ç½®ä¸åŒé™æµç­–ç•¥
            role, _ := c.Get("role")
            rate := defaultRate

            switch role {
            case "admin":
                rate = defaultRate * 5 // ç®¡ç†å‘˜æ›´é«˜é™åˆ¶
            case "premium":
                rate = defaultRate * 2 // ä»˜è´¹ç”¨æˆ·æ›´é«˜é™åˆ¶
            case "vip":
                rate = defaultRate * 3 // VIPç”¨æˆ·æ›´é«˜é™åˆ¶
            }

            limiter = NewRateLimiter(rate, rate*2)
            userLimiter[userKey] = limiter
        }

        if !limiter.Allow() {
            c.JSON(429, gin.H{
                "error": "Rate limit exceeded",
                "retry_after": 1,
                "limit_type": "user_based",
            })
            c.Abort()
            return
        }

        c.Next()
    }
}

// InputValidation è¾“å…¥éªŒè¯ä¸­é—´ä»¶
func InputValidation() gin.HandlerFunc {
    return func(c *gin.Context) {
        // æ£€æŸ¥è¯·æ±‚å¤§å°
        if c.Request.ContentLength > 10*1024*1024 { // 10MBé™åˆ¶
            c.JSON(413, gin.H{"error": "Request too large"})
            c.Abort()
            return
        }

        // æ£€æŸ¥Content-Type
        if c.Request.Method == "POST" || c.Request.Method == "PUT" || c.Request.Method == "PATCH" {
            contentType := c.GetHeader("Content-Type")
            if !strings.Contains(contentType, "application/json") &&
               !strings.Contains(contentType, "multipart/form-data") &&
               !strings.Contains(contentType, "application/x-www-form-urlencoded") {
                c.JSON(415, gin.H{"error": "Unsupported media type"})
                c.Abort()
                return
            }
        }

        c.Next()
    }
}

// AdvancedAuth é«˜çº§è®¤è¯ä¸­é—´ä»¶
func AdvancedAuth(authConfig AuthConfig) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(401, gin.H{"error": "Authorization header required"})
            c.Abort()
            return
        }

        // æ”¯æŒå¤šç§è®¤è¯æ–¹å¼
        if strings.HasPrefix(authHeader, "Bearer ") {
            // JWTè®¤è¯
            if !handleJWTAuth(strings.TrimPrefix(authHeader, "Bearer "), authConfig.JWTSecret) {
                c.JSON(401, gin.H{"error": "Invalid JWT token"})
                c.Abort()
                return
            }
        } else if strings.HasPrefix(authHeader, "Basic ") {
            // Basicè®¤è¯
            if !handleBasicAuth(strings.TrimPrefix(authHeader, "Basic "), authConfig.Users) {
                c.JSON(401, gin.H{"error": "Invalid credentials"})
                c.Abort()
                return
            }
        } else if strings.HasPrefix(authHeader, "ApiKey ") {
            // API Keyè®¤è¯
            if !handleAPIKeyAuth(strings.TrimPrefix(authHeader, "ApiKey "), authConfig.APIKeys) {
                c.JSON(401, gin.H{"error": "Invalid API key"})
                c.Abort()
                return
            }
        } else {
            c.JSON(401, gin.H{"error": "Unsupported authentication method"})
            c.Abort()
            return
        }

        c.Next()
    }
}

// TwoFactorAuth åŒå› ç´ è®¤è¯ä¸­é—´ä»¶
func TwoFactorAuth(secretStore SecretStore) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, exists := c.Get("user_id")
        if !exists {
            c.JSON(401, gin.H{"error": "User not authenticated"})
            c.Abort()
            return
        }

        // æ£€æŸ¥æ˜¯å¦éœ€è¦2FA
        requires2FA, err := secretStore.Requires2FA(userID.(uint))
        if err != nil {
            c.JSON(500, gin.H{"error": "Failed to check 2FA requirement"})
            c.Abort()
            return
        }

        if !requires2FA {
            c.Next()
            return
        }

        // éªŒè¯2FA token
        twoFactorToken := c.GetHeader("X-2FA-Token")
        if twoFactorToken == "" {
            c.JSON(401, gin.H{"error": "2FA token required"})
            c.Abort()
            return
        }

        secret, err := secretStore.Get2FASecret(userID.(uint))
        if err != nil {
            c.JSON(500, gin.H{"error": "Failed to get 2FA secret"})
            c.Abort()
            return
        }

        if !totp.Validate(twoFactorToken, secret) {
            c.JSON(401, gin.H{"error": "Invalid 2FA token"})
            c.Abort()
            return
        }

        c.Next()
    }
}
```

### ç›‘æ§å’Œå¯è§‚æµ‹æ€§

#### å®Œæ•´çš„ç›‘æ§ä½“ç³»
```go
package monitoring

import (
    "context"
    "fmt"
    "net/http"
    "runtime"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporter/jaeger"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
    "go.opentelemetry.io/otel/trace"
)

var (
    // HTTPè¯·æ±‚æŒ‡æ ‡
    httpRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status_code", "user_agent"},
    )

    httpRequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "HTTP request duration in seconds",
            Buckets: []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10},
        },
        []string{"method", "endpoint", "status_code"},
    )

    httpRequestSize = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_size_bytes",
            Help:    "HTTP request size in bytes",
            Buckets: prometheus.ExponentialBuckets(100, 2, 10),
        },
        []string{"method", "endpoint"},
    )

    httpResponseSize = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_response_size_bytes",
            Help:    "HTTP response size in bytes",
            Buckets: prometheus.ExponentialBuckets(100, 2, 10),
        },
        []string{"method", "endpoint", "status_code"},
    )

    // åº”ç”¨æŒ‡æ ‡
    activeConnections = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "app_active_connections",
            Help: "Current number of active connections",
        },
    )

    goRoutines = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "app_goroutines",
            Help: "Current number of goroutines",
        },
    )

    memoryUsage = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "app_memory_usage_bytes",
            Help: "Memory usage in bytes",
        },
        []string{"type"},
    )

    // æ•°æ®åº“æŒ‡æ ‡
    dbConnectionsActive = promauto.NewGauge(
        prometheus.GaugeOpts{
            Name: "db_connections_active",
            Help: "Number of active database connections",
        },
    )

    dbQueryDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "db_query_duration_seconds",
            Help:    "Database query duration in seconds",
            Buckets: []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5},
        },
        []string{"operation", "table"},
    )

    dbQueryTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "db_queries_total",
            Help: "Total number of database queries",
        },
        []string{"operation", "table", "status"},
    )
)

// MonitoringService ç›‘æ§æœåŠ¡
type MonitoringService struct {
    registry *prometheus.Registry
    tracer   trace.Tracer
    logger   *logrus.Logger
}

func NewMonitoringService(logger *logrus.Logger) (*MonitoringService, error) {
    // åˆå§‹åŒ–Prometheusæ³¨å†Œå™¨
    registry := prometheus.NewRegistry()

    // æ³¨å†ŒGoè¿›ç¨‹æŒ‡æ ‡
    if err := registry.Register(prometheus.NewGoCollector()); err != nil {
        return nil, fmt.Errorf("failed to register Go collector: %w", err)
    }

    // æ³¨å†Œè¿›ç¨‹æŒ‡æ ‡
    if err := registry.Register(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{})); err != nil {
        return nil, fmt.Errorf("failed to register process collector: %w", err)
    }

    // åˆå§‹åŒ–OpenTelemetry
    tracerProvider, err := initTracerProvider()
    if err != nil {
        return nil, fmt.Errorf("failed to initialize tracer provider: %w", err)
    }

    return &MonitoringService{
        registry: registry,
        tracer:   tracerProvider.Tracer("gin-app"),
        logger:   logger,
    }, nil
}

// initTracerProvider åˆå§‹åŒ–è¿½è¸ªæä¾›è€…
func initTracerProvider() (*trace.TracerProvider, error) {
    // åˆ›å»ºJaegerå¯¼å‡ºå™¨
    exporter, err := jaeger.New(jaeger.WithCollectorEndpoint())
    if err != nil {
        return nil, fmt.Errorf("failed to create Jaeger exporter: %w", err)
    }

    // åˆ›å»ºèµ„æº
    res, err := resource.New(context.Background(),
        resource.WithAttributes(
            semconv.ServiceNameKey.String("gin-app"),
            semconv.ServiceVersionKey.String("1.0.0"),
        ),
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create resource: %w", err)
    }

    // åˆ›å»ºè¿½è¸ªæä¾›è€…
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
        trace.WithResource(res),
    )

    // è®¾ç½®ä¸ºå…¨å±€é»˜è®¤è¿½è¸ªæä¾›è€…
    otel.SetTracerProvider(tp)

    return tp, nil
}

// MetricsMiddleware PrometheusæŒ‡æ ‡æ”¶é›†ä¸­é—´ä»¶
func (ms *MonitoringService) MetricsMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()

        // è·å–è¯·æ±‚ä¿¡æ¯
        method := c.Request.Method
        path := c.FullPath()
        if path == "" {
            path = c.Request.URL.Path
        }

        userAgent := c.Request.UserAgent()
        if userAgent == "" {
            userAgent = "unknown"
        }

        // å¢åŠ æ´»è·ƒè¿æ¥æ•°
        activeConnections.Inc()

        // è®°å½•è¯·æ±‚å¤§å°
        if c.Request.ContentLength > 0 {
            httpRequestSize.WithLabelValues(method, path).Observe(float64(c.Request.ContentLength))
        }

        c.Next()

        // å‡å°‘æ´»è·ƒè¿æ¥æ•°
        activeConnections.Dec()

        // è®°å½•æŒ‡æ ‡
        duration := time.Since(start)
        statusCode := fmt.Sprintf("%d", c.Writer.Status())

        httpRequestsTotal.WithLabelValues(method, path, statusCode, userAgent).Inc()
        httpRequestDuration.WithLabelValues(method, path, statusCode).Observe(duration.Seconds())

        // è®°å½•å“åº”å¤§å°
        if c.Writer.Size() > 0 {
            httpResponseSize.WithLabelValues(method, path, statusCode).Observe(float64(c.Writer.Size()))
        }

        // è®°å½•åº”ç”¨æŒ‡æ ‡
        ms.recordApplicationMetrics()
    }
}

// recordApplicationMetrics è®°å½•åº”ç”¨æŒ‡æ ‡
func (ms *MonitoringService) recordApplicationMetrics() {
    // è®°å½•goroutineæ•°é‡
    goRoutines.Set(float64(runtime.NumGoroutine()))

    // è®°å½•å†…å­˜ä½¿ç”¨
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    memoryUsage.WithLabelValues("heap").Set(float64(m.HeapAlloc))
    memoryUsage.WithLabelValues("stack").Set(float64(m.StackInuse))
    memoryUsage.WithLabelValues("gc").Set(float64(m.GCSys))
}

// TracingMiddleware é“¾è·¯è¿½è¸ªä¸­é—´ä»¶
func (ms *MonitoringService) TracingMiddleware(serviceName string) gin.HandlerFunc {
    return otelgin.Middleware(serviceName)
}

// SetupMetricsRoutes è®¾ç½®æŒ‡æ ‡è·¯ç”±
func (ms *MonitoringService) SetupMetricsRoutes(router *gin.Engine) {
    // PrometheusæŒ‡æ ‡ç«¯ç‚¹
    router.GET("/metrics", gin.WrapH(promhttp.HandlerFor(ms.registry, promhttp.HandlerOpts{})))

    // å¥åº·æ£€æŸ¥ç«¯ç‚¹
    router.GET("/health", ms.healthCheck)

    // æŒ‡æ ‡æ¦‚è§ˆç«¯ç‚¹
    router.GET("/metrics/overview", ms.metricsOverview)
}

// healthCheck å¥åº·æ£€æŸ¥
func (ms *MonitoringService) healthCheck(c *gin.Context) {
    // æ£€æŸ¥å„ç§æŒ‡æ ‡
    health := gin.H{
        "status": "healthy",
        "timestamp": time.Now().Unix(),
        "version": "1.0.0",
    }

    // æ£€æŸ¥å†…å­˜ä½¿ç”¨
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    memoryMB := float64(m.Alloc) / 1024 / 1024
    if memoryMB > 1000 { // å¦‚æœå†…å­˜ä½¿ç”¨è¶…è¿‡1GB
        health["status"] = "degraded"
        health["memory_warning"] = "High memory usage"
    }

    // æ£€æŸ¥goroutineæ•°é‡
    goroutineCount := runtime.NumGoroutine()
    if goroutineCount > 1000 { // å¦‚æœgoroutineæ•°é‡è¿‡å¤š
        health["status"] = "degraded"
        health["goroutine_warning"] = "High goroutine count"
    }

    statusCode := http.StatusOK
    if health["status"] != "healthy" {
        statusCode = http.StatusServiceUnavailable
    }

    c.JSON(statusCode, health)
}

// metricsOverview æŒ‡æ ‡æ¦‚è§ˆ
func (ms *MonitoringService) metricsOverview(c *gin.Context) {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    overview := gin.H{
        "runtime": gin.H{
            "goroutines": runtime.NumGoroutine(),
            "memory": gin.H{
                "alloc_mb":      float64(m.Alloc) / 1024 / 1024,
                "total_alloc_mb": float64(m.TotalAlloc) / 1024 / 1024,
                "sys_mb":        float64(m.Sys) / 1024 / 1024,
                "num_gc":        m.NumGC,
            },
        },
        "http": gin.H{
            "active_connections": activeConnections.Get(),
        },
        "timestamp": time.Now().Unix(),
    }

    c.JSON(http.StatusOK, overview)
}
```

---

## â“ å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### Q1: å¦‚ä½•å¤„ç†å¤§æ–‡ä»¶ä¸Šä¼ çš„å†…å­˜ä¼˜åŒ–ï¼Ÿ
**A**: ä½¿ç”¨æµå¼å¤„ç†å’Œåˆ†å—ä¸Šä¼ æŠ€æœ¯ï¼š

```go
func HandleLargeFileUpload(c *gin.Context) {
    // é™åˆ¶æ–‡ä»¶å¤§å° (100MB)
    c.Request.ParseMultipartForm(100 << 20)

    file, header, err := c.Request.FormFile("file")
    if err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    defer file.Close()

    // ä½¿ç”¨æµå¼å¤„ç†ï¼Œé¿å…ä¸€æ¬¡æ€§è¯»å–åˆ°å†…å­˜
    const chunkSize = 32 * 1024 // 32KB chunks
    buffer := make([]byte, chunkSize)

    uploadedSize := int64(0)
    for {
        bytesRead, err := file.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            c.JSON(500, gin.H{"error": "Failed to read file"})
            return
        }

        uploadedSize += int64(bytesRead)

        // å¤„ç†æ¯ä¸ªchunkï¼ˆä¾‹å¦‚å†™å…¥ç£ç›˜æˆ–äº‘å­˜å‚¨ï¼‰
        if err := processChunk(buffer[:bytesRead]); err != nil {
            c.JSON(500, gin.H{"error": "Failed to process file chunk"})
            return
        }
    }

    c.JSON(200, gin.H{
        "filename": header.Filename,
        "size":     uploadedSize,
        "status":   "uploaded successfully",
    })
}
```

### Q2: å¦‚ä½•ä¼˜åŒ–é«˜å¹¶å‘åœºæ™¯ä¸‹çš„JSONåºåˆ—åŒ–æ€§èƒ½ï¼Ÿ
**A**: ä½¿ç”¨å¯¹è±¡æ± ã€é¢„åˆ†é…ç¼“å†²åŒºå’Œé«˜æ•ˆçš„JSONåº“ï¼š

```go
var (
    jsonPool = sync.Pool{
        New: func() interface{} {
            return &bytes.Buffer{}
        },
    }

    encoderPool = sync.Pool{
        New: func() interface{} {
            return json.NewEncoder(nil)
        },
    }
)

func FastJSONResponse(c *gin.Context, data interface{}) {
    // ä»æ± ä¸­è·å–ç¼“å†²åŒº
    buf := jsonPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset()
        jsonPool.Put(buf)
    }()

    // ä»æ± ä¸­è·å–ç¼–ç å™¨
    encoder := encoderPool.Get().(*json.Encoder)
    defer encoderPool.Put(encoder)

    encoder.Reset(buf)

    // ç¼–ç JSON
    if err := encoder.Encode(data); err != nil {
        c.JSON(500, gin.H{"error": "JSON encoding failed"})
        return
    }

    // è®¾ç½®æ­£ç¡®çš„Content-Typeå¹¶è¿”å›
    c.Data(200, "application/json; charset=utf-8", buf.Bytes())
}
```

### Q3: å¦‚ä½•å®ç°ä¼˜é›…çš„æœåŠ¡å…³é—­å’Œèµ„æºæ¸…ç†ï¼Ÿ
**A**: ä½¿ç”¨contextã€ä¿¡å·å¤„ç†å’Œèµ„æºæ¸…ç†æ¨¡å¼ï¼š

```go
func main() {
    // åˆ›å»ºåº”ç”¨
    app, err := NewApplication(config.Load())
    if err != nil {
        log.Fatal("Failed to create application:", err)
    }

    // åˆ›å»ºå¸¦è¶…æ—¶çš„contextç”¨äºå…³é—­
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    // è®¾ç½®è·¯ç”±
    router := app.SetupRouter()

    // åˆ›å»ºHTTPæœåŠ¡å™¨
    server := &http.Server{
        Addr:         ":8080",
        Handler:      router,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }

    // å¯åŠ¨æœåŠ¡å™¨
    go func() {
        log.Printf("Server starting on %s", server.Addr)
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Printf("Server failed to start: %v", err)
        }
    }()

    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    log.Println("Shutting down server...")

    // ä¼˜é›…å…³é—­HTTPæœåŠ¡å™¨
    shutdownErr := make(chan error, 1)
    go func() {
        shutdownErr <- server.Shutdown(ctx)
    }()

    // å…³é—­åº”ç”¨èµ„æº
    if err := app.Shutdown(ctx); err != nil {
        log.Printf("Application shutdown error: %v", err)
    }

    // ç­‰å¾…æœåŠ¡å™¨å…³é—­å®Œæˆ
    if err := <-shutdownErr; err != nil {
        log.Printf("Server shutdown error: %v", err)
    }

    log.Println("Server gracefully stopped")
}

// Shutdown ä¼˜é›…å…³é—­åº”ç”¨
func (app *Application) Shutdown(ctx context.Context) error {
    var wg sync.WaitGroup
    errors := make(chan error, 10)

    // å…³é—­æ•°æ®åº“è¿æ¥
    wg.Add(1)
    go func() {
        defer wg.Done()
        if sqlDB, err := app.DB.DB(); err == nil {
            if err := sqlDB.Close(); err != nil {
                errors <- fmt.Errorf("database close error: %w", err)
            }
        }
    }()

    // å…³é—­Redisè¿æ¥
    wg.Add(1)
    go func() {
        defer wg.Done()
        if err := app.Redis.Close(); err != nil {
            errors <- fmt.Errorf("redis close error: %w", err)
        }
    }()

    // å…³é—­gRPCè¿æ¥æ± 
    wg.Add(1)
    go func() {
        defer wg.Done()
        if err := app.Container.GrpcPool.Close(); err != nil {
            errors <- fmt.Errorf("grpc pool close error: %w", err)
        }
    }()

    // ç­‰å¾…æ‰€æœ‰å…³é—­æ“ä½œå®Œæˆ
    done := make(chan struct{})
    go func() {
        wg.Wait()
        close(done)
    }()

    select {
    case <-done:
        return nil
    case err := <-errors:
        return err
    case <-ctx.Done():
        return ctx.Err()
    }
}
```

---

## ğŸ¯ ç»ƒä¹ ä¸å®è·µ

### ç»ƒä¹ 1: é«˜çº§ä¸­é—´ä»¶å¼€å‘
**ç›®æ ‡**: å®ç°ä¸€ä¸ªå®Œæ•´çš„CORSä¸­é—´ä»¶ï¼Œæ”¯æŒåŠ¨æ€é…ç½®å’Œé¢„æ£€è¯·æ±‚ç¼“å­˜

**ä»»åŠ¡è¦æ±‚**:
1. æ”¯æŒå¤šç§CORSç­–ç•¥ï¼ˆå®½æ¾ã€ä¸¥æ ¼ã€è‡ªå®šä¹‰ï¼‰
2. åŠ¨æ€é…ç½®å…è®¸çš„åŸŸåã€æ–¹æ³•å’Œå¤´
3. é¢„æ£€è¯·æ±‚å¤„ç†å’Œç¼“å­˜
4. æ€§èƒ½ä¼˜åŒ–ï¼ˆé…ç½®ç¼“å­˜ã€è§„åˆ™åŒ¹é…ä¼˜åŒ–ï¼‰

### ç»ƒä¹ 2: æ€§èƒ½ä¼˜åŒ–å®æˆ˜
**ç›®æ ‡**: ä¼˜åŒ–ä¸€ä¸ªé«˜å¹¶å‘APIçš„ç»¼åˆæ€§èƒ½

**æŒ‘æˆ˜ä»»åŠ¡**:
- ä½¿ç”¨pprofåˆ†ææ€§èƒ½ç“¶é¢ˆ
- å®ç°å¯¹è±¡æ± ä¼˜åŒ–å†…å­˜åˆ†é…
- æ·»åŠ æ™ºèƒ½ç¼“å­˜å±‚
- ä½¿ç”¨Benchmarkæµ‹è¯•éªŒè¯ä¼˜åŒ–æ•ˆæœ
- å®ç°è¿æ¥æ± å’Œå¹¶å‘æ§åˆ¶

### ç»ƒä¹ 3: ä¼ä¸šçº§é¡¹ç›®æ¶æ„
**ç›®æ ‡**: è®¾è®¡å¹¶å®ç°ä¸€ä¸ªå®Œæ•´çš„ç”µå•†åç«¯APIç³»ç»Ÿ

**è¦æ±‚**:
- ç”¨æˆ·è®¤è¯å’Œæˆæƒç³»ç»Ÿï¼ˆJWT + 2FAï¼‰
- å•†å“ç®¡ç†å’Œæœç´¢åŠŸèƒ½
- è®¢å•å¤„ç†å’Œæ”¯ä»˜é›†æˆ
- åº“å­˜ç®¡ç†å’Œå¹¶å‘æ§åˆ¶
- å®Œæ•´çš„ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ
- ä¼˜é›…çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

---

## ğŸ“Š æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹å›é¡¾
1. **ä¸­é—´ä»¶æ˜¯Ginçš„æ ¸å¿ƒ**: æŒæ¡ä¸­é—´ä»¶å¼€å‘æ˜¯ç²¾é€šGinçš„å…³é”®ï¼ŒåŒ…æ‹¬è®¤è¯ã€æ—¥å¿—ã€é™æµã€CORSç­‰
2. **æ€§èƒ½ä¼˜åŒ–è‡³å…³é‡è¦**: å¯¹è±¡æ± ã€å†…å­˜ç®¡ç†ã€å¹¶å‘ä¼˜åŒ–æ˜¯ç”Ÿäº§ç¯å¢ƒçš„å¿…å¤‡æŠ€èƒ½
3. **æºç ç†è§£åŠ æ·±åº”ç”¨**: äº†è§£Radix Treeè·¯ç”±ç®—æ³•å’ŒContextæœºåˆ¶æœ‰åŠ©äºæ›´å¥½çš„é—®é¢˜æ’æŸ¥
4. **ä¼ä¸šçº§ç‰¹æ€§**: å®‰å…¨ã€ç›‘æ§ã€ä¼˜é›…å…³é—­ã€é”™è¯¯å¤„ç†æ˜¯ç”Ÿäº§ç¯å¢ƒçš„å¿…éœ€å“
5. **å¾®æœåŠ¡é›†æˆ**: æœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡ã€é“¾è·¯è¿½è¸ªæ˜¯ç°ä»£æ¶æ„çš„é‡è¦ç»„ä»¶

### å­¦ä¹ æˆæœæ£€æŸ¥
- [ ] æ˜¯å¦èƒ½å¤Ÿå¼€å‘å¤æ‚çš„è‡ªå®šä¹‰ä¸­é—´ä»¶ï¼Ÿ
- [ ] æ˜¯å¦èƒ½å¤Ÿè¿›è¡ŒGinåº”ç”¨çš„æ€§èƒ½åˆ†æå’Œä¼˜åŒ–ï¼Ÿ
- [ ] æ˜¯å¦ç†è§£Ginçš„è·¯ç”±ç®—æ³•å’Œä¸­é—´ä»¶æœºåˆ¶ï¼Ÿ
- [ ] æ˜¯å¦å…·å¤‡è®¾è®¡å’Œå®ç°ä¼ä¸šçº§Go Webåº”ç”¨çš„èƒ½åŠ›ï¼Ÿ
- [ ] æ˜¯å¦æŒæ¡å¾®æœåŠ¡æ¶æ„ä¸­çš„æœåŠ¡é›†æˆæŠ€æœ¯ï¼Ÿ

### è¿›é˜¶æ–¹å‘
- **æ·±å…¥å­¦ä¹ **: ç ”ç©¶Ginçš„æºç å®ç°å’Œè®¾è®¡æ¨¡å¼
- **æ€§èƒ½ä¸“å®¶**: æˆä¸ºGo Webåº”ç”¨æ€§èƒ½è°ƒä¼˜ä¸“å®¶
- **æ¶æ„å¸ˆ**: è®¾è®¡å¤§è§„æ¨¡åˆ†å¸ƒå¼Webç³»ç»Ÿ
- **å¼€æºè´¡çŒ®**: å‚ä¸Ginæˆ–ç›¸å…³å¼€æºé¡¹ç›®çš„è´¡çŒ®

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ
**ç‰ˆæœ¬**: v1.0.0

---

> ğŸ’¡ **å­¦ä¹ å»ºè®®**:
> - å®è·µæ¯ä¸ªä»£ç ç¤ºä¾‹ï¼Œç†è§£å…¶å·¥ä½œåŸç†å’Œæœ€ä½³å®è·µ
> - ä½¿ç”¨pprofå’Œbenchmarkå·¥å…·åˆ†æè‡ªå·±é¡¹ç›®çš„æ€§èƒ½
> - å°è¯•å¼€å‘è‡ªå·±çš„ä¸­é—´ä»¶åº“å¹¶å¼€æºåˆ†äº«
> - å…³æ³¨Ginæ¡†æ¶çš„æ›´æ–°å’Œç¤¾åŒºåŠ¨æ€
> - å­¦ä¹ ç›¸å…³çš„ç”Ÿæ€ç³»ç»Ÿï¼Œå¦‚gRPCã€WebSocketã€GraphQLç­‰
>
> ğŸ¯ **ä¸‹ä¸€æ­¥**: ç»§ç»­å­¦ä¹  [GORMå®Œæ•´å­¦ä¹ ](03-gorm-orm-complete.md)ï¼ŒæŒæ¡Goçš„æ•°æ®æŒä¹…åŒ–æŠ€æœ¯