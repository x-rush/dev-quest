# Goç¼–ç¨‹ç²¾å - ä¼ä¸šçº§å¼€å‘æ ¸å¿ƒæŠ€å·§

> **æ–‡æ¡£ç®€ä»‹**: æ·±å…¥Goè¯­è¨€ç¼–ç¨‹çš„æ ¸å¿ƒæŠ€å·§å’Œæœ€ä½³å®è·µï¼Œä»ä»£ç ç»„ç»‡åˆ°æ€§èƒ½ä¼˜åŒ–ï¼Œå¸®åŠ©ä½ ç¼–å†™é«˜è´¨é‡ã€å¯ç»´æŠ¤çš„Goä»£ç 

> **ç›®æ ‡è¯»è€…**: æœ‰Goè¯­è¨€åŸºç¡€ï¼Œå¸Œæœ›æŒæ¡ä¼ä¸šçº§å¼€å‘æŠ€å·§çš„ä¸­é«˜çº§å¼€å‘è€…

> **å‰ç½®çŸ¥è¯†**: GoåŸºç¡€è¯­æ³•ã€æ•°æ®ç±»å‹ã€æ§åˆ¶æµç¨‹ã€å‡½æ•°å®šä¹‰

> **é¢„è®¡æ—¶é•¿**: 6-8å°æ—¶ï¼ˆåŒ…å«å®è·µç»ƒä¹ ï¼‰

## ğŸ“š æ–‡æ¡£å…ƒæ•°æ®

| å±æ€§ | å†…å®¹ |
|------|------|
| **æ¨¡å—** | `01-go-backend` |
| **åˆ†ç±»** | `language-concepts/core-programming` |
| **éš¾åº¦** | â­â­â­â­ |
| **æ ‡ç­¾** | `#goç¼–ç¨‹` `#æœ€ä½³å®è·µ` `#ä»£ç è´¨é‡` `#æ€§èƒ½ä¼˜åŒ–` |
| **æ›´æ–°æ—¥æœŸ** | `2025å¹´10æœˆ` |
| **ä½œè€…** | Dev Quest Team |
| **çŠ¶æ€** | âœ… å·²å®Œæˆ |

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ¨¡å—åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… **æŒæ¡Goè¯­è¨€å“²å­¦**: ç†è§£Goçš„è®¾è®¡å“²å­¦å’Œç¼–ç¨‹èŒƒå¼
- âœ… **ç¼–å†™é«˜è´¨é‡ä»£ç **: éµå¾ªGoçš„ç¼–ç è§„èŒƒå’Œæœ€ä½³å®è·µ
- âœ… **ä¼˜åŒ–ç¨‹åºæ€§èƒ½**: æŒæ¡æ€§èƒ½è°ƒä¼˜å’Œå†…å­˜ç®¡ç†æŠ€å·§
- âœ… **è®¾è®¡ä¼˜é›…æ¶æ„**: å­¦ä¼šå¯æ‰©å±•ã€å¯ç»´æŠ¤çš„ä»£ç ç»„ç»‡
- âœ… **å¤„ç†å¤æ‚åœºæ™¯**: æŒæ¡é”™è¯¯å¤„ç†ã€å¹¶å‘ç¼–ç¨‹ç­‰é«˜çº§æŠ€å·§

## ğŸ“‹ ç›®å½•

- [Goè¯­è¨€è®¾è®¡å“²å­¦](#goè¯­è¨€è®¾è®¡å“²å­¦)
- [ä»£ç ç»„ç»‡ä¸è§„èŒƒ](#ä»£ç ç»„ç»‡ä¸è§„èŒƒ)
- [æ¥å£è®¾è®¡ä¸æŠ½è±¡](#æ¥å£è®¾è®¡ä¸æŠ½è±¡)
- [é”™è¯¯å¤„ç†æœ€ä½³å®è·µ](#é”™è¯¯å¤„ç†æœ€ä½³å®è·µ)
- [å¹¶å‘ç¼–ç¨‹æ¨¡å¼](#å¹¶å‘ç¼–ç¨‹æ¨¡å¼)
- [æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#æ€§èƒ½ä¼˜åŒ–æŠ€å·§)
- [å†…å­˜ç®¡ç†ç­–ç•¥](#å†…å­˜ç®¡ç†ç­–ç•¥)
- [æµ‹è¯•ä¸è´¨é‡ä¿è¯](#æµ‹è¯•ä¸è´¨é‡ä¿è¯)
- [åŒ…ç®¡ç†ä¸ä¾èµ–](#åŒ…ç®¡ç†ä¸ä¾èµ–)
- [å·¥å…·é“¾ä¸å·¥ç¨‹åŒ–](#å·¥å…·é“¾ä¸å·¥ç¨‹åŒ–)

---

## ğŸ§  Goè¯­è¨€è®¾è®¡å“²å­¦

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

#### 1. ç®€æ´æ€§ (Simplicity)
```go
// âŒ è¿‡åº¦å¤æ‚çš„å®ç°
func ProcessUsers(users []User) map[string]interface{} {
    result := make(map[string]interface{})
    for i, user := range users {
        if user != nil {
            if user.ID > 0 {
                if user.Name != "" {
                    result[fmt.Sprintf("user_%d", i)] = map[string]interface{}{
                        "id":   user.ID,
                        "name": user.Name,
                        "meta": map[string]interface{}{
                            "created_at": user.CreatedAt,
                            "updated_at": user.UpdatedAt,
                            "status":     user.Status,
                        },
                    }
                }
            }
        }
    }
    return result
}

// âœ… ç®€æ´æ˜äº†çš„å®ç°
func ProcessUsers(users []User) map[int]User {
    result := make(map[int]User)
    for _, user := range users {
        if user.IsValid() {
            result[user.ID] = user
        }
    }
    return result
}

func (u *User) IsValid() bool {
    return u != nil && u.ID > 0 && u.Name != ""
}
```

#### 2. å¯è¯»æ€§ (Readability)
```go
// âŒ éš¾ä»¥ç†è§£çš„ä»£ç 
func calc(d []float64) (float64, float64) {
    var s, c float64
    for _, v := range d {
        s += v
        c++
    }
    return s / c, s / float64(c) * s / float64(c)
}

// âœ… è‡ªæ–‡æ¡£åŒ–çš„ä»£ç 
func CalculateMeanAndVariance(data []float64) (mean, variance float64) {
    if len(data) == 0 {
        return 0, 0
    }

    mean = calculateMean(data)
    variance = calculateVariance(data, mean)
    return mean, variance
}

func calculateMean(data []float64) float64 {
    sum := 0.0
    for _, value := range data {
        sum += value
    }
    return sum / float64(len(data))
}

func calculateVariance(data []float64, mean float64) float64 {
    sumOfSquares := 0.0
    for _, value := range data {
        diff := value - mean
        sumOfSquares += diff * diff
    }
    return sumOfSquares / float64(len(data))
}
```

#### 3. ç»„åˆä¼˜äºç»§æ‰¿ (Composition over Inheritance)
```go
// âŒ ä¼ ç»Ÿç»§æ‰¿æ€ç»´
type Animal struct {
    Name string
}

func (a *Animal) Speak() string {
    return "..."
}

type Dog struct {
    Animal // ç»§æ‰¿Animal
    Breed  string
}

func (d *Dog) Speak() string {
    return "Woof!"
}

// âœ… Goçš„ç»„åˆæ–¹å¼
type Speaker interface {
    Speak() string
}

type Named interface {
    GetName() string
}

type Animal struct {
    name string
}

func (a *Animal) GetName() string {
    return a.name
}

type Dog struct {
    name  string
    breed string
}

func (d *Dog) GetName() string {
    return d.name
}

func (d *Dog) Speak() string {
    return "Woof!"
}

// ç»„åˆä½¿ç”¨
type Pet struct {
    speaker Speaker
    named   Named
}

func (p *Pet) Introduce() string {
    return fmt.Sprintf("%s says %s", p.named.GetName(), p.speaker.Speak())
}
```

### Goè¯­è¨€çš„æƒè¡¡

#### æ˜¾å¼ä¼˜äºéšå¼
```go
// âŒ éšå¼çš„é­”æ³•
type UserRepository struct {
    // è‡ªåŠ¨æ³¨å…¥æ•°æ®åº“è¿æ¥
    db *Database
}

// âœ… æ˜¾å¼çš„ä¾èµ–æ³¨å…¥
type UserRepository struct {
    db Database
}

func NewUserRepository(db Database) *UserRepository {
    return &UserRepository{db: db}
}
```

#### é¢å‘æ¥å£ç¼–ç¨‹
```go
// å®šä¹‰å°è€Œä¸“æ³¨çš„æ¥å£
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

// ç»„åˆæ¥å£
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

---

## ğŸ“ ä»£ç ç»„ç»‡ä¸è§„èŒƒ

### é¡¹ç›®ç»“æ„æœ€ä½³å®è·µ

#### æ ‡å‡†é¡¹ç›®ç»“æ„
```
my-project/
â”œâ”€â”€ cmd/                    # åº”ç”¨ç¨‹åºå…¥å£ç‚¹
â”‚   â”œâ”€â”€ server/
â”‚   â”‚   â””â”€â”€ main.go
â”‚   â””â”€â”€ cli/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/               # ç§æœ‰åº”ç”¨ç¨‹åºä»£ç 
â”‚   â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ handlers/
â”œâ”€â”€ pkg/                    # å¯è¢«å¤–éƒ¨åº”ç”¨ç¨‹åºä½¿ç”¨çš„åº“ä»£ç 
â”‚   â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ utils/
â”‚   â””â”€â”€ middleware/
â”œâ”€â”€ api/                    # APIå®šä¹‰æ–‡ä»¶
â”‚   â””â”€â”€ openapi/
â”œâ”€â”€ web/                    # Webåº”ç”¨ç¨‹åºç‰¹å®šçš„ç»„ä»¶
â”‚   â”œâ”€â”€ static/
â”‚   â””â”€â”€ templates/
â”œâ”€â”€ build/                  # æ„å»ºå’Œæ‰“åŒ…è„šæœ¬
â”œâ”€â”€ deployments/            # IaaSã€PaaSã€ç³»ç»Ÿå’Œå®¹å™¨ç¼–æ’éƒ¨ç½²é…ç½®
â”œâ”€â”€ scripts/                # å„ç§å®ç”¨è„šæœ¬
â”œâ”€â”€ test/                   # é¢å¤–çš„å¤–éƒ¨æµ‹è¯•åº”ç”¨ç¨‹åºå’Œæµ‹è¯•æ•°æ®
â”œâ”€â”€ docs/                   # è®¾è®¡å’Œç”¨æˆ·æ–‡æ¡£
â”œâ”€â”€ tools/                  # æ­¤é¡¹ç›®çš„æ”¯æŒå·¥å…·
â”œâ”€â”€ examples/               # åº”ç”¨ç¨‹åºæˆ–å…¬å…±åº“çš„ç¤ºä¾‹
â”œâ”€â”€ third_party/            # å¤–éƒ¨è¾…åŠ©å·¥å…·ã€åˆ†å‰ä»£ç å’Œå…¶ä»–ç¬¬ä¸‰æ–¹å·¥å…·
â”œâ”€â”€ githooks/               # Gité’©å­
â”œâ”€â”€ assets/                 # ä¸å­˜å‚¨åº“ä¸€èµ·ä½¿ç”¨çš„å…¶ä»–èµ„äº§ï¼ˆå›¾åƒã€å¾½æ ‡ç­‰ï¼‰
â”œâ”€â”€ website/                # æ­¤é¡¹ç›®ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰çš„ç½‘ç«™
â””â”€â”€ go.mod                  # Goæ¨¡å—å®šä¹‰
```

#### åŒ…çš„å‘½åè§„èŒƒ
```go
// âœ… å¥½çš„åŒ…å - ç®€çŸ­ã€æ¸…æ™°ã€æè¿°æ€§
package user          // å¤„ç†ç”¨æˆ·ç›¸å…³åŠŸèƒ½
package auth          // è®¤è¯å’Œæˆæƒ
package cache         // ç¼“å­˜æ“ä½œ
package httpserver    // HTTPæœåŠ¡å™¨åŠŸèƒ½
package stringutils   // å­—ç¬¦ä¸²å·¥å…·å‡½æ•°

// âŒ é¿å…çš„åŒ…å
package util          // å¤ªé€šç”¨
package common        // å¤ªé€šç”¨
package data          // å¤ªé€šç”¨
package helper        // å¤ªé€šç”¨
package v1            // ç‰ˆæœ¬å·ä¸åº”è¯¥åœ¨åŒ…åä¸­

// åŒ…çº§åˆ«å¸¸é‡ - ä½¿ç”¨PascalCase
package user

const (
    DefaultPageSize = 20
    MaxLoginAttempts = 5
    SessionTimeout = 24 * time.Hour
)

// åŒ…çº§åˆ«å˜é‡ - ä½¿ç”¨CamelCase
var (
    ErrUserNotFound = errors.New("user not found")
    ErrInvalidPassword = errors.New("invalid password")
)
```

### å‡½æ•°è®¾è®¡åŸåˆ™

#### å•ä¸€èŒè´£åŸåˆ™
```go
// âŒ è¿åå•ä¸€èŒè´£
func ProcessUserRegistration(name, email, password string) error {
    // éªŒè¯è¾“å…¥
    if name == "" || email == "" || password == "" {
        return errors.New("invalid input")
    }
    if !isValidEmail(email) {
        return errors.New("invalid email")
    }
    if len(password) < 8 {
        return errors.New("password too short")
    }

    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    if userExists(email) {
        return errors.New("email already exists")
    }

    // å¯†ç åŠ å¯†
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return err
    }

    // åˆ›å»ºç”¨æˆ·
    user := &User{
        Name: name,
        Email: email,
        Password: string(hashedPassword),
        CreatedAt: time.Now(),
    }

    // ä¿å­˜åˆ°æ•°æ®åº“
    return saveUser(user)
}

// âœ… æ‹†åˆ†ä¸ºå¤šä¸ªå‡½æ•°
func ProcessUserRegistration(name, email, password string) error {
    if err := validateRegistrationInput(name, email, password); err != nil {
        return err
    }

    if err := checkEmailAvailability(email); err != nil {
        return err
    }

    hashedPassword, err := hashPassword(password)
    if err != nil {
        return err
    }

    user := createUser(name, email, hashedPassword)
    return saveUser(user)
}

func validateRegistrationInput(name, email, password string) error {
    if name == "" || email == "" || password == "" {
        return errors.New("invalid input")
    }
    if !isValidEmail(email) {
        return errors.New("invalid email")
    }
    if len(password) < 8 {
        return errors.New("password too short")
    }
    return nil
}

func checkEmailAvailability(email string) error {
    if userExists(email) {
        return errors.New("email already exists")
    }
    return nil
}

func hashPassword(password string) (string, error) {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return "", err
    }
    return string(hashedPassword), nil
}

func createUser(name, email, hashedPassword string) *User {
    return &User{
        Name:      name,
        Email:     email,
        Password:  hashedPassword,
        CreatedAt: time.Now(),
    }
}
```

#### å‡½æ•°ç­¾åè®¾è®¡
```go
// âœ… è‰¯å¥½çš„å‡½æ•°ç­¾åè®¾è®¡
type UserRepository interface {
    // è¿”å›å€¼åº”è¯¥æœ‰æ„ä¹‰ï¼Œé¿å…bool
    FindByID(id int) (*User, error)
    FindByEmail(email string) (*User, error)

    // ä½¿ç”¨context.Contextå¤„ç†è¶…æ—¶å’Œå–æ¶ˆ
    Create(ctx context.Context, user *User) error
    Update(ctx context.Context, user *User) error

    // æ”¯æŒåˆ†é¡µå’Œè¿‡æ»¤
    List(ctx context.Context, opts ListOptions) ([]*User, error)

    // æ‰¹é‡æ“ä½œ
    BatchCreate(ctx context.Context, users []*User) error
    Delete(ctx context.Context, ids []int) error
}

type ListOptions struct {
    Page     int
    PageSize int
    Filter   map[string]interface{}
    SortBy   string
    SortDesc bool
}

// âœ… é€‰é¡¹æ¨¡å¼ï¼ˆOptions Patternï¼‰
type Server struct {
    host     string
    port     int
    timeout  time.Duration
    tls      bool
    certFile string
    keyFile  string
}

type ServerOption func(*Server)

func WithHost(host string) ServerOption {
    return func(s *Server) {
        s.host = host
    }
}

func WithPort(port int) ServerOption {
    return func(s *Server) {
        s.port = port
    }
}

func WithTimeout(timeout time.Duration) ServerOption {
    return func(s *Server) {
        s.timeout = timeout
    }
}

func WithTLS(certFile, keyFile string) ServerOption {
    return func(s *Server) {
        s.tls = true
        s.certFile = certFile
        s.keyFile = keyFile
    }
}

func NewServer(opts ...ServerOption) *Server {
    server := &Server{
        host:    "localhost",
        port:    8080,
        timeout: 30 * time.Second,
    }

    for _, opt := range opts {
        opt(server)
    }

    return server
}

// ä½¿ç”¨æ–¹å¼
server := NewServer(
    WithHost("0.0.0.0"),
    WithPort(443),
    WithTimeout(60*time.Second),
    WithTLS("server.crt", "server.key"),
)
```

---

## ğŸ”Œ æ¥å£è®¾è®¡ä¸æŠ½è±¡

### æ¥å£è®¾è®¡åŸåˆ™

#### å°è€Œä¸“æ³¨çš„æ¥å£
```go
// âŒ å¤§è€Œå…¨çš„æ¥å£
type UserService interface {
    CreateUser(name, email, password string) error
    GetUser(id int) (*User, error)
    UpdateUser(id int, name, email string) error
    DeleteUser(id int) error
    ValidateUser(user *User) error
    HashPassword(password string) (string, error)
    CheckPassword(hash, password string) bool
    SendWelcomeEmail(user *User) error
    LoginUser(email, password string) (*Session, error)
    LogoutUser(sessionID string) error
}

// âœ… æ‹†åˆ†ä¸ºå°æ¥å£
type UserRepository interface {
    Create(ctx context.Context, user *User) error
    FindByID(ctx context.Context, id int) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id int) error
    FindByEmail(ctx context.Context, email string) (*User, error)
}

type UserValidator interface {
    Validate(user *User) error
}

type PasswordService interface {
    Hash(password string) (string, error)
    Verify(hash, password string) bool
}

type EmailService interface {
    SendWelcomeEmail(user *User) error
    SendPasswordResetEmail(user *User, token string) error
}

type AuthService interface {
    Login(ctx context.Context, email, password string) (*Session, error)
    Logout(ctx context.Context, sessionID string) error
    ValidateSession(ctx context.Context, sessionID string) (*User, error)
}

// ç»„åˆä½¿ç”¨
type UserService struct {
    repo            UserRepository
    validator       UserValidator
    passwordService PasswordService
    emailService    EmailService
    authService     AuthService
}
```

#### æ¥å£éš”ç¦»åŸåˆ™
```go
// âŒ å¼ºè¿«å®ç°ä¸éœ€è¦çš„æ–¹æ³•
type FileManager interface {
    ReadFile(path string) ([]byte, error)
    WriteFile(path string, data []byte) error
    DeleteFile(path string) error
    ListFiles(dir string) ([]string, error)
    CreateDir(path string) error
    DeleteDir(path string) error
    GetFileInfo(path string) (FileInfo, error)
}

// å¦‚æœåªéœ€è¦è¯»å–åŠŸèƒ½ï¼Œå´è¦å®ç°æ‰€æœ‰æ–¹æ³•
type ReadOnlyFileStorage struct {
    // å¿…é¡»å®ç°ä¸éœ€è¦çš„æ–¹æ³•
}

func (s *ReadOnlyFileStorage) ReadFile(path string) ([]byte, error) { /* å®ç° */ }
func (s *ReadOnlyFileStorage) WriteFile(path string, data []byte) error {
    return errors.New("operation not supported")
}
func (s *ReadOnlyFileStorage) DeleteFile(path string) error { /* ... */ }
// ...

// âœ… æ‹†åˆ†ä¸ºç»†ç²’åº¦æ¥å£
type Reader interface {
    Read(path string) ([]byte, error)
}

type Writer interface {
    Write(path string, data []byte) error
}

type Deleter interface {
    Delete(path string) error
}

type Lister interface {
    List(dir string) ([]string, error)
}

type DirCreator interface {
    CreateDir(path string) error
}

type DirDeleter interface {
    DeleteDir(path string) error
}

type InfoGetter interface {
    GetInfo(path string) (FileInfo, error)
}

// ç»„åˆæ¥å£
type ReadWriter interface {
    Reader
    Writer
}

type FileManager interface {
    Reader
    Writer
    Deleter
    Lister
    DirCreator
    DirDeleter
    InfoGetter
}

// ç°åœ¨å¯ä»¥åªå®ç°éœ€è¦çš„æ¥å£
type ReadOnlyFileStorage struct {
    storage Reader
}

func (s *ReadOnlyFileStorage) ReadFile(path string) ([]byte, error) {
    return s.storage.Read(path)
}
```

#### æ¥å£ç»„åˆ
```go
// åŸºç¡€æ¥å£
type Reader interface {
    Read(ctx context.Context, key string) ([]byte, error)
}

type Writer interface {
    Write(ctx context.Context, key string, value []byte) error
}

type Deleter interface {
    Delete(ctx context.Context, key string) error
}

// ç»„åˆæ¥å£
type ReadWriter interface {
    Reader
    Writer
}

type KeyValueStore interface {
    ReadWriter
    Deleter
}

// æ‰©å±•æ¥å£
type TTLReader interface {
    Reader
    GetWithTTL(ctx context.Context, key string) ([]byte, time.Duration, error)
}

type TTLWriter interface {
    Writer
    SetWithTTL(ctx context.Context, key string, value []byte, ttl time.Duration) error
}

type TTLKeyValueStore interface {
    TTLReader
    TTLWriter
    Deleter
}

// å®ç°
type RedisStore struct {
    client *redis.Client
}

func (r *RedisStore) Read(ctx context.Context, key string) ([]byte, error) {
    return r.client.Get(ctx, key).Bytes()
}

func (r *RedisStore) Write(ctx context.Context, key string, value []byte) error {
    return r.client.Set(ctx, key, value, 0).Err()
}

func (r *RedisStore) Delete(ctx context.Context, key string) error {
    return r.client.Del(ctx, key).Err()
}

func (r *RedisStore) GetWithTTL(ctx context.Context, key string) ([]byte, time.Duration, error) {
    cmd := r.client.Get(ctx, key)
    if cmd.Err() != nil {
        return nil, 0, cmd.Err()
    }

    ttl := r.client.TTL(ctx, key).Val()
    return cmd.Bytes(), ttl, nil
}

func (r *RedisStore) SetWithTTL(ctx context.Context, key string, value []byte, ttl time.Duration) error {
    return r.client.Set(ctx, key, value, ttl).Err()
}
```

### ä¾èµ–æ³¨å…¥æ¨¡å¼

#### æ„é€ å‡½æ•°æ³¨å…¥
```go
type UserService struct {
    userRepo       UserRepository
    authRepo       AuthRepository
    emailService   EmailService
    passwordHasher PasswordHasher
    logger         Logger
}

func NewUserService(
    userRepo UserRepository,
    authRepo AuthRepository,
    emailService EmailService,
    passwordHasher PasswordHasher,
    logger Logger,
) *UserService {
    return &UserService{
        userRepo:       userRepo,
        authRepo:       authRepo,
        emailService:   emailService,
        passwordHasher: passwordHasher,
        logger:         logger,
    }
}

func (s *UserService) RegisterUser(ctx context.Context, req *RegisterUserRequest) (*User, error) {
    s.logger.Info("å¼€å§‹æ³¨å†Œç”¨æˆ·", "email", req.Email)

    // ä¸šåŠ¡é€»è¾‘...

    s.logger.Info("ç”¨æˆ·æ³¨å†ŒæˆåŠŸ", "userID", user.ID)
    return user, nil
}
```

#### å·¥å‚æ¨¡å¼
```go
type DatabaseConfig struct {
    Host     string
    Port     int
    User     string
    Password string
    DBName   string
}

type DatabaseType int

const (
    MySQL DatabaseType = iota
    PostgreSQL
    SQLite
)

type DatabaseFactory interface {
    CreateRepository() UserRepository
    CreateConnection() (*sql.DB, error)
}

type MySQLDatabaseFactory struct {
    config DatabaseConfig
}

func (f *MySQLDatabaseFactory) CreateRepository() UserRepository {
    conn, _ := f.CreateConnection()
    return &MySQLUserRepository{db: conn}
}

func (f *MySQLDatabaseFactory) CreateConnection() (*sql.DB, error) {
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true",
        f.config.User, f.config.Password, f.config.Host, f.config.Port, f.config.DBName)
    return sql.Open("mysql", dsn)
}

type PostgreSQLDatabaseFactory struct {
    config DatabaseConfig
}

func (f *PostgreSQLDatabaseFactory) CreateRepository() UserRepository {
    conn, _ := f.CreateConnection()
    return &PostgreSQLUserRepository{db: conn}
}

func (f *PostgreSQLDatabaseFactory) CreateConnection() (*sql.DB, error) {
    dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
        f.config.Host, f.config.Port, f.config.User, f.config.Password, f.config.DBName)
    return sql.Open("postgres", dsn)
}

// å·¥å‚å‡½æ•°
func NewDatabaseFactory(dbType DatabaseType, config DatabaseConfig) DatabaseFactory {
    switch dbType {
    case MySQL:
        return &MySQLDatabaseFactory{config: config}
    case PostgreSQL:
        return &PostgreSQLDatabaseFactory{config: config}
    case SQLite:
        return &SQLiteDatabaseFactory{config: config}
    default:
        panic("unsupported database type")
    }
}

// ä½¿ç”¨
factory := NewDatabaseFactory(MySQL, dbConfig)
userRepo := factory.CreateRepository()
```

---

## âš ï¸ é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

### Goé”™è¯¯å¤„ç†å“²å­¦

#### æ˜¾å¼é”™è¯¯å¤„ç†
```go
// âŒ å¿½ç•¥é”™è¯¯
func GetUser(id int) *User {
    user, _ := userRepo.FindByID(id)
    return user
}

// âœ… å¤„ç†æ‰€æœ‰é”™è¯¯
func GetUser(id int) (*User, error) {
    user, err := userRepo.FindByID(id)
    if err != nil {
        return nil, fmt.Errorf("failed to find user %d: %w", id, err)
    }
    return user, nil
}

// âœ… ä½¿ç”¨åŒ…è£…é”™è¯¯æä¾›ä¸Šä¸‹æ–‡
func (s *UserService) CreateUser(req *CreateUserRequest) error {
    if err := s.validateRequest(req); err != nil {
        return fmt.Errorf("validation failed: %w", err)
    }

    user := &User{
        Name:  req.Name,
        Email: req.Email,
    }

    if err := s.repo.Create(user); err != nil {
        return fmt.Errorf("failed to create user: %w", err)
    }

    return nil
}
```

#### é”™è¯¯ç±»å‹è®¾è®¡
```go
// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type ValidationError struct {
    Field   string
    Message string
    Value   interface{}
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field '%s': %s", e.Field, e.Message)
}

type NotFoundError struct {
    Resource string
    ID       interface{}
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s with id %v not found", e.Resource, e.ID)
}

type ConflictError struct {
    Resource string
    Field    string
    Value    interface{}
}

func (e *ConflictError) Error() string {
    return fmt.Sprintf("conflict: %s with %s '%v' already exists", e.Resource, e.Field, e.Value)
}

// é¢„å®šä¹‰é”™è¯¯
var (
    ErrUserNotFound     = &NotFoundError{Resource: "user"}
    ErrEmailExists      = &ConflictError{Resource: "user", Field: "email"}
    ErrInvalidCredentials = errors.New("invalid credentials")
)

// é”™è¯¯æ£€æŸ¥å‡½æ•°
func IsValidationError(err error) bool {
    var validationErr *ValidationError
    return errors.As(err, &validationErr)
}

func IsNotFoundError(err error) bool {
    var notFoundErr *NotFoundError
    return errors.As(err, &notFoundErr)
}

func IsConflictError(err error) bool {
    var conflictErr *ConflictError
    return errors.As(err, &conflictErr)
}
```

#### é”™è¯¯åŒ…è£…ä¸ä¸Šä¸‹æ–‡
```go
// âŒ ä¸¢å¤±åŸå§‹é”™è¯¯ä¿¡æ¯
func (s *UserService) GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, errors.New("invalid user id")
    }

    user, err := s.repo.FindByID(id)
    if err != nil {
        return nil, errors.New("database error")
    }

    return user, nil
}

// âœ… ä¿ç•™é”™è¯¯é“¾
func (s *UserService) GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, &ValidationError{
            Field:   "id",
            Message: "must be positive",
            Value:   id,
        }
    }

    user, err := s.repo.FindByID(id)
    if err != nil {
        return nil, fmt.Errorf("failed to find user %d: %w", id, err)
    }

    return user, nil
}

// âœ… æä¾›ä¸°å¯Œçš„é”™è¯¯ä¸Šä¸‹æ–‡
func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error) {
    // éªŒè¯è¯·æ±‚
    if err := s.validateCreateRequest(req); err != nil {
        return nil, fmt.Errorf("create user request validation failed: %w", err)
    }

    // æ£€æŸ¥é‚®ç®±å”¯ä¸€æ€§
    if exists, err := s.emailExists(ctx, req.Email); err != nil {
        return nil, fmt.Errorf("failed to check email existence: %w", err)
    } else if exists {
        return nil, &ConflictError{
            Resource: "user",
            Field:    "email",
            Value:    req.Email,
        }
    }

    // åˆ›å»ºç”¨æˆ·
    user := &User{
        Name:      req.Name,
        Email:     req.Email,
        CreatedAt: time.Now(),
    }

    if err := s.repo.Create(ctx, user); err != nil {
        return nil, fmt.Errorf("failed to create user in database: %w", err)
    }

    // å‘é€æ¬¢è¿é‚®ä»¶
    if err := s.sendWelcomeEmail(ctx, user); err != nil {
        // è®°å½•é”™è¯¯ä½†ä¸ä¸­æ–­æµç¨‹
        log.Printf("failed to send welcome email to user %d: %v", user.ID, err)
    }

    return user, nil
}
```

#### é”™è¯¯æ¢å¤ç­–ç•¥
```go
// é‡è¯•æœºåˆ¶
type RetryConfig struct {
    MaxAttempts int
    Delay       time.Duration
    Backoff     float64
}

func WithRetry(ctx context.Context, config RetryConfig, fn func() error) error {
    var lastErr error

    for attempt := 1; attempt <= config.MaxAttempts; attempt++ {
        if err := fn(); err == nil {
            return nil
        } else {
            lastErr = err

            if attempt < config.MaxAttempts {
                delay := time.Duration(float64(config.Delay) * math.Pow(config.Backoff, float64(attempt-1)))
                select {
                case <-ctx.Done():
                    return ctx.Err()
                case <-time.After(delay):
                    continue
                }
            }
        }
    }

    return fmt.Errorf("failed after %d attempts: %w", config.MaxAttempts, lastErr)
}

// æ–­è·¯å™¨æ¨¡å¼
type CircuitBreaker struct {
    maxFailures  int
    resetTimeout time.Duration
    failures     int
    lastFailTime time.Time
    state        State
    mutex        sync.Mutex
}

type State int

const (
    StateClosed State = iota
    StateOpen
    StateHalfOpen
)

func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()

    switch cb.state {
    case StateOpen:
        if time.Since(cb.lastFailTime) > cb.resetTimeout {
            cb.state = StateHalfOpen
            cb.failures = 0
        } else {
            return errors.New("circuit breaker is open")
        }
    case StateHalfOpen:
        // å…è®¸å°‘é‡è¯·æ±‚é€šè¿‡
    }

    err := fn()
    if err != nil {
        cb.failures++
        cb.lastFailTime = time.Now()

        if cb.failures >= cb.maxFailures {
            cb.state = StateOpen
        }
        return err
    }

    // æˆåŠŸè°ƒç”¨
    cb.failures = 0
    cb.state = StateClosed
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func (s *UserService) CreateUserWithRetry(ctx context.Context, req *CreateUserRequest) error {
    retryConfig := RetryConfig{
        MaxAttempts: 3,
        Delay:       100 * time.Millisecond,
        Backoff:     2.0,
    }

    return WithRetry(ctx, retryConfig, func() error {
        return s.CreateUser(ctx, req)
    })
}
```

---

## ğŸš€ å¹¶å‘ç¼–ç¨‹æ¨¡å¼

### Goroutineæœ€ä½³å®è·µ

#### æ§åˆ¶Goroutineæ•°é‡
```go
// âŒ æ— é™åˆ¶åˆ›å»ºgoroutine
func ProcessUsers(users []User) {
    for _, user := range users {
        go func(u User) {
            // å¤„ç†ç”¨æˆ·
            ProcessUser(u)
        }(user)
    }
}

// âœ… ä½¿ç”¨worker poolæ¨¡å¼
func ProcessUsers(users []User) error {
    const workerCount = 10
    jobs := make(chan User, len(users))
    results := make(chan error, len(users))

    // å¯åŠ¨worker
    var wg sync.WaitGroup
    for i := 0; i < workerCount; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for user := range jobs {
                if err := ProcessUser(user); err != nil {
                    results <- err
                } else {
                    results <- nil
                }
            }
        }()
    }

    // å‘é€ä»»åŠ¡
    go func() {
        defer close(jobs)
        for _, user := range users {
            jobs <- user
        }
    }()

    // ç­‰å¾…å®Œæˆ
    go func() {
        wg.Wait()
        close(results)
    }()

    // æ”¶é›†ç»“æœ
    var errors []error
    for err := range results {
        if err != nil {
            errors = append(errors, err)
        }
    }

    if len(errors) > 0 {
        return fmt.Errorf("processing completed with %d errors: %v", len(errors), errors)
    }

    return nil
}
```

#### ä¼˜é›…å…³é—­
```go
type Server struct {
    httpServer *http.Server
    tasks      []func(context.Context) error
}

func NewServer() *Server {
    return &Server{
        tasks: make([]func(context.Context) error, 0),
    }
}

func (s *Server) AddTask(task func(context.Context) error) {
    s.tasks = append(s.tasks, task)
}

func (s *Server) Start() error {
    // å¯åŠ¨HTTPæœåŠ¡å™¨
    go func() {
        if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Printf("HTTP server error: %v", err)
        }
    }()

    // å¯åŠ¨åå°ä»»åŠ¡
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    for _, task := range s.tasks {
        go func(t func(context.Context) error) {
            if err := t(ctx); err != nil {
                log.Printf("Task error: %v", err)
            }
        }(task)
    }

    return nil
}

func (s *Server) Shutdown(ctx context.Context) error {
    // åˆ›å»ºä¸€ä¸ªè¶…æ—¶context
    shutdownCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()

    // å…³é—­HTTPæœåŠ¡å™¨
    if err := s.httpServer.Shutdown(shutdownCtx); err != nil {
        return fmt.Errorf("failed to shutdown HTTP server: %w", err)
    }

    // å–æ¶ˆæ‰€æœ‰åå°ä»»åŠ¡
    cancel()

    return nil
}

// ä½¿ç”¨ä¿¡å·å¤„ç†ä¼˜é›…å…³é—­
func main() {
    server := NewServer()

    // æ·»åŠ ä»»åŠ¡
    server.AddTask(func(ctx context.Context) error {
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()

        for {
            select {
            case <-ctx.Done():
                return ctx.Err()
            case <-ticker.C:
                if err := doPeriodicTask(); err != nil {
                    log.Printf("Periodic task error: %v", err)
                }
            }
        }
    })

    if err := server.Start(); err != nil {
        log.Fatal(err)
    }

    // ç­‰å¾…ä¿¡å·
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
    <-sigChan

    // ä¼˜é›…å…³é—­
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    if err := server.Shutdown(ctx); err != nil {
        log.Printf("Shutdown error: %v", err)
        os.Exit(1)
    }

    log.Println("Server shutdown gracefully")
}
```

### Channelä½¿ç”¨æ¨¡å¼

#### æ‰‡å…¥æ¨¡å¼ (Fan-in)
```go
func fanIn(channels ...<-chan string) <-chan string {
    output := make(chan string)

    var wg sync.WaitGroup
    for _, ch := range channels {
        wg.Add(1)
        go func(ch <-chan string) {
            defer wg.Done()
            for value := range ch {
                output <- value
            }
        }(ch)
    }

    go func() {
        wg.Wait()
        close(output)
    }()

    return output
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    ch3 := make(chan string)

    // å¯åŠ¨ç”Ÿäº§è€…
    go func() {
        defer close(ch1)
        for i := 0; i < 5; i++ {
            ch1 <- fmt.Sprintf("ch1-%d", i)
            time.Sleep(100 * time.Millisecond)
        }
    }()

    go func() {
        defer close(ch2)
        for i := 0; i < 5; i++ {
            ch2 <- fmt.Sprintf("ch2-%d", i)
            time.Sleep(150 * time.Millisecond)
        }
    }()

    go func() {
        defer close(ch3)
        for i := 0; i < 5; i++ {
            ch3 <- fmt.Sprintf("ch3-%d", i)
            time.Sleep(200 * time.Millisecond)
        }
    }()

    // æ‰‡å…¥
    output := fanIn(ch1, ch2, ch3)

    for value := range output {
        fmt.Println(value)
    }
}
```

#### æ‰‡å‡ºæ¨¡å¼ (Fan-out)
```go
func fanOut(input <-chan int, workerCount int) []<-chan int {
    outputs := make([]<-chan int, workerCount)

    for i := 0; i < workerCount; i++ {
        output := make(chan int)
        outputs[i] = output

        go func(ch chan<- int) {
            defer close(ch)
            for value := range input {
                // å¤„ç†æ•°æ®
                result := process(value)
                ch <- result
            }
        }(output)
    }

    return outputs
}

func process(value int) int {
    // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
    time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
    return value * value
}
```

#### é™æµæ¨¡å¼
```go
type RateLimiter struct {
    rate       time.Duration
    burst      int
    tokens     chan struct{}
    lastUpdate time.Time
    mutex      sync.Mutex
}

func NewRateLimiter(rate time.Duration, burst int) *RateLimiter {
    rl := &RateLimiter{
        rate:   rate,
        burst:  burst,
        tokens: make(chan struct{}, burst),
    }

    // åˆå§‹å¡«å……ä»¤ç‰Œ
    for i := 0; i < burst; i++ {
        rl.tokens <- struct{}{}
    }

    return rl
}

func (rl *RateLimiter) Allow() bool {
    select {
    case <-rl.tokens:
        return true
    default:
        rl.refill()
        select {
        case <-rl.tokens:
            return true
        default:
            return false
        }
    }
}

func (rl *RateLimiter) refill() {
    rl.mutex.Lock()
    defer rl.mutex.Unlock()

    now := time.Now()
    elapsed := now.Sub(rl.lastUpdate)
    if elapsed < rl.rate {
        return
    }

    tokensToAdd := int(elapsed / rl.rate)
    if tokensToAdd <= 0 {
        return
    }

    for i := 0; i < tokensToAdd && len(rl.tokens) < cap(rl.tokens); i++ {
        select {
        case rl.tokens <- struct{}{}:
        default:
            break
        }
    }

    rl.lastUpdate = now
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    limiter := NewRateLimiter(100*time.Millisecond, 5)

    for i := 0; i < 20; i++ {
        if limiter.Allow() {
            fmt.Printf("Request %d allowed\n", i)
        } else {
            fmt.Printf("Request %d rate limited\n", i)
        }
        time.Sleep(50 * time.Millisecond)
    }
}
```

### Contextä½¿ç”¨æ¨¡å¼

#### è¶…æ—¶æ§åˆ¶
```go
func (s *UserService) GetUserWithTimeout(ctx context.Context, id int) (*User, error) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„context
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()

    return s.repo.FindByID(ctx, id)
}

func (s *UserService) BatchProcessUsers(ctx context.Context, users []User) error {
    const batchSize = 10
    const timeout = 30 * time.Second

    for i := 0; i < len(users); i += batchSize {
        end := i + batchSize
        if end > len(users) {
            end = len(users)
        }

        batch := users[i:end]

        // ä¸ºæ¯ä¸ªæ‰¹æ¬¡åˆ›å»ºç‹¬ç«‹çš„è¶…æ—¶
        ctx, cancel := context.WithTimeout(ctx, timeout)
        if err := s.processBatch(ctx, batch); err != nil {
            cancel()
            return fmt.Errorf("failed to process batch %d: %w", i/batchSize, err)
        }
        cancel()
    }

    return nil
}
```

#### å–æ¶ˆä¼ æ’­
```go
func (s *Service) ProcessData(ctx context.Context, data []Data) error {
    // åˆ›å»ºå­context
    childCtx, cancel := context.WithCancel(ctx)
    defer cancel()

    // å¯åŠ¨å¤šä¸ªgoroutine
    errChan := make(chan error, 2)

    go func() {
        errChan <- s.step1(childCtx, data)
    }()

    go func() {
        errChan <- s.step2(childCtx, data)
    }()

    // ç­‰å¾…å®Œæˆæˆ–å–æ¶ˆ
    var errors []error
    for i := 0; i < 2; i++ {
        select {
        case err := <-errChan:
            if err != nil {
                errors = append(errors, err)
                cancel() // å–æ¶ˆå…¶ä»–goroutine
            }
        case <-ctx.Done():
            return ctx.Err()
        }
    }

    if len(errors) > 0 {
        return fmt.Errorf("processing failed: %v", errors)
    }

    return nil
}
```

#### å€¼ä¼ é€’
```go
type UserIDKey struct{}
type RequestIDKey struct{}

func WithUserID(ctx context.Context, userID int) context.Context {
    return context.WithValue(ctx, UserIDKey{}, userID)
}

func GetUserID(ctx context.Context) (int, bool) {
    userID, ok := ctx.Value(UserIDKey{}).(int)
    return userID, ok
}

func WithRequestID(ctx context.Context, requestID string) context.Context {
    return context.WithValue(ctx, RequestIDKey{}, requestID)
}

func GetRequestID(ctx context.Context) string {
    if requestID, ok := ctx.Value(RequestIDKey{}).(string); ok {
        return requestID
    }
    return ""
}

// åœ¨ä¸­é—´ä»¶ä¸­ä½¿ç”¨
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        requestID := generateRequestID()
        ctx := WithRequestID(r.Context(), requestID)

        logger := logger.With("request_id", requestID)
        ctx = WithLogger(ctx, logger)

        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

func (s *UserService) GetUser(ctx context.Context, id int) (*User, error) {
    logger := GetLogger(ctx)
    requestID := GetRequestID(ctx)

    logger.Info("getting user", "user_id", id, "request_id", requestID)

    user, err := s.repo.FindByID(ctx, id)
    if err != nil {
        logger.Error("failed to get user", "error", err, "user_id", id)
        return nil, err
    }

    return user, nil
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### å†…å­˜ä¼˜åŒ–

#### é¿å…å†…å­˜æ³„æ¼
```go
// âŒ å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
func (s *Service) WatchChanges() {
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            changes := s.getChanges()
            // å¦‚æœchangeså¾ˆå¤§ä¸”å¤„ç†å¾ˆæ…¢ï¼Œä¼šç´¯ç§¯å†…å­˜
            processChanges(changes)
        case <-s.ctx.Done():
            return
        }
    }
}

// âœ… ä½¿ç”¨å¯¹è±¡æ± é¿å…å†…å­˜æ³„æ¼
func (s *Service) WatchChanges() {
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()

    // ä½¿ç”¨å¯¹è±¡æ± 
    changePool := &sync.Pool{
        New: func() interface{} {
            return make([]Change, 0, 100)
        },
    }

    for {
        select {
        case <-ticker.C:
            // ä»æ± ä¸­è·å–åˆ‡ç‰‡
            changes := changePool.Get().([]Change)
            changes = changes[:0] // é‡ç½®é•¿åº¦ä½†ä¿ç•™å®¹é‡

            changes = s.getChanges()
            processChanges(changes)

            // å½’è¿˜åˆ°æ± ä¸­
            changePool.Put(changes)

        case <-s.ctx.Done():
            return
        }
    }
}
```

#### å­—ç¬¦ä¸²ä¼˜åŒ–
```go
// âŒ å­—ç¬¦ä¸²æ‹¼æ¥æ€§èƒ½å·®
func BuildQuery(params map[string]string) string {
    var query string
    for key, value := range params {
        query += key + "=" + value + "&"
    }
    return query
}

// âœ… ä½¿ç”¨strings.Builder
func BuildQuery(params map[string]string) string {
    var builder strings.Builder
    builder.Grow(len(params) * 20) // é¢„åˆ†é…å®¹é‡

    first := true
    for key, value := range params {
        if !first {
            builder.WriteByte('&')
        }
        builder.WriteString(key)
        builder.WriteByte('=')
        builder.WriteString(value)
        first = false
    }

    return builder.String()
}

// âœ… å¯¹äºå¤§é‡æ‹¼æ¥ï¼Œä½¿ç”¨æ›´é«˜æ•ˆçš„æ–¹å¼
func BuildLargeQuery(params map[string]string) string {
    parts := make([]string, 0, len(params)*2)
    for key, value := range params {
        parts = append(parts, key, value)
    }
    return strings.Join(parts, "=") + "&"
}
```

#### åˆ‡ç‰‡ä¼˜åŒ–
```go
// âŒ é¢‘ç¹æ‰©å®¹åˆ‡ç‰‡
func ProcessData(data []int) []int {
    var result []int
    for _, item := range data {
        if isValid(item) {
            result = append(result, process(item))
        }
    }
    return result
}

// âœ… é¢„åˆ†é…å®¹é‡
func ProcessData(data []int) []int {
    // ä¼°ç®—å®¹é‡
    estimatedSize := len(data) / 2 // å‡è®¾æœ‰ä¸€åŠæ•°æ®æœ‰æ•ˆ
    result := make([]int, 0, estimatedSize)

    for _, item := range data {
        if isValid(item) {
            result = append(result, process(item))
        }
    }
    return result
}

// âœ… å¤ç”¨åˆ‡ç‰‡
func (p *Processor) ProcessData(data []int) []int {
    // å¤ç”¨å·²æœ‰çš„åˆ‡ç‰‡
    p.result = p.result[:0] // é‡ç½®é•¿åº¦ä½†ä¿ç•™å®¹é‡

    if cap(p.result) < len(data) {
        p.result = make([]int, 0, len(data))
    }

    for _, item := range data {
        if isValid(item) {
            p.result = append(p.result, process(item))
        }
    }

    return p.result
}
```

### å¹¶å‘æ€§èƒ½ä¼˜åŒ–

#### å‡å°‘é”ç«äº‰
```go
// âŒ ç²—ç²’åº¦é”
type Counter struct {
    mutex sync.Mutex
    count int
}

func (c *Counter) Increment() {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    c.count++
}

func (c *Counter) GetValue() int {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    return c.count
}

// âœ… ä½¿ç”¨åŸå­æ“ä½œ
type Counter struct {
    count int64
}

func (c *Counter) Increment() {
    atomic.AddInt64(&c.count, 1)
}

func (c *Counter) GetValue() int64 {
    return atomic.LoadInt64(&c.count)
}

// âœ… åˆ†ç‰‡é”å‡å°‘ç«äº‰
type ShardedMap struct {
    shards []map[string]interface{}
    mutexes []sync.RWMutex
    shardCount int
}

func NewShardedMap(shardCount int) *ShardedMap {
    sm := &ShardedMap{
        shards: make([]map[string]interface{}, shardCount),
        mutexes: make([]sync.RWMutex, shardCount),
        shardCount: shardCount,
    }

    for i := 0; i < shardCount; i++ {
        sm.shards[i] = make(map[string]interface{})
    }

    return sm
}

func (sm *ShardedMap) getShard(key string) (map[string]interface{}, *sync.RWMutex) {
    hash := fnv32(key)
    index := hash % uint32(sm.shardCount)
    return sm.shards[index], &sm.mutexes[index]
}

func (sm *ShardedMap) Set(key string, value interface{}) {
    shard, mutex := sm.getShard(key)
    mutex.Lock()
    defer mutex.Unlock()
    shard[key] = value
}

func (sm *ShardedMap) Get(key string) (interface{}, bool) {
    shard, mutex := sm.getShard(key)
    mutex.RLock()
    defer mutex.RUnlock()
    value, exists := shard[key]
    return value, exists
}

func fnv32(s string) uint32 {
    h := fnv32OffsetBasis
    for i := 0; i < len(s); i++ {
        h ^= uint32(s[i])
        h *= fnv32Prime
    }
    return h
}

const (
    fnv32OffsetBasis = 2166136261
    fnv32Prime       = 16777619
)
```

#### æ— é”æ•°æ®ç»“æ„
```go
// ä½¿ç”¨channelå®ç°æ— é”é˜Ÿåˆ—
type Queue struct {
    input  chan interface{}
    output chan interface{}
}

func NewQueue() *Queue {
    q := &Queue{
        input:  make(chan interface{}),
        output: make(chan interface{}),
    }

    go q.worker()
    return q
}

func (q *Queue) worker() {
    var items []interface{}

    for {
        var output chan interface{}
        var item interface{}

        if len(items) > 0 {
            output = q.output
            item = items[0]
        }

        select {
        case newItem := <-q.input:
            items = append(items, newItem)
        case output <- item:
            items = items[1:]
        }
    }
}

func (q *Queue) Enqueue(item interface{}) {
    q.input <- item
}

func (q *Queue) Dequeue() interface{} {
    return <-q.output
}
```

### æ•°æ®åº“ä¼˜åŒ–

#### è¿æ¥æ± é…ç½®
```go
type DatabaseConfig struct {
    MaxOpenConns    int
    MaxIdleConns    int
    ConnMaxLifetime time.Duration
    ConnMaxIdleTime time.Duration
}

func ConfigureDB(db *sql.DB, config DatabaseConfig) error {
    db.SetMaxOpenConns(config.MaxOpenConns)
    db.SetMaxIdleConns(config.MaxIdleConns)
    db.SetConnMaxLifetime(config.ConnMaxLifetime)
    db.SetConnMaxIdleTime(config.ConnMaxIdleTime)

    // éªŒè¯è¿æ¥
    if err := db.Ping(); err != nil {
        return fmt.Errorf("failed to ping database: %w", err)
    }

    return nil
}

// ç”Ÿäº§ç¯å¢ƒé…ç½®
func NewProductionDBConfig() DatabaseConfig {
    return DatabaseConfig{
        MaxOpenConns:    100,
        MaxIdleConns:    10,
        ConnMaxLifetime: time.Hour,
        ConnMaxIdleTime: time.Minute * 30,
    }
}

// å¼€å‘ç¯å¢ƒé…ç½®
func NewDevelopmentDBConfig() DatabaseConfig {
    return DatabaseConfig{
        MaxOpenConns:    10,
        MaxIdleConns:    5,
        ConnMaxLifetime: time.Minute * 30,
        ConnMaxIdleTime: time.Minute * 5,
    }
}
```

#### æ‰¹é‡æ“ä½œä¼˜åŒ–
```go
// âŒ N+1æŸ¥è¯¢é—®é¢˜
func (r *UserRepository) GetUsersWithPosts(userIDs []int) ([]UserWithPosts, error) {
    var results []UserWithPosts

    for _, id := range userIDs {
        user, err := r.FindByID(id)
        if err != nil {
            return nil, err
        }

        posts, err := r.FindPostsByUserID(id)
        if err != nil {
            return nil, err
        }

        results = append(results, UserWithPosts{
            User:  *user,
            Posts: posts,
        })
    }

    return results, nil
}

// âœ… æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–
func (r *UserRepository) GetUsersWithPosts(userIDs []int) ([]UserWithPosts, error) {
    // æ‰¹é‡æŸ¥è¯¢ç”¨æˆ·
    users, err := r.FindByIDs(userIDs)
    if err != nil {
        return nil, err
    }

    // æ‰¹é‡æŸ¥è¯¢æ–‡ç« 
    posts, err := r.FindPostsByUserIDs(userIDs)
    if err != nil {
        return nil, err
    }

    // æŒ‰ç”¨æˆ·IDåˆ†ç»„æ–‡ç« 
    postsByUser := make(map[int][]Post)
    for _, post := range posts {
        postsByUser[post.UserID] = append(postsByUser[post.UserID], post)
    }

    // ç»„è£…ç»“æœ
    var results []UserWithPosts
    for _, user := range users {
        userPosts := postsByUser[user.ID]
        results = append(results, UserWithPosts{
            User:  user,
            Posts: userPosts,
        })
    }

    return results, nil
}
```

---

## ğŸ’¾ å†…å­˜ç®¡ç†ç­–ç•¥

### åƒåœ¾å›æ”¶ä¼˜åŒ–

#### å‡å°‘GCå‹åŠ›
```go
// âŒ åˆ›å»ºå¤§é‡ä¸´æ—¶å¯¹è±¡
func ProcessData(data []byte) []byte {
    var result []byte

    for _, b := range data {
        // æ¯æ¬¡å¾ªç¯éƒ½åˆ›å»ºæ–°çš„åˆ‡ç‰‡
        temp := make([]byte, 1)
        temp[0] = transform(b)
        result = append(result, temp...)
    }

    return result
}

// âœ… å¤ç”¨å¯¹è±¡ï¼Œå‡å°‘GCå‹åŠ›
func ProcessData(data []byte) []byte {
    // é¢„åˆ†é…è¶³å¤Ÿå¤§çš„åˆ‡ç‰‡
    result := make([]byte, 0, len(data))

    for _, b := range data {
        result = append(result, transform(b))
    }

    return result
}

// âœ… ä½¿ç”¨å¯¹è±¡æ± 
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 0, 1024)
    },
}

func ProcessDataWithPool(data []byte) []byte {
    buffer := bufferPool.Get().([]byte)
    defer bufferPool.Put(buffer[:0]) // å½’è¿˜æ—¶é‡ç½®é•¿åº¦

    buffer = buffer[:0] // é‡ç½®é•¿åº¦ä½†ä¿ç•™å®¹é‡

    for _, b := range data {
        buffer = append(buffer, transform(b))
    }

    // å¤åˆ¶ç»“æœï¼Œå› ä¸ºbufferä¼šè¢«å½’è¿˜åˆ°æ± ä¸­
    result := make([]byte, len(buffer))
    copy(result, buffer)

    return result
}
```

#### å†…å­˜é€ƒé€¸åˆ†æ
```go
// âŒ å¯¼è‡´å†…å­˜é€ƒé€¸
func ProcessLargeData() {
    data := make([]int, 1000000)

    // åŒ¿åå‡½æ•°æ•è·dataï¼Œå¯¼è‡´dataé€ƒé€¸åˆ°å †
    go func() {
        for i := range data {
            data[i] *= 2
        }
    }()

    time.Sleep(time.Second)
}

// âœ… é¿å…å†…å­˜é€ƒé€¸
func ProcessLargeData() {
    data := make([]int, 1000000)

    // ä¼ é€’æŒ‡é’ˆè€Œä¸æ˜¯æ•è·æ•´ä¸ªæ•°ç»„
    go func(d []int) {
        for i := range d {
            d[i] *= 2
        }
    }(data)

    time.Sleep(time.Second)
}

// âœ… ä½¿ç”¨å€¼ç±»å‹é¿å…é€ƒé€¸
type Point struct {
    X, Y int
}

func (p Point) Distance(other Point) int {
    // å€¼ç±»å‹ä¸ä¼šé€ƒé€¸
    dx := p.X - other.X
    dy := p.Y - other.Y
    return dx*dx + dy*dy
}

// âŒ æŒ‡é’ˆç±»å‹å¯èƒ½å¯¼è‡´é€ƒé€¸
func (p *Point) Distance(other *Point) int {
    // æŒ‡é’ˆç±»å‹æ›´å®¹æ˜“é€ƒé€¸
    dx := p.X - other.X
    dy := p.Y - other.Y
    return dx*dx + dy*dy
}
```

#### å†…å­˜æ˜ å°„æ–‡ä»¶
```go
type MemoryMappedFile struct {
    data []byte
    file *os.File
}

func NewMemoryMappedFile(filename string) (*MemoryMappedFile, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }

    stat, err := file.Stat()
    if err != nil {
        file.Close()
        return nil, err
    }

    data, err := syscall.Mmap(int(file.Fd()), 0, int(stat.Size()),
        syscall.PROT_READ, syscall.MAP_SHARED)
    if err != nil {
        file.Close()
        return nil, err
    }

    return &MemoryMappedFile{
        data: data,
        file: file,
    }, nil
}

func (m *MemoryMappedFile) Data() []byte {
    return m.data
}

func (m *MemoryMappedFile) Close() error {
    err1 := syscall.Munmap(m.data)
    err2 := m.file.Close()

    if err1 != nil {
        return err1
    }
    return err2
}

// ä½¿ç”¨ç¤ºä¾‹
func ProcessLargeFile(filename string) error {
    mmf, err := NewMemoryMappedFile(filename)
    if err != nil {
        return err
    }
    defer mmf.Close()

    data := mmf.Data()

    // å¤„ç†æ•°æ®ï¼Œæ— éœ€å°†æ•´ä¸ªæ–‡ä»¶åŠ è½½åˆ°å†…å­˜
    for i := 0; i < len(data); i += 1024 {
        end := i + 1024
        if end > len(data) {
            end = len(data)
        }

        chunk := data[i:end]
        ProcessChunk(chunk)
    }

    return nil
}
```

### å†…å­˜ç›‘æ§ä¸è°ƒè¯•

#### å†…å­˜ç»Ÿè®¡
```go
func PrintMemStats() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    log.Printf("å†…å­˜ç»Ÿè®¡ä¿¡æ¯:")
    log.Printf("  åˆ†é…çš„å­—èŠ‚æ•°: %d KB", m.Alloc/1024)
    log.Printf("  æ€»åˆ†é…çš„å­—èŠ‚æ•°: %d KB", m.TotalAlloc/1024)
    log.Printf("  ç³»ç»Ÿå†…å­˜å­—èŠ‚æ•°: %d KB", m.Sys/1024)
    log.Printf("  GCè¿è¡Œæ¬¡æ•°: %d", m.NumGC)
    log.Printf("  ä¸‹ä¸€æ¬¡GCç›®æ ‡å­—èŠ‚æ•°: %d KB", m.NextGC/1024)
    log.Printf("  å †å¯¹è±¡æ•°é‡: %d", m.HeapObjects)
}

// å†…å­˜ç›‘æ§å™¨
type MemoryMonitor struct {
    interval time.Duration
    stopChan chan struct{}
}

func NewMemoryMonitor(interval time.Duration) *MemoryMonitor {
    return &MemoryMonitor{
        interval: interval,
        stopChan: make(chan struct{}),
    }
}

func (m *MemoryMonitor) Start() {
    ticker := time.NewTicker(m.interval)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            PrintMemStats()
        case <-m.stopChan:
            return
        }
    }
}

func (m *MemoryMonitor) Stop() {
    close(m.stopChan)
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    monitor := NewMemoryMonitor(10 * time.Second)
    go monitor.Start()
    defer monitor.Stop()

    // åº”ç”¨ç¨‹åºé€»è¾‘
    // ...
}
```

#### pprofå†…å­˜åˆ†æ
```go
import (
    _ "net/http/pprof"
    "net/http"
    "os"
    "runtime"
    "runtime/pprof"
)

func StartProfileServer() {
    go func() {
        log.Println("Profile server starting on :6060")
        log.Fatal(http.ListenAndServe(":6060", nil))
    }()
}

func EnableMemoryProfile(filename string) error {
    f, err := os.Create(filename)
    if err != nil {
        return err
    }
    defer f.Close()

    runtime.GC() // å¼ºåˆ¶GCä»¥è·å–å‡†ç¡®çš„å†…å­˜ä½¿ç”¨æƒ…å†µ

    if err := pprof.WriteHeapProfile(f); err != nil {
        return err
    }

    return nil
}

// CPUæ€§èƒ½åˆ†æ
func EnableCPUProfile(filename string) func() {
    f, err := os.Create(filename)
    if err != nil {
        log.Fatal(err)
    }

    pprof.StartCPUProfile(f)

    return func() {
        pprof.StopCPUProfile()
        f.Close()
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    // å¯åŠ¨profileæœåŠ¡å™¨
    StartProfileServer()

    // å¯ç”¨CPUåˆ†æ
    stopCPU := EnableCPUProfile("cpu.prof")
    defer stopCPU()

    // åº”ç”¨ç¨‹åºé€»è¾‘
    // ...

    // ç”Ÿæˆå†…å­˜profile
    if err := EnableMemoryProfile("mem.prof"); err != nil {
        log.Printf("Failed to write memory profile: %v", err)
    }
}
```

---

## ğŸ§ª æµ‹è¯•ä¸è´¨é‡ä¿è¯

### æµ‹è¯•ç­–ç•¥

#### å•å…ƒæµ‹è¯•
```go
// user_service_test.go
package services

import (
    "context"
    "errors"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/require"
)

// Mockå®ç°
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) FindByID(ctx context.Context, id int) (*User, error) {
    args := m.Called(ctx, id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}

func (m *MockUserRepository) Create(ctx context.Context, user *User) error {
    args := m.Called(ctx, user)
    return args.Error(0)
}

func (m *MockUserRepository) FindByEmail(ctx context.Context, email string) (*User, error) {
    args := m.Called(ctx, email)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}

// æµ‹è¯•ç”¨ä¾‹
func TestUserService_GetUser_Success(t *testing.T) {
    // å‡†å¤‡
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)

    expectedUser := &User{
        ID:    1,
        Name:  "John Doe",
        Email: "john@example.com",
    }

    ctx := context.Background()
    mockRepo.On("FindByID", ctx, 1).Return(expectedUser, nil)

    // æ‰§è¡Œ
    user, err := service.GetUser(ctx, 1)

    // éªŒè¯
    require.NoError(t, err)
    assert.Equal(t, expectedUser, user)
    mockRepo.AssertExpectations(t)
}

func TestUserService_GetUser_NotFound(t *testing.T) {
    // å‡†å¤‡
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)

    ctx := context.Background()
    mockRepo.On("FindByID", ctx, 999).Return(nil, errors.New("user not found"))

    // æ‰§è¡Œ
    user, err := service.GetUser(ctx, 999)

    // éªŒè¯
    assert.Error(t, err)
    assert.Nil(t, user)
    assert.Contains(t, err.Error(), "user not found")
    mockRepo.AssertExpectations(t)
}

func TestUserService_CreateUser_EmailExists(t *testing.T) {
    // å‡†å¤‡
    mockRepo := new(MockUserRepository)
    service := NewUserService(mockRepo)

    ctx := context.Background()
    req := &CreateUserRequest{
        Name:  "John Doe",
        Email: "john@example.com",
    }

    existingUser := &User{
        ID:    1,
        Email: "john@example.com",
    }

    mockRepo.On("FindByEmail", ctx, req.Email).Return(existingUser, nil)

    // æ‰§è¡Œ
    user, err := service.CreateUser(ctx, req)

    // éªŒè¯
    assert.Error(t, err)
    assert.Nil(t, user)
    assert.Contains(t, err.Error(), "email already exists")
    mockRepo.AssertExpectations(t)
}

// è¡¨æ ¼é©±åŠ¨æµ‹è¯•
func TestUserService_ValidateEmail_Valid(t *testing.T) {
    tests := []struct {
        name     string
        email    string
        expected bool
    }{
        {"valid email", "test@example.com", true},
        {"valid email with subdomain", "test@mail.example.com", true},
        {"invalid email - no @", "testexample.com", false},
        {"invalid email - no domain", "test@", false},
        {"invalid email - empty", "", false},
    }

    service := &UserService{}

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := service.ValidateEmail(tt.email)
            assert.Equal(t, tt.expected, result)
        })
    }
}
```

#### é›†æˆæµ‹è¯•
```go
// integration_test.go
// +build integration

package tests

import (
    "context"
    "testing"
    "time"

    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
)

func TestUserService_Integration(t *testing.T) {
    // å¯åŠ¨æµ‹è¯•æ•°æ®åº“å®¹å™¨
    ctx := context.Background()
    req := testcontainers.ContainerRequest{
        Image:        "mysql:8.0",
        ExposedPorts: []string{"3306/tcp"},
        Env: map[string]string{
            "MYSQL_ROOT_PASSWORD": "password",
            "MYSQL_DATABASE":      "testdb",
        },
        WaitingFor: wait.ForLog("ready for connections"),
    }

    container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: req,
        Started:          true,
    })
    require.NoError(t, err)
    defer container.Terminate(ctx)

    // è·å–æ•°æ®åº“è¿æ¥ä¿¡æ¯
    host, err := container.Host(ctx)
    require.NoError(t, err)

    port, err := container.MappedPort(ctx, "3306")
    require.NoError(t, err)

    // å»ºç«‹æ•°æ®åº“è¿æ¥
    db, err := setupDatabase(host, port.Port())
    require.NoError(t, err)
    defer db.Close()

    // åˆ›å»ºrepositoryå’ŒæœåŠ¡
    userRepo := NewSQLUserRepository(db)
    userService := NewUserService(userRepo, nil, nil, nil, nil)

    // æ‰§è¡Œé›†æˆæµ‹è¯•
    t.Run("Create and Get User", func(t *testing.T) {
        req := &CreateUserRequest{
            Name:  "Integration Test User",
            Email: "integration@test.com",
        }

        // åˆ›å»ºç”¨æˆ·
        user, err := userService.CreateUser(ctx, req)
        require.NoError(t, err)
        assert.NotZero(t, user.ID)

        // è·å–ç”¨æˆ·
        retrievedUser, err := userService.GetUser(ctx, user.ID)
        require.NoError(t, err)
        assert.Equal(t, user.Name, retrievedUser.Name)
        assert.Equal(t, user.Email, retrievedUser.Email)
    })

    t.Run("Duplicate Email", func(t *testing.T) {
        req := &CreateUserRequest{
            Name:  "User 1",
            Email: "duplicate@test.com",
        }

        // åˆ›å»ºç¬¬ä¸€ä¸ªç”¨æˆ·
        _, err := userService.CreateUser(ctx, req)
        require.NoError(t, err)

        // å°è¯•åˆ›å»ºé‡å¤é‚®ç®±çš„ç”¨æˆ·
        req2 := &CreateUserRequest{
            Name:  "User 2",
            Email: "duplicate@test.com",
        }

        _, err = userService.CreateUser(ctx, req2)
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "email already exists")
    })
}

func setupDatabase(host string, port int) (*sql.DB, error) {
    dsn := fmt.Sprintf("root:password@tcp(%s:%d)/testdb?parseTime=true", host, port)

    // ç­‰å¾…æ•°æ®åº“å°±ç»ª
    var db *sql.DB
    var err error

    for i := 0; i < 30; i++ {
        db, err = sql.Open("mysql", dsn)
        if err != nil {
            return nil, err
        }

        if err = db.Ping(); err == nil {
            break
        }

        db.Close()
        time.Sleep(time.Second)
    }

    if err != nil {
        return nil, fmt.Errorf("failed to connect to database: %w", err)
    }

    // è¿è¡Œè¿ç§»
    if err := runMigrations(db); err != nil {
        return nil, fmt.Errorf("failed to run migrations: %w", err)
    }

    return db, nil
}
```

#### åŸºå‡†æµ‹è¯•
```go
func BenchmarkUserRepository_Create(b *testing.B) {
    // å‡†å¤‡æµ‹è¯•ç¯å¢ƒ
    db := setupTestDB(b)
    defer db.Close()

    repo := NewSQLUserRepository(db)
    ctx := context.Background()

    // é¢„çƒ­
    for i := 0; i < 100; i++ {
        user := &User{
            Name:  fmt.Sprintf("User %d", i),
            Email: fmt.Sprintf("user%d@test.com", i),
        }
        repo.Create(ctx, user)
    }

    // é‡ç½®è®¡æ—¶å™¨
    b.ResetTimer()

    // è¿è¡ŒåŸºå‡†æµ‹è¯•
    b.RunParallel(func(pb *testing.PB) {
        i := 0
        for pb.Next() {
            user := &User{
                Name:  fmt.Sprintf("BenchUser %d", i),
                Email: fmt.Sprintf("benchuser%d@test.com", i),
            }
            repo.Create(ctx, user)
            i++
        }
    })
}

func BenchmarkUserService_GetUser(b *testing.B) {
    // å‡†å¤‡æµ‹è¯•æ•°æ®
    db := setupTestDB(b)
    defer db.Close()

    repo := NewSQLUserRepository(db)
    service := NewUserService(repo, nil, nil, nil, nil)
    ctx := context.Background()

    // åˆ›å»ºæµ‹è¯•ç”¨æˆ·
    users := make([]*User, 1000)
    for i := 0; i < 1000; i++ {
        user := &User{
            Name:  fmt.Sprintf("User %d", i),
            Email: fmt.Sprintf("user%d@test.com", i),
        }
        repo.Create(ctx, user)
        users[i] = user
    }

    b.ResetTimer()

    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            // éšæœºé€‰æ‹©ä¸€ä¸ªç”¨æˆ·ID
            userID := users[rand.Intn(len(users))].ID
            _, err := service.GetUser(ctx, userID)
            if err != nil {
                b.Fatal(err)
            }
        }
    })
}
```

### æµ‹è¯•å·¥å…·

#### æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
```go
type UserBuilder struct {
    user User
}

func NewUserBuilder() *UserBuilder {
    return &UserBuilder{
        user: User{
            Name:      "Default User",
            Email:     "default@example.com",
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        },
    }
}

func (b *UserBuilder) WithName(name string) *UserBuilder {
    b.user.Name = name
    return b
}

func (b *UserBuilder) WithEmail(email string) *UserBuilder {
    b.user.Email = email
    return b
}

func (b *UserBuilder) WithID(id int) *UserBuilder {
    b.user.ID = id
    return b
}

func (b *UserBuilder) CreatedAt(t time.Time) *UserBuilder {
    b.user.CreatedAt = t
    return b
}

func (b *UserBuilder) Build() User {
    return b.user
}

// ä½¿ç”¨ç¤ºä¾‹
func TestUserService_ProcessUser(t *testing.T) {
    user := NewUserBuilder().
        WithName("Test User").
        WithEmail("test@example.com").
        WithID(123).
        CreatedAt(time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC)).
        Build()

    // æµ‹è¯•é€»è¾‘
    // ...
}

// æµ‹è¯•æ•°æ®å·¥å‚
type UserFactory struct {
    counter int
}

func NewUserFactory() *UserFactory {
    return &UserFactory{counter: 0}
}

func (f *UserFactory) CreateUser() User {
    f.counter++
    return User{
        ID:        f.counter,
        Name:      fmt.Sprintf("User %d", f.counter),
        Email:     fmt.Sprintf("user%d@example.com", f.counter),
        CreatedAt: time.Now(),
    }
}

func (f *UserFactory) CreateUsers(count int) []User {
    users := make([]User, count)
    for i := 0; i < count; i++ {
        users[i] = f.CreateUser()
    }
    return users
}
```

#### æµ‹è¯•è¾…åŠ©å‡½æ•°
```go
// æ–­è¨€è¾…åŠ©å‡½æ•°
func AssertNoError(t *testing.T, err error) {
    t.Helper()
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
}

func AssertError(t *testing.T, err error, expectedMessage string) {
    t.Helper()
    if err == nil {
        t.Fatal("expected error but got nil")
    }
    if !strings.Contains(err.Error(), expectedMessage) {
        t.Fatalf("error message %q does not contain %q", err.Error(), expectedMessage)
    }
}

func AssertEqualTime(t *testing.T, expected, actual time.Time, delta time.Duration) {
    t.Helper()
    diff := expected.Sub(actual)
    if diff < -delta || diff > delta {
        t.Fatalf("times differ by %v, expected diff within %v", diff, delta)
    }
}

// HTTPæµ‹è¯•è¾…åŠ©å‡½æ•°
func AssertHTTPStatus(t *testing.T, resp *http.Response, expectedStatus int) {
    t.Helper()
    if resp.StatusCode != expectedStatus {
        t.Fatalf("expected status %d, got %d", expectedStatus, resp.StatusCode)
    }
}

func AssertJSONResponse(t *testing.T, resp *http.Response, expected interface{}) {
    t.Helper()
    defer resp.Body.Close()

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        t.Fatalf("failed to read response body: %v", err)
    }

    var actual interface{}
    if err := json.Unmarshal(body, &actual); err != nil {
        t.Fatalf("failed to unmarshal response body: %v", err)
    }

    assert.Equal(t, expected, actual)
}

// æ•°æ®åº“æµ‹è¯•è¾…åŠ©å‡½æ•°
func SetupTestDB(t *testing.T) *sql.DB {
    t.Helper()

    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        t.Fatalf("failed to open test database: %v", err)
    }

    if err := runMigrations(db); err != nil {
        t.Fatalf("failed to run migrations: %v", err)
    }

    return db
}

func CleanupTestDB(t *testing.T, db *sql.DB) {
    t.Helper()

    tables := []string{"users", "posts", "comments"}
    for _, table := range tables {
        _, err := db.Exec(fmt.Sprintf("DELETE FROM %s", table))
        if err != nil {
            t.Fatalf("failed to clean table %s: %v", table, err)
        }
    }
}
```

---

## ğŸ“¦ åŒ…ç®¡ç†ä¸ä¾èµ–

### Go Modulesæœ€ä½³å®è·µ

#### ç‰ˆæœ¬ç®¡ç†ç­–ç•¥
```go
// go.mod
module github.com/yourcompany/yourproject

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/golang-jwt/jwt/v5 v5.0.0
    github.com/stretchr/testify v1.8.4
    gorm.io/driver/mysql v1.5.2
    gorm.io/gorm v1.25.5
)

// é—´æ¥ä¾èµ–
require (
    github.com/bytedance/sonic v1.9.1 // indirect
    github.com/chenzhuoyu/base64x v0.0.0-20221115062448-fe3a3abad311 // indirect
    // ...
)
```

#### ä¾èµ–ç‰ˆæœ¬æ§åˆ¶
```bash
# æŸ¥çœ‹å½“å‰ä¾èµ–
go list -m all

# æŸ¥çœ‹ç‰¹å®šæ¨¡å—çš„å¯ç”¨ç‰ˆæœ¬
go list -m -versions github.com/gin-gonic/gin

# æ›´æ–°åˆ°æœ€æ–°è¡¥ä¸ç‰ˆæœ¬
go get -u=patch github.com/gin-gonic/gin

# æ›´æ–°åˆ°æœ€æ–°æ¬¡ç‰ˆæœ¬
go get -u=minor github.com/gin-gonic/gin

# æ›´æ–°åˆ°æœ€æ–°ä¸»ç‰ˆæœ¬ï¼ˆå¯èƒ½åŒ…å«ç ´åæ€§æ›´æ”¹ï¼‰
go get -u=latest github.com/gin-gonic/gin

# å›ºå®šç‰ˆæœ¬
go get github.com/gin-gonic/gin@v1.9.1

# ä½¿ç”¨commit hash
go get github.com/gin-gonic/gin@da5c9f7
```

#### ä¾èµ–æ¸…ç†
```bash
# æ·»åŠ ä¾èµ–å¹¶è‡ªåŠ¨æ›´æ–°go.modå’Œgo.sum
go get github.com/example/package

# ç§»é™¤æœªä½¿ç”¨çš„ä¾èµ–
go mod tidy

# éªŒè¯ä¾èµ–
go mod verify

# ä¸‹è½½ä¾èµ–åˆ°vendorç›®å½•
go mod vendor

# æ„å»ºæ—¶ä½¿ç”¨vendorç›®å½•
go build -mod=vendor
```

### ç§æœ‰æ¨¡å—ç®¡ç†

#### é…ç½®ç§æœ‰æ¨¡å—
```bash
# è®¾ç½®Goæ¨¡å—ä»£ç†
export GOPRIVATE=github.com/yourcompany/*
export GOPROXY=https://proxy.golang.org,direct

# æˆ–è€…ä½¿ç”¨ç§æœ‰ä»£ç†
export GOPROXY=https://proxy.golang.org,https://your-private-proxy.company.com,direct
```

#### ä½¿ç”¨ç§æœ‰æ¨¡å—
```go
// go.mod
module github.com/yourcompany/yourproject

go 1.21

require (
    github.com/yourcompany/internal-auth v1.2.3
    github.com/yourcompany/shared-utils v0.1.0
)
```

### ä¾èµ–æ³¨å…¥æ¡†æ¶

#### ä½¿ç”¨Wire
```go
// wire.go
// +build wireinject

package main

import (
    "github.com/google/wire"
    "yourproject/internal/config"
    "yourproject/internal/database"
    "yourproject/internal/handlers"
    "yourproject/internal/repositories"
    "yourproject/internal/services"
)

// å®šä¹‰Provider Set
var ConfigSet = wire.NewSet(
    config.LoadConfig,
    wire.Bind(new(ConfigInterface), new(*config.Config)),
)

var DatabaseSet = wire.NewSet(
    database.NewConnection,
    database.NewMigrator,
    wire.Bind(new(DatabaseInterface), new(*database.Database)),
)

var RepositorySet = wire.NewSet(
    repositories.NewUserRepository,
    repositories.NewPostRepository,
    wire.Bind(new(UserRepositoryInterface), new(*repositories.UserRepository)),
    wire.Bind(new(PostRepositoryInterface), new(*repositories.PostRepository)),
)

var ServiceSet = wire.NewSet(
    services.NewUserService,
    services.NewPostService,
    wire.Bind(new(UserServiceInterface), new(*services.UserService)),
    wire.Bind(new(PostServiceInterface), new(*services.PostService)),
)

var HandlerSet = wire.NewSet(
    handlers.NewUserHandler,
    handlers.NewPostHandler,
)

var AppSet = wire.NewSet(
    ConfigSet,
    DatabaseSet,
    RepositorySet,
    ServiceSet,
    HandlerSet,
    NewApp,
)

// æ³¨å…¥å‡½æ•°
func InitializeApp(configPath string) (*App, error) {
    wire.Build(AppSet)
    return nil, nil // wireä¼šç”Ÿæˆå®é™…çš„åˆå§‹åŒ–ä»£ç 
}
```

```go
// main.go
package main

import (
    "log"

    "yourproject"
)

func main() {
    app, err := yourproject.InitializeApp("config.yaml")
    if err != nil {
        log.Fatal(err)
    }

    if err := app.Run(); err != nil {
        log.Fatal(err)
    }
}
```

---

## ğŸ› ï¸ å·¥å…·é“¾ä¸å·¥ç¨‹åŒ–

### ä»£ç è´¨é‡å·¥å…·

#### gofmtå’Œgoimports
```bash
# æ ¼å¼åŒ–ä»£ç 
gofmt -w .

# è‡ªåŠ¨å¯¼å…¥å’Œåˆ é™¤æœªä½¿ç”¨çš„å¯¼å…¥
goimports -w .

# åœ¨ä¿å­˜æ—¶è‡ªåŠ¨æ ¼å¼åŒ–ï¼ˆç¼–è¾‘å™¨é…ç½®ï¼‰
# VSCode settings.json
{
    "go.formatTool": "goimports",
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
        "source.organizeImports": true
    }
}
```

#### staticcheck
```bash
# å®‰è£…staticcheck
go install honnef.co/go/tools/cmd/staticcheck@latest

# è¿è¡Œstaticcheck
staticcheck ./...

# é…ç½®staticcheckï¼ˆ.staticcheck.conf)
checks = [
    "all",
    "-ST1000",  // ç¦ç”¨æŸäº›æ£€æŸ¥
    "-ST1003",
]

# å¿½ç•¥æŸäº›æ£€æŸ¥
# //staticcheck:ignore ST1000
func unused_function() {
    // ...
}
```

#### golangci-lint
```yaml
# .golangci.yml
run:
  timeout: 5m
  issues-exit-code: 1
  tests: true

linters-settings:
  govet:
    check-shadowing: true
  golint:
    min-confidence: 0
  gocyclo:
    min-complexity: 15
  maligned:
    suggest-new: true
  dupl:
    threshold: 100
  goconst:
    min-len: 2
    min-occurrences: 2

linters:
  disable-all: true
  enable:
    - bodyclose
    - deadcode
    - depguard
    - dogsled
    - dupl
    - errcheck
    - funlen
    - gochecknoinits
    - goconst
    - gocritic
    - gocyclo
    - gofmt
    - goimports
    - golint
    - gomnd
    - goprintffuncname
    - gosec
    - gosimple
    - govet
    - ineffassign
    - interfacer
    - lll
    - misspell
    - nakedret
    - rowserrcheck
    - scopelint
    - staticcheck
    - structcheck
    - stylecheck
    - typecheck
    - unconvert
    - unparam
    - unused
    - varcheck
    - whitespace

issues:
  exclude-rules:
    # å¿½ç•¥æµ‹è¯•æ–‡ä»¶çš„æŸäº›æ£€æŸ¥
    - path: _test\.go
      linters:
        - gocyclo
        - errcheck
        - dupl
        - gosec

    # å¿½ç•¥mainå‡½æ•°çš„æŸäº›æ£€æŸ¥
    - path: main\.go
      linters:
        - funlen
        - gocyclo
```

```bash
# å®‰è£…golangci-lint
curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.54.2

# è¿è¡Œæ£€æŸ¥
golangci-lint run

# é…ç½®æ–‡ä»¶
golangci-lint run -c .golangci.yml
```

### æ„å»ºä¸éƒ¨ç½²

#### Makefile
```makefile
# Makefile
.PHONY: build test clean docker-build docker-run lint fmt vet

# å˜é‡å®šä¹‰
APP_NAME := myapp
VERSION := $(shell git describe --tags --always --dirty)
BUILD_TIME := $(shell date +%Y-%m-%dT%H:%M:%S)
GO_VERSION := $(shell go version | awk '{print $$3}')

# æ„å»ºæ ‡å¿—
LDFLAGS := -ldflags "-X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GoVersion=$(GO_VERSION)"

# é»˜è®¤ç›®æ ‡
all: fmt vet lint test build

# ä»£ç æ ¼å¼åŒ–
fmt:
	go fmt ./...
	goimports -w .

# é™æ€åˆ†æ
vet:
	go vet ./...

# ä»£ç æ£€æŸ¥
lint:
	golangci-lint run

# è¿è¡Œæµ‹è¯•
test:
	go test -v -race -coverprofile=coverage.out ./...

# æŸ¥çœ‹æµ‹è¯•è¦†ç›–ç‡
coverage: test
	go tool cover -html=coverage.out -o coverage.html

# æ„å»º
build:
	CGO_ENABLED=0 GOOS=linux go build $(LDFLAGS) -o bin/$(APP_NAME) ./cmd/server

# äº¤å‰ç¼–è¯‘
build-all:
	CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build $(LDFLAGS) -o bin/$(APP_NAME)-linux-amd64 ./cmd/server
	CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build $(LDFLAGS) -o bin/$(APP_NAME)-darwin-amd64 ./cmd/server
	CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build $(LDFLAGS) -o bin/$(APP_NAME)-windows-amd64.exe ./cmd/server

# Dockeræ„å»º
docker-build:
	docker build -t $(APP_NAME):$(VERSION) .
	docker tag $(APP_NAME):$(VERSION) $(APP_NAME):latest

# Dockerè¿è¡Œ
docker-run:
	docker run -p 8080:8080 $(APP_NAME):latest

# æ¸…ç†
clean:
	rm -rf bin/
	rm -f coverage.out coverage.html

# å®‰è£…å·¥å…·
install-tools:
	go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
	go install golang.org/x/tools/cmd/goimports@latest
	go install github.com/securecodewarrior/scc@latest

# ä»£ç ç»Ÿè®¡
stats:
	scc .

# ä¾èµ–ç®¡ç†
deps-update:
	go get -u ./...
	go mod tidy

deps-verify:
	go mod verify

# å®‰å…¨æ‰«æ
security:
	gosec ./...

# æ€§èƒ½åˆ†æ
pprof:
	go tool pprof http://localhost:8080/debug/pprof/profile

# åŸºå‡†æµ‹è¯•
bench:
	go test -bench=. -benchmem ./...
```

#### Dockerfile
```dockerfile
# å¤šé˜¶æ®µæ„å»º
FROM golang:1.21-alpine AS builder

# å®‰è£…å¿…è¦å·¥å…·
RUN apk add --no-cache git ca-certificates tzdata

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY go.mod go.sum ./

# ä¸‹è½½ä¾èµ–
RUN go mod download

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºåº”ç”¨
RUN CGO_ENABLED=0 GOOS=linux go build \
    -ldflags='-w -s -extldflags "-static"' \
    -a -installsuffix cgo \
    -o main .

# æœ€ç»ˆé•œåƒ
FROM scratch

# ä»builderé˜¶æ®µå¤åˆ¶æ—¶åŒºä¿¡æ¯å’ŒCAè¯ä¹¦
COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# å¤åˆ¶åº”ç”¨
COPY --from=builder /app/main /main

# è®¾ç½®æ—¶åŒº
ENV TZ=Asia/Shanghai

# æš´éœ²ç«¯å£
EXPOSE 8080

# è¿è¡Œåº”ç”¨
ENTRYPOINT ["/main"]
```

#### GitHub Actions CI/CD
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  GO_VERSION: '1.21'

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Install dependencies
      run: go mod download

    - name: Run tests
      run: make test

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-umbrella

  lint:
    name: Lint
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v3
      with:
        version: latest
        args: --timeout=5m

  security:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Run Gosec Security Scanner
      uses: securecodewarrior/github-action-gosec@master
      with:
        args: '-no-fail -fmt sarif -out results.sarif ./...'

    - name: Upload SARIF file
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: results.sarif

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test, lint, security]

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Build application
      run: make build

    - name: Build Docker image
      run: make docker-build

    - name: Push to registry
      if: github.ref == 'refs/heads/main'
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker push ${{ secrets.DOCKER_REGISTRY }}/myapp:${{ github.sha }}
        docker push ${{ secrets.DOCKER_REGISTRY }}/myapp:latest

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Deploy to production
      run: |
        # éƒ¨ç½²è„šæœ¬
        echo "Deploying to production..."
```

---

## â“ å¸¸è§é—®é¢˜

### Q1: Goè¯­è¨€ä¸­å¦‚ä½•æ­£ç¡®å¤„ç†é”™è¯¯ï¼Ÿ
**A**: Goçš„é”™è¯¯å¤„ç†éµå¾ªæ˜¾å¼åŸåˆ™ï¼š
- **æ€»æ˜¯æ£€æŸ¥é”™è¯¯**: ä¸è¦å¿½ç•¥è¿”å›çš„é”™è¯¯
- **åŒ…è£…é”™è¯¯**: ä½¿ç”¨`fmt.Errorf`å’Œ`%w`åŠ¨è¯åŒ…è£…é”™è¯¯ï¼Œä¿ç•™é”™è¯¯é“¾
- **å®šä¹‰é”™è¯¯ç±»å‹**: åˆ›å»ºè‡ªå®šä¹‰é”™è¯¯ç±»å‹æä¾›æ›´å¤šä¸Šä¸‹æ–‡
- **é”™è¯¯æ¢å¤**: ä½¿ç”¨é‡è¯•ã€æ–­è·¯å™¨ç­‰æ¨¡å¼å¤„ç†å¯æ¢å¤é”™è¯¯

### Q2: ä½•æ—¶åº”è¯¥ä½¿ç”¨æŒ‡é’ˆè€Œä¸æ˜¯å€¼ï¼Ÿ
**A**: æŒ‡é’ˆä½¿ç”¨åœºæ™¯ï¼š
- **éœ€è¦ä¿®æ”¹åŸå§‹å€¼**: å‡½æ•°éœ€è¦ä¿®æ”¹è°ƒç”¨è€…çš„å˜é‡
- **å¤§å¯¹è±¡**: é¿å…å¤åˆ¶å¤§ç»“æ„ä½“
- **å¯é€‰å€¼**: è¡¨ç¤ºå¯èƒ½ä¸ºnilçš„å€¼
- **æ¥å£å®ç°**: æ¥æ”¶è€…ç±»å‹é€‰æ‹©
- **å…±äº«çŠ¶æ€**: å¤šä¸ªåœ°æ–¹éœ€è¦è®¿é—®åŒä¸€ä¸ªå¯¹è±¡

### Q3: å¦‚ä½•ä¼˜åŒ–Goç¨‹åºçš„æ€§èƒ½ï¼Ÿ
**A**: æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š
- **ä½¿ç”¨pprofåˆ†æ**: æ‰¾å‡ºæ€§èƒ½ç“¶é¢ˆ
- **å‡å°‘å†…å­˜åˆ†é…**: ä½¿ç”¨å¯¹è±¡æ± ã€é¢„åˆ†é…åˆ‡ç‰‡
- **ä¼˜åŒ–å¹¶å‘**: åˆç†ä½¿ç”¨goroutineå’Œchannel
- **æ•°æ®åº“ä¼˜åŒ–**: ä½¿ç”¨è¿æ¥æ± ã€æ‰¹é‡æ“ä½œ
- **é¿å…ä¸å¿…è¦çš„ç±»å‹è½¬æ¢**: å‡å°‘è¿è¡Œæ—¶å¼€é”€

### Q4: Goçš„åƒåœ¾å›æ”¶æœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ
**A**: Go GCç‰¹ç‚¹ï¼š
- **å¹¶å‘æ ‡è®°æ¸…é™¤**: GCä¸åº”ç”¨ç¨‹åºå¹¶å‘æ‰§è¡Œ
- **åˆ†ä»£æ”¶é›†**: ä¼˜å…ˆå›æ”¶å¹´è½»å¯¹è±¡
- **å¯è°ƒå‚æ•°**: å¯ä»¥é€šè¿‡GOGCè°ƒæ•´GCæ¿€è¿›ç¨‹åº¦
- **ä½å»¶è¿Ÿ**: é€‚åˆå»¶è¿Ÿæ•æ„Ÿçš„åº”ç”¨

### Q5: å¦‚ä½•é¿å…goroutineæ³„æ¼ï¼Ÿ
**A**: é¿å…goroutineæ³„æ¼çš„æ–¹æ³•ï¼š
- **ä½¿ç”¨context**: æä¾›å–æ¶ˆæœºåˆ¶
- **æ­£ç¡®å…³é—­channel**: ç¡®ä¿æ¥æ”¶æ–¹èƒ½é€€å‡º
- **ä½¿ç”¨sync.WaitGroup**: ç­‰å¾…goroutineå®Œæˆ
- **ç›‘æ§goroutineæ•°é‡**: ä½¿ç”¨runtimeç»Ÿè®¡ä¿¡æ¯

### Q6: Goæ¨¡å—çš„æœ€ä½³å®è·µæ˜¯ä»€ä¹ˆï¼Ÿ
**A**: Goæ¨¡å—æœ€ä½³å®è·µï¼š
- **è¯­ä¹‰åŒ–ç‰ˆæœ¬**: éµå¾ªv2+ç‰ˆæœ¬çº¦å®š
- **æœ€å°ä¾èµ–**: åªä¾èµ–çœŸæ­£éœ€è¦çš„åŒ…
- **å›ºå®šç‰ˆæœ¬**: åœ¨ç”Ÿäº§ç¯å¢ƒä¸­å›ºå®šä¾èµ–ç‰ˆæœ¬
- **å®šæœŸæ›´æ–°**: å®šæœŸæ›´æ–°ä¾èµ–è·å¾—å®‰å…¨ä¿®å¤

---

## ğŸ”— ç›¸å…³èµ„æº

### ğŸ“– å®˜æ–¹èµ„æº
- **Goå®˜æ–¹æ–‡æ¡£**: [go.dev/doc](https://go.dev/doc) - æœ€æƒå¨çš„Goè¯­è¨€æ–‡æ¡£
- **Goåšå®¢**: [go.dev/blog](https://go.dev/blog) - Goè¯­è¨€æœ€ä½³å®è·µå’Œè®¾è®¡ç†å¿µ
- **Effective Go**: [go.dev/doc/effective_go](https://go.dev/doc/effective_go) - Goè¯­è¨€ç¼–ç¨‹æŒ‡å—

### ğŸ› ï¸ å·¥å…·å’Œåº“
- **golangci-lint**: [github.com/golangci/golangci-lint](https://github.com/golangci/golangci-lint) - Goä»£ç æ£€æŸ¥å·¥å…·
- **testify**: [github.com/stretchr/testify](https://github.com/stretchr/testify) - æµ‹è¯•å·¥å…·åº“
- **Wire**: [github.com/google/wire](https://github.com/google/wire) - ä¾èµ–æ³¨å…¥å·¥å…·
- **pprof**: [pkg.go.dev/runtime/pprof](https://pkg.go.dev/runtime/pprof) - æ€§èƒ½åˆ†æå·¥å…·

### ğŸ“¹ å­¦ä¹ èµ„æº
- **Goè¯­è¨€ä¹‹æ—…**: [tour.go-zh.org](https://tour.go-zh.org) - äº¤äº’å¼Goæ•™ç¨‹
- **Go by Example**: [gobyexample.com](https://gobyexample.com) - å®ä¾‹é©±åŠ¨å­¦ä¹ 
- **Goè¯­è¨€è®¾è®¡ä¸å®ç°**: [draveness.me/golang](https://draveness.me/golang) - æ·±å…¥ç†è§£Goè¯­è¨€

### ğŸš€ è¿›é˜¶ä¸»é¢˜
- **Goå¹¶å‘ç¼–ç¨‹**: [blog.golang.org/concurrency-is-not-parallelism](https://blog.golang.org/concurrency-is-not-parallelism)
- **Goæ€§èƒ½ä¼˜åŒ–**: [go.dev/doc/diagnostics](https://go.dev/doc/diagnostics)
- **Goå†…å­˜ç®¡ç†**: [go.dev/doc/gc](https://go.dev/doc/gc)

---

## ğŸ¯ ç»ƒä¹ ä¸å®è·µ

### ç»ƒä¹ ä¸€ï¼šé‡æ„é—ç•™ä»£ç 
**ç›®æ ‡**: åº”ç”¨Goç¼–ç¨‹æœ€ä½³å®è·µé‡æ„ä»£ç 

**ä»»åŠ¡è¦æ±‚**:
1. æ‰¾åˆ°ä¸€ä¸ªåŒ…å«é‡å¤ä»£ç ã€è¿‡é•¿å‡½æ•°ã€ç¼ºä¹é”™è¯¯å¤„ç†çš„Goä»£ç 
2. åº”ç”¨å•ä¸€èŒè´£åŸåˆ™æ‹†åˆ†å‡½æ•°
3. æ·»åŠ é€‚å½“çš„é”™è¯¯å¤„ç†
4. ä½¿ç”¨æ¥å£æé«˜ä»£ç å¯æµ‹è¯•æ€§
5. æ·»åŠ å•å…ƒæµ‹è¯•

**è¯„ä¼°æ ‡å‡†**:
- [ ] ä»£ç ç»“æ„æ¸…æ™°ï¼ŒèŒè´£åˆ†ç¦»
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] æ¥å£è®¾è®¡åˆç†
- [ ] æµ‹è¯•è¦†ç›–ç‡è¾¾æ ‡

### ç»ƒä¹ äºŒï¼šå¹¶å‘ç¼–ç¨‹å®è·µ
**ç›®æ ‡**: æŒæ¡Goå¹¶å‘ç¼–ç¨‹æ¨¡å¼

**ä»»åŠ¡è¦æ±‚**:
1. å®ç°ä¸€ä¸ªworker poolæ¨¡å¼å¤„ç†ä»»åŠ¡
2. ä½¿ç”¨contextå®ç°è¶…æ—¶æ§åˆ¶
3. å®ç°ä¼˜é›…å…³é—­æœºåˆ¶
4. æ·»åŠ æ€§èƒ½ç›‘æ§å’ŒæŒ‡æ ‡

**è¯„ä¼°æ ‡å‡†**:
- [ ] å¹¶å‘å®‰å…¨
- [ ] èµ„æºæ³„æ¼æ§åˆ¶
- [ ] æ€§èƒ½è¡¨ç°è‰¯å¥½
- [ ] é”™è¯¯å¤„ç†å®Œå–„

### ç»ƒä¹ ä¸‰ï¼šæ€§èƒ½ä¼˜åŒ–é¡¹ç›®
**ç›®æ ‡**: ä¼˜åŒ–Goç¨‹åºæ€§èƒ½

**ä»»åŠ¡è¦æ±‚**:
1. ä½¿ç”¨pprofåˆ†ææ€§èƒ½ç“¶é¢ˆ
2. ä¼˜åŒ–å†…å­˜åˆ†é…
3. ä¼˜åŒ–å¹¶å‘å¤„ç†
4. éªŒè¯ä¼˜åŒ–æ•ˆæœ

**è¯„ä¼°æ ‡å‡†**:
- [ ] æ€§èƒ½æå‡æ˜æ˜¾
- [ ] å†…å­˜ä½¿ç”¨ä¼˜åŒ–
- [ ] ä»£ç å¯è¯»æ€§ä¿æŒ
- [ ] ä¼˜åŒ–æ–¹æ¡ˆåˆç†

### ç»ƒä¹ å››ï¼šå·¥å…·é“¾é…ç½®
**ç›®æ ‡**: å»ºç«‹å®Œæ•´çš„Goå·¥ç¨‹åŒ–å·¥å…·é“¾

**ä»»åŠ¡è¦æ±‚**:
1. é…ç½®golangci-lint
2. è®¾ç½®GitHub Actions CI/CD
3. é…ç½®Dockerå¤šé˜¶æ®µæ„å»º
4. é›†æˆæµ‹è¯•å’Œéƒ¨ç½²æµç¨‹

**è¯„ä¼°æ ‡å‡†**:
- [ ] CI/CDæµç¨‹å®Œæ•´
- [ ] ä»£ç è´¨é‡æ£€æŸ¥åˆ°ä½
- [ ] æ„å»ºå’Œéƒ¨ç½²è‡ªåŠ¨åŒ–
- [ ] ç›‘æ§å’Œæ—¥å¿—å®Œå–„

---

## ğŸ“Š çŸ¥è¯†å›¾è°±

### å‰ç½®çŸ¥è¯†
```mermaid
graph TD
    A[GoåŸºç¡€è¯­æ³•] --> B[æ•°æ®ç±»å‹å’Œæ§åˆ¶æµç¨‹]
    B --> C[å‡½æ•°å’Œæ–¹æ³•]
    C --> D[æ¥å£å’Œç»“æ„ä½“]
    D --> E[Goç¼–ç¨‹ç²¾å]
```

### å­¦ä¹ è·¯å¾„
```mermaid
graph LR
    F[è®¾è®¡å“²å­¦] --> G[ä»£ç ç»„ç»‡]
    G --> H[æ¥å£è®¾è®¡]
    H --> I[é”™è¯¯å¤„ç†]
    I --> J[å¹¶å‘ç¼–ç¨‹]
    J --> K[æ€§èƒ½ä¼˜åŒ–]
    K --> L[å·¥ç¨‹åŒ–å®è·µ]
```

---

## ğŸ”„ æ–‡æ¡£äº¤å‰å¼•ç”¨

### ç›¸å…³æ–‡æ¡£
- ğŸ“„ **[Goå…³é”®å­—è¯¦è§£]**: [01-go-keywords.md](01-go-keywords.md) - è¯­è¨€åŸºç¡€å…ƒç´ 
- ğŸ“„ **[Goå†…ç½®å‡½æ•°]**: [02-go-built-in-functions.md](02-go-built-in-functions.md) - æ ‡å‡†åº“å‡½æ•°
- ğŸ“„ **[æ•°æ®ç±»å‹è¯¦è§£]**: [04-go-data-types.md](04-go-data-types.md) - ç±»å‹ç³»ç»Ÿæ·±å…¥

### å‚è€ƒç« èŠ‚
- ğŸ“– **[å¹¶å‘ç¼–ç¨‹æ¨¡å¼]**: [å†…éƒ¨é“¾æ¥](#å¹¶å‘ç¼–ç¨‹æ¨¡å¼) - å¹¶å‘æœ€ä½³å®è·µ
- ğŸ“– **[é”™è¯¯å¤„ç†æœ€ä½³å®è·µ]**: [å†…éƒ¨é“¾æ¥](#é”™è¯¯å¤„ç†æœ€ä½³å®è·µ) - é”™è¯¯å¤„ç†æŠ€å·§
- ğŸ“– **[æ€§èƒ½ä¼˜åŒ–æŠ€å·§]**: [å†…éƒ¨é“¾æ¥](#æ€§èƒ½ä¼˜åŒ–æŠ€å·§) - æ€§èƒ½è°ƒä¼˜ç­–ç•¥

---

## ğŸ“ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹å›é¡¾
1. **Goè®¾è®¡å“²å­¦**: ç®€æ´æ€§ã€å¯è¯»æ€§ã€ç»„åˆä¼˜äºç»§æ‰¿
2. **ä»£ç è´¨é‡**: è‰¯å¥½çš„ç»„ç»‡ç»“æ„ã€æ¸…æ™°çš„æ¥å£è®¾è®¡ã€å®Œå–„çš„é”™è¯¯å¤„ç†
3. **å¹¶å‘ç¼–ç¨‹**: åˆç†ä½¿ç”¨goroutineå’Œchannelï¼Œé¿å…èµ„æºæ³„æ¼
4. **æ€§èƒ½ä¼˜åŒ–**: å†…å­˜ç®¡ç†ã€å‡å°‘GCå‹åŠ›ã€å¹¶å‘ä¼˜åŒ–
5. **å·¥ç¨‹åŒ–å®è·µ**: æµ‹è¯•ç­–ç•¥ã€CI/CDæµç¨‹ã€ä»£ç è´¨é‡å·¥å…·

### å­¦ä¹ æˆæœæ£€æŸ¥
- [ ] æ˜¯å¦ç†è§£äº†Goè¯­è¨€çš„è®¾è®¡å“²å­¦ï¼Ÿ
- [ ] æ˜¯å¦èƒ½å¤Ÿç¼–å†™é«˜è´¨é‡çš„Goä»£ç ï¼Ÿ
- [ ] æ˜¯å¦æŒæ¡äº†å¹¶å‘ç¼–ç¨‹çš„æœ€ä½³å®è·µï¼Ÿ
- [ ] æ˜¯å¦èƒ½å¤Ÿè¿›è¡Œæ€§èƒ½è°ƒä¼˜ï¼Ÿ
- [ ] æ˜¯å¦å…·å¤‡äº†ä¼ä¸šçº§Goå¼€å‘èƒ½åŠ›ï¼Ÿ

---

## ğŸ¤ è´¡çŒ®ä¸åé¦ˆ

### å†…å®¹æ”¹è¿›
å¦‚æœä½ å‘ç°æœ¬æ–‡æ¡£æœ‰æ”¹è¿›ç©ºé—´ï¼Œæ¬¢è¿ï¼š
- ğŸ› **æŠ¥å‘Šé—®é¢˜**: åœ¨Issuesä¸­æå‡ºå…·ä½“é—®é¢˜
- ğŸ’¡ **å»ºè®®æ”¹è¿›**: æå‡ºä¿®æ”¹å»ºè®®å’Œè¡¥å……å†…å®¹
- ğŸ“ **å‚ä¸è´¡çŒ®**: æäº¤PRå®Œå–„æ–‡æ¡£å†…å®¹

### å­¦ä¹ åé¦ˆ
åˆ†äº«ä½ çš„å­¦ä¹ ä½“éªŒï¼š
- âœ… **æœ‰ç”¨å†…å®¹**: å“ªäº›éƒ¨åˆ†å¯¹ä½ æœ€æœ‰å¸®åŠ©
- â“ **ç–‘é—®ç‚¹**: å“ªäº›å†…å®¹éœ€è¦è¿›ä¸€æ­¥æ¾„æ¸…
- ğŸ¯ **å»ºè®®**: å¸Œæœ›å¢åŠ ä»€ä¹ˆå†…å®¹

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ | ğŸš§ è¿›è¡Œä¸­ | ğŸ“‹ è®¡åˆ’ä¸­
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ
**ç‰ˆæœ¬**: v1.0.0

---

> ğŸ’¡ **å­¦ä¹ å»ºè®®**:
> - å»ºè®®ç»“åˆå®é™…é¡¹ç›®ç»ƒä¹ è¿™äº›ç¼–ç¨‹æŠ€å·§
> - é‡ç‚¹å…³æ³¨ä»£ç ç»„ç»‡å’Œé”™è¯¯å¤„ç†æ¨¡å¼
> - å¤šä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·æ¥ç†è§£ä»£ç è¡Œä¸º
> - éµå¾ªGoè¯­è¨€çš„è®¾è®¡å“²å­¦ç¼–å†™åœ°é“çš„Goä»£ç 
>
> ğŸ¯ **ä¸‹ä¸€æ­¥**: å®Œæˆæœ¬æ–‡æ¡£å­¦ä¹ åï¼Œå»ºè®®ç»§ç»­å­¦ä¹  [Ginæ¡†æ¶é«˜çº§ç‰¹æ€§](../../frameworks/02-gin-framework-advanced.md) æˆ– [GORMå®Œæ•´å­¦ä¹ ](../../frameworks/03-gorm-orm-complete.md)