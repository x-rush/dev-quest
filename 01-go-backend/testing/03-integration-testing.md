# Goé›†æˆæµ‹è¯•è¯¦è§£

## ğŸ“š æ–‡æ¡£å…ƒæ•°æ®

| å±æ€§ | å†…å®¹ |
|------|------|
| **æ¨¡å—** | `01-go-backend` |
| **åˆ†ç±»** | `testing/quality-assurance` |
| **éš¾åº¦** | â­â­â­ |
| **æ ‡ç­¾** | `#testing` `#integration-testing` `#quality-assurance` `#testing-strategies` |
| **æ›´æ–°æ—¥æœŸ** | `2025å¹´10æœˆ` |
| **ä½œè€…** | Dev Quest Team |
| **çŠ¶æ€** | âœ… å·²å®Œæˆ |

## æ¦‚è¿°
é›†æˆæµ‹è¯•æ˜¯éªŒè¯å¤šä¸ªç»„ä»¶æˆ–ç³»ç»ŸååŒå·¥ä½œæ˜¯å¦æ­£å¸¸çš„é‡è¦æµ‹è¯•æ‰‹æ®µã€‚ä¸å•å…ƒæµ‹è¯•ä¸åŒï¼Œé›†æˆæµ‹è¯•å…³æ³¨çš„æ˜¯ç»„ä»¶ä¹‹é—´çš„äº¤äº’ã€æ•°æ®æµå’Œæ•´ä½“åŠŸèƒ½ã€‚æœ¬æŒ‡å—å°†è¯¦ç»†ä»‹ç»Goè¯­è¨€é›†æˆæµ‹è¯•çš„å„ä¸ªæ–¹é¢ï¼ŒåŒ…æ‹¬æµ‹è¯•ç­–ç•¥ã€å·¥å…·ä½¿ç”¨å’Œæœ€ä½³å®è·µã€‚

## é›†æˆæµ‹è¯•åŸºç¡€

### ä»€ä¹ˆæ˜¯é›†æˆæµ‹è¯•
é›†æˆæµ‹è¯•æ˜¯éªŒè¯å¤šä¸ªç‹¬ç«‹æ¨¡å—ã€æœåŠ¡æˆ–ç³»ç»ŸååŒå·¥ä½œæ˜¯å¦æ­£å¸¸çš„æµ‹è¯•æ–¹æ³•ã€‚å®ƒä»‹äºå•å…ƒæµ‹è¯•å’Œç«¯åˆ°ç«¯æµ‹è¯•ä¹‹é—´ï¼Œä¸»è¦å…³æ³¨ï¼š

- ç»„ä»¶é—´çš„æ¥å£å’Œäº¤äº’
- æ•°æ®æµçš„æ­£ç¡®æ€§
- å¤–éƒ¨ä¾èµ–çš„é›†æˆ
- ä¸šåŠ¡é€»è¾‘çš„ç«¯åˆ°ç«¯éªŒè¯

### é›†æˆæµ‹è¯•çš„é‡è¦æ€§
- **å‘ç°æ¥å£é—®é¢˜**: è¯†åˆ«ç»„ä»¶é—´æ¥å£ä¸åŒ¹é…
- **éªŒè¯é›†æˆç‚¹**: ç¡®ä¿å¤–éƒ¨ä¾èµ–æ­£ç¡®é›†æˆ
- **æµ‹è¯•æ•°æ®æµ**: éªŒè¯æ•°æ®åœ¨ä¸åŒç»„ä»¶é—´çš„ä¼ é€’
- **æ¨¡æ‹ŸçœŸå®ç¯å¢ƒ**: åœ¨æ¥è¿‘ç”Ÿäº§ç¯å¢ƒä¸­æµ‹è¯•

## é›†æˆæµ‹è¯•ç­–ç•¥

### 1. æµ‹è¯•é‡‘å­—å¡”

```
        /\
       /  \
      / E2E \
     /______\
    /        \
   / Integration \
  /______________\
 /                \
/   Unit Tests     \
/__________________\
```

- **å•å…ƒæµ‹è¯• (70%)**: å¿«é€Ÿã€éš”ç¦»çš„æµ‹è¯•
- **é›†æˆæµ‹è¯• (20%)**: ç»„ä»¶é—´äº¤äº’æµ‹è¯•
- **ç«¯åˆ°ç«¯æµ‹è¯• (10%)**: å®Œæ•´ä¸šåŠ¡æµç¨‹æµ‹è¯•

### 2. é›†æˆæµ‹è¯•å±‚æ¬¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ç«¯åˆ°ç«¯æµ‹è¯•                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   æœåŠ¡é›†æˆæµ‹è¯•                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   æ•°æ®åº“é›†æˆæµ‹è¯•                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   APIé›†æˆæµ‹è¯•                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   å•å…ƒæµ‹è¯•                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## æ•°æ®åº“é›†æˆæµ‹è¯•

### ä½¿ç”¨Testcontainer

```go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"testing"
	"time"

	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

type User struct {
	ID        int       `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	CreatedAt time.Time `json:"created_at"`
}

type UserRepository struct {
	db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository {
	return &UserRepository{db: db}
}

func (r *UserRepository) Create(ctx context.Context, user *User) error {
	query := `INSERT INTO users (username, email, created_at) VALUES ($1, $2, $3) RETURNING id`
	return r.db.QueryRowContext(ctx, query, user.Username, user.Email, user.CreatedAt).Scan(&user.ID)
}

func (r *UserRepository) GetByID(ctx context.Context, id int) (*User, error) {
	user := &User{}
	query := `SELECT id, username, email, created_at FROM users WHERE id = $1`
	err := r.db.QueryRowContext(ctx, query, id).Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt)
	return user, err
}

func (r *UserRepository) Update(ctx context.Context, user *User) error {
	query := `UPDATE users SET username = $1, email = $2 WHERE id = $3`
	_, err := r.db.ExecContext(ctx, query, user.Username, user.Email, user.ID)
	return err
}

func (r *UserRepository) Delete(ctx context.Context, id int) error {
	query := `DELETE FROM users WHERE id = $1`
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func TestUserRepositoryIntegration(t *testing.T) {
	ctx := context.Background()

	// åˆ›å»ºPostgreSQLå®¹å™¨
	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:15-alpine"),
		postgres.WithDatabase("testdb"),
		postgres.WithUsername("testuser"),
		postgres.WithPassword("testpass"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).
				WithStartupTimeout(5*time.Second),
		),
	)
	if err != nil {
		t.Fatalf("Failed to start PostgreSQL container: %v", err)
	}
	defer pgContainer.Terminate(ctx)

	// è·å–æ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²
	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		t.Fatalf("Failed to get connection string: %v", err)
	}

	// è¿æ¥æ•°æ®åº“
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		t.Fatalf("Failed to connect to database: %v", err)
	}
	defer db.Close()

	// åˆ›å»ºè¡¨
	_, err = db.ExecContext(ctx, `
		CREATE TABLE IF NOT EXISTS users (
			id SERIAL PRIMARY KEY,
			username VARCHAR(50) NOT NULL UNIQUE,
			email VARCHAR(100) NOT NULL UNIQUE,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create table: %v", err)
	}

	// åˆ›å»ºç”¨æˆ·ä»“åº“
	repo := NewUserRepository(db)

	// æµ‹è¯•åˆ›å»ºç”¨æˆ·
	t.Run("CreateUser", func(t *testing.T) {
		user := &User{
			Username:  "testuser",
			Email:     "test@example.com",
			CreatedAt: time.Now(),
		}

		err := repo.Create(ctx, user)
		if err != nil {
			t.Errorf("Failed to create user: %v", err)
		}

		if user.ID == 0 {
			t.Error("User ID should not be zero")
		}
	})

	// æµ‹è¯•è·å–ç”¨æˆ·
	t.Run("GetUser", func(t *testing.T) {
		user := &User{
			Username:  "getuser",
			Email:     "get@example.com",
			CreatedAt: time.Now(),
		}

		// å…ˆåˆ›å»ºç”¨æˆ·
		err := repo.Create(ctx, user)
		if err != nil {
			t.Fatalf("Failed to create user: %v", err)
		}

		// è·å–ç”¨æˆ·
		retrieved, err := repo.GetByID(ctx, user.ID)
		if err != nil {
			t.Errorf("Failed to get user: %v", err)
		}

		if retrieved.Username != user.Username {
			t.Errorf("Expected username %s, got %s", user.Username, retrieved.Username)
		}

		if retrieved.Email != user.Email {
			t.Errorf("Expected email %s, got %s", user.Email, retrieved.Email)
		}
	})

	// æµ‹è¯•æ›´æ–°ç”¨æˆ·
	t.Run("UpdateUser", func(t *testing.T) {
		user := &User{
			Username:  "updateuser",
			Email:     "update@example.com",
			CreatedAt: time.Now(),
		}

		// å…ˆåˆ›å»ºç”¨æˆ·
		err := repo.Create(ctx, user)
		if err != nil {
			t.Fatalf("Failed to create user: %v", err)
		}

		// æ›´æ–°ç”¨æˆ·
		user.Username = "updateduser"
		user.Email = "updated@example.com"

		err = repo.Update(ctx, user)
		if err != nil {
			t.Errorf("Failed to update user: %v", err)
		}

		// éªŒè¯æ›´æ–°
		retrieved, err := repo.GetByID(ctx, user.ID)
		if err != nil {
			t.Errorf("Failed to get updated user: %v", err)
		}

		if retrieved.Username != "updateduser" {
			t.Errorf("Expected updated username %s, got %s", "updateduser", retrieved.Username)
		}
	})

	// æµ‹è¯•åˆ é™¤ç”¨æˆ·
	t.Run("DeleteUser", func(t *testing.T) {
		user := &User{
			Username:  "deleteuser",
			Email:     "delete@example.com",
			CreatedAt: time.Now(),
		}

		// å…ˆåˆ›å»ºç”¨æˆ·
		err := repo.Create(ctx, user)
		if err != nil {
			t.Fatalf("Failed to create user: %v", err)
		}

		// åˆ é™¤ç”¨æˆ·
		err = repo.Delete(ctx, user.ID)
		if err != nil {
			t.Errorf("Failed to delete user: %v", err)
		}

		// éªŒè¯åˆ é™¤
		_, err = repo.GetByID(ctx, user.ID)
		if err == nil {
			t.Error("Expected error when getting deleted user")
		}
	})
}
```

### ä½¿ç”¨å†…å­˜æ•°æ®åº“

```go
package database

import (
	"database/sql"
	"testing"
	"time"

	_ "github.com/mattn/go-sqlite3"
)

func TestUserRepositoryWithSQLite(t *testing.T) {
	// ä½¿ç”¨å†…å­˜SQLiteæ•°æ®åº“
	db, err := sql.Open("sqlite3", ":memory:")
	if err != nil {
		t.Fatalf("Failed to open database: %v", err)
	}
	defer db.Close()

	// åˆ›å»ºè¡¨
	_, err = db.Exec(`
		CREATE TABLE users (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			username TEXT NOT NULL UNIQUE,
			email TEXT NOT NULL UNIQUE,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		t.Fatalf("Failed to create table: %v", err)
	}

	repo := NewUserRepository(db)

	// æµ‹è¯•ç”¨ä¾‹
	testCases := []struct {
		name     string
		setup    func() (*User, error)
		test     func(*User) error
		validate func(*User, error)
	}{
		{
			name: "CreateUser",
			setup: func() (*User, error) {
				return &User{
					Username:  "testuser",
					Email:     "test@example.com",
					CreatedAt: time.Now(),
				}, nil
			},
			test: func(user *User) error {
				return repo.Create(context.Background(), user)
			},
			validate: func(user *User, err error) {
				if err != nil {
					t.Errorf("Create user failed: %v", err)
				}
				if user.ID == 0 {
					t.Error("User ID should not be zero")
				}
			},
		},
		{
			name: "GetNonExistentUser",
			setup: func() (*User, error) {
				return nil, nil
			},
			test: func(user *User) error {
				_, err := repo.GetByID(context.Background(), 999)
				return err
			},
			validate: func(user *User, err error) {
				if err == nil {
					t.Error("Expected error when getting non-existent user")
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// æ¯ä¸ªæµ‹è¯•å‰æ¸…ç†æ•°æ®
			_, err := db.Exec("DELETE FROM users")
			if err != nil {
				t.Fatalf("Failed to clean table: %v", err)
			}

			// è®¾ç½®æµ‹è¯•æ•°æ®
			user, err := tc.setup()
			if err != nil {
				t.Fatalf("Setup failed: %v", err)
			}

			// æ‰§è¡Œæµ‹è¯•
			err = tc.test(user)

			// éªŒè¯ç»“æœ
			tc.validate(user, err)
		})
	}
}
```

## APIé›†æˆæµ‹è¯•

### HTTPå®¢æˆ·ç«¯æµ‹è¯•

```go
package api

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

type User struct {
	ID       string `json:"id"`
	Username string `json:"username"`
	Email    string `json:"email"`
}

type UserHandler struct {
	users map[string]*User
}

func NewUserHandler() *UserHandler {
	return &UserHandler{
		users: make(map[string]*User),
	}
}

func (h *UserHandler) CreateUser(c *gin.Context) {
	var user User
	if err := c.ShouldBindJSON(&user); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	user.ID = generateID()
	h.users[user.ID] = user

	c.JSON(http.StatusCreated, user)
}

func (h *UserHandler) GetUser(c *gin.Context) {
	id := c.Param("id")
	user, exists := h.users[id]
	if !exists {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	c.JSON(http.StatusOK, user)
}

func (h *UserHandler) UpdateUser(c *gin.Context) {
	id := c.Param("id")
	user, exists := h.users[id]
	if !exists {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	var updateUser User
	if err := c.ShouldBindJSON(&updateUser); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	user.Username = updateUser.Username
	user.Email = updateUser.Email

	c.JSON(http.StatusOK, user)
}

func (h *UserHandler) DeleteUser(c *gin.Context) {
	id := c.Param("id")
	if _, exists := h.users[id]; !exists {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	delete(h.users, id)
	c.Status(http.StatusNoContent)
}

func (h *UserHandler) ListUsers(c *gin.Context) {
	var users []*User
	for _, user := range h.users {
		users = append(users, user)
	}

	c.JSON(http.StatusOK, users)
}

func TestUserAPIIntegration(t *testing.T) {
	// è®¾ç½®Ginä¸ºæµ‹è¯•æ¨¡å¼
	gin.SetMode(gin.TestMode)

	// åˆ›å»ºç”¨æˆ·å¤„ç†å™¨
	handler := NewUserHandler()

	// åˆ›å»ºè·¯ç”±
	router := gin.Default()
	router.POST("/users", handler.CreateUser)
	router.GET("/users/:id", handler.GetUser)
	router.PUT("/users/:id", handler.UpdateUser)
	router.DELETE("/users/:id", handler.DeleteUser)
	router.GET("/users", handler.ListUsers)

	// æµ‹è¯•åˆ›å»ºç”¨æˆ·
	t.Run("CreateUser", func(t *testing.T) {
		user := User{
			Username: "testuser",
			Email:    "test@example.com",
		}

		jsonData, _ := json.Marshal(user)
		req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonData))
		req.Header.Set("Content-Type", "application/json")

		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusCreated, w.Code)

		var response User
		err := json.Unmarshal(w.Body.Bytes(), &response)
		assert.NoError(t, err)
		assert.NotEmpty(t, response.ID)
		assert.Equal(t, user.Username, response.Username)
		assert.Equal(t, user.Email, response.Email)
	})

	// æµ‹è¯•è·å–ç”¨æˆ·
	t.Run("GetUser", func(t *testing.T) {
		// å…ˆåˆ›å»ºç”¨æˆ·
		user := User{
			Username: "getuser",
			Email:    "get@example.com",
		}

		jsonData, _ := json.Marshal(user)
		req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonData))
		req.Header.Set("Content-Type", "application/json")

		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		var createdUser User
		json.Unmarshal(w.Body.Bytes(), &createdUser)

		// è·å–ç”¨æˆ·
		req, _ = http.NewRequest("GET", "/users/"+createdUser.ID, nil)
		w = httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response User
		err := json.Unmarshal(w.Body.Bytes(), &response)
		assert.NoError(t, err)
		assert.Equal(t, createdUser.ID, response.ID)
		assert.Equal(t, createdUser.Username, response.Username)
		assert.Equal(t, createdUser.Email, response.Email)
	})

	// æµ‹è¯•æ›´æ–°ç”¨æˆ·
	t.Run("UpdateUser", func(t *testing.T) {
		// å…ˆåˆ›å»ºç”¨æˆ·
		user := User{
			Username: "updateuser",
			Email:    "update@example.com",
		}

		jsonData, _ := json.Marshal(user)
		req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonData))
		req.Header.Set("Content-Type", "application/json")

		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		var createdUser User
		json.Unmarshal(w.Body.Bytes(), &createdUser)

		// æ›´æ–°ç”¨æˆ·
		updatedUser := User{
			Username: "updateduser",
			Email:    "updated@example.com",
		}

		jsonData, _ = json.Marshal(updatedUser)
		req, _ = http.NewRequest("PUT", "/users/"+createdUser.ID, bytes.NewBuffer(jsonData))
		req.Header.Set("Content-Type", "application/json")

		w = httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response User
		err := json.Unmarshal(w.Body.Bytes(), &response)
		assert.NoError(t, err)
		assert.Equal(t, "updateduser", response.Username)
		assert.Equal(t, "updated@example.com", response.Email)
	})

	// æµ‹è¯•åˆ é™¤ç”¨æˆ·
	t.Run("DeleteUser", func(t *testing.T) {
		// å…ˆåˆ›å»ºç”¨æˆ·
		user := User{
			Username: "deleteuser",
			Email:    "delete@example.com",
		}

		jsonData, _ := json.Marshal(user)
		req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonData))
		req.Header.Set("Content-Type", "application/json")

		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		var createdUser User
		json.Unmarshal(w.Body.Bytes(), &createdUser)

		// åˆ é™¤ç”¨æˆ·
		req, _ = http.NewRequest("DELETE", "/users/"+createdUser.ID, nil)
		w = httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusNoContent, w.Code)

		// éªŒè¯ç”¨æˆ·å·²åˆ é™¤
		req, _ = http.NewRequest("GET", "/users/"+createdUser.ID, nil)
		w = httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusNotFound, w.Code)
	})

	// æµ‹è¯•ç”¨æˆ·åˆ—è¡¨
	t.Run("ListUsers", func(t *testing.T) {
		// æ¸…ç©ºç”¨æˆ·
		handler.users = make(map[string]*User)

		// åˆ›å»ºå‡ ä¸ªç”¨æˆ·
		users := []User{
			{Username: "user1", Email: "user1@example.com"},
			{Username: "user2", Email: "user2@example.com"},
			{Username: "user3", Email: "user3@example.com"},
		}

		for _, user := range users {
			jsonData, _ := json.Marshal(user)
			req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonData))
			req.Header.Set("Content-Type", "application/json")

			w := httptest.NewRecorder()
			router.ServeHTTP(w, req)
		}

		// è·å–ç”¨æˆ·åˆ—è¡¨
		req, _ := http.NewRequest("GET", "/users", nil)
		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response []User
		err := json.Unmarshal(w.Body.Bytes(), &response)
		assert.NoError(t, err)
		assert.Len(t, response, 3)
	})
}
```

### å¤–éƒ¨APIé›†æˆæµ‹è¯•

```go
package external

import (
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

type Post struct {
	ID     int    `json:"id"`
	Title  string `json:"title"`
	Body   string `json:"body"`
	UserID int   `json:"userId"`
}

type PostService struct {
	baseURL    string
	httpClient *http.Client
}

func NewPostService(baseURL string) *PostService {
	return &PostService{
		baseURL: baseURL,
		httpClient: &http.Client{
			Timeout: 10 * time.Second,
		},
	}
}

func (s *PostService) GetPosts() ([]Post, error) {
	resp, err := s.httpClient.Get(s.baseURL + "/posts")
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var posts []Post
	err = json.Unmarshal(body, &posts)
	if err != nil {
		return nil, err
	}

	return posts, nil
}

func (s *PostService) GetPost(id int) (*Post, error) {
	resp, err := s.httpClient.Get(fmt.Sprintf("%s/posts/%d", s.baseURL, id))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var post Post
	err = json.Unmarshal(body, &post)
	if err != nil {
		return nil, err
	}

	return &post, nil
}

func (s *PostService) CreatePost(post *Post) (*Post, error) {
	jsonData, err := json.Marshal(post)
	if err != nil {
		return nil, err
	}

	resp, err := s.httpClient.Post(s.baseURL+"/posts", "application/json", bytes.NewReader(jsonData))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var createdPost Post
	err = json.Unmarshal(body, &createdPost)
	if err != nil {
		return nil, err
	}

	return &createdPost, nil
}

func TestPostServiceIntegration(t *testing.T) {
	// åˆ›å»ºæ¨¡æ‹Ÿçš„å¤–éƒ¨APIæœåŠ¡å™¨
	mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case "/posts":
			if r.Method == http.MethodGet {
				// è¿”å›å¸–å­åˆ—è¡¨
				posts := []Post{
					{ID: 1, Title: "Post 1", Body: "Body 1", UserID: 1},
					{ID: 2, Title: "Post 2", Body: "Body 2", UserID: 2},
				}
				w.Header().Set("Content-Type", "application/json")
				json.NewEncoder(w).Encode(posts)
			} else if r.Method == http.MethodPost {
				// åˆ›å»ºæ–°å¸–å­
				var post Post
				err := json.NewDecoder(r.Body).Decode(&post)
				if err != nil {
					http.Error(w, err.Error(), http.StatusBadRequest)
					return
				}

				post.ID = 3 // æ¨¡æ‹Ÿåˆ†é…ID
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusCreated)
				json.NewEncoder(w).Encode(post)
			}
		case "/posts/1":
			if r.Method == http.MethodGet {
				// è¿”å›å•ä¸ªå¸–å­
				post := Post{ID: 1, Title: "Post 1", Body: "Body 1", UserID: 1}
				w.Header().Set("Content-Type", "application/json")
				json.NewEncoder(w).Encode(post)
			}
		case "/posts/999":
			// è¿”å›404
			w.WriteHeader(http.StatusNotFound)
		default:
			w.WriteHeader(http.StatusNotFound)
		}
	}))
	defer mockServer.Close()

	// åˆ›å»ºå¸–å­æœåŠ¡
	service := NewPostService(mockServer.URL)

	t.Run("GetPosts", func(t *testing.T) {
		posts, err := service.GetPosts()
		require.NoError(t, err)
		assert.Len(t, posts, 2)
		assert.Equal(t, "Post 1", posts[0].Title)
		assert.Equal(t, "Post 2", posts[1].Title)
	})

	t.Run("GetPost", func(t *testing.T) {
		post, err := service.GetPost(1)
		require.NoError(t, err)
		assert.Equal(t, 1, post.ID)
		assert.Equal(t, "Post 1", post.Title)
		assert.Equal(t, "Body 1", post.Body)
	})

	t.Run("GetNonExistentPost", func(t *testing.T) {
		post, err := service.GetPost(999)
		assert.Error(t, err)
		assert.Nil(t, post)
	})

	t.Run("CreatePost", func(t *testing.T) {
		newPost := &Post{
			Title:  "New Post",
			Body:   "New Body",
			UserID: 1,
		}

		createdPost, err := service.CreatePost(newPost)
		require.NoError(t, err)
		assert.Equal(t, 3, createdPost.ID)
		assert.Equal(t, "New Post", createdPost.Title)
		assert.Equal(t, "New Body", createdPost.Body)
	})

	t.Run("NetworkError", func(t *testing.T) {
		// æµ‹è¯•ç½‘ç»œé”™è¯¯æƒ…å†µ
		service := NewPostService("http://invalid-url")
		_, err := service.GetPosts()
		assert.Error(t, err)
	})
}
```

## æ¶ˆæ¯é˜Ÿåˆ—é›†æˆæµ‹è¯•

### Redisé›†æˆæµ‹è¯•

```go
package queue

import (
	"context"
	"encoding/json"
	"testing"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/redis"
)

type Message struct {
	ID      string      `json:"id"`
	Type    string      `json:"type"`
	Payload interface{} `json:"payload"`
}

type MessageQueue struct {
	client *redis.Client
}

func NewMessageQueue(client *redis.Client) *MessageQueue {
	return &MessageQueue{client: client}
}

func (q *MessageQueue) Publish(ctx context.Context, channel string, message *Message) error {
	data, err := json.Marshal(message)
	if err != nil {
		return err
	}

	return q.client.Publish(ctx, channel, data).Err()
}

func (q *MessageQueue) Subscribe(ctx context.Context, channel string) <-chan *Message {
	msgChan := make(chan *Message, 100)

	go func() {
		defer close(msgChan)

		pubsub := q.client.Subscribe(ctx, channel)
		defer pubsub.Close()

		for {
			select {
			case <-ctx.Done():
				return
			case msg := <-pubsub.Channel():
				var message Message
				if err := json.Unmarshal([]byte(msg.Payload), &message); err != nil {
					continue
				}
				msgChan <- &message
			}
		}
	}()

	return msgChan
}

func TestMessageQueueIntegration(t *testing.T) {
	ctx := context.Background()

	// åˆ›å»ºRediså®¹å™¨
	redisContainer, err := redis.RunContainer(ctx,
		testcontainers.WithImage("redis:7-alpine"),
	)
	require.NoError(t, err)
	defer redisContainer.Terminate(ctx)

	// è·å–Redisè¿æ¥åœ°å€
	redisAddr, err := redisContainer.ConnectionString(ctx)
	require.NoError(t, err)

	// åˆ›å»ºRediså®¢æˆ·ç«¯
	client := redis.NewClient(&redis.Options{
		Addr: redisAddr,
	})

	// æµ‹è¯•è¿æ¥
	_, err = client.Ping(ctx).Result()
	require.NoError(t, err)

	// åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—
	queue := NewMessageQueue(client)

	t.Run("PublishAndSubscribe", func(t *testing.T) {
		channel := "test-channel"
		message := &Message{
			ID:      "123",
			Type:    "test",
			Payload: "test payload",
		}

		// è®¢é˜…é¢‘é“
		msgChan := queue.Subscribe(ctx, channel)

		// å‘å¸ƒæ¶ˆæ¯
		err := queue.Publish(ctx, channel, message)
		require.NoError(t, err)

		// æ¥æ”¶æ¶ˆæ¯
		select {
		case received := <-msgChan:
			assert.Equal(t, message.ID, received.ID)
			assert.Equal(t, message.Type, received.Type)
			assert.Equal(t, message.Payload, received.Payload)
		case <-time.After(5 * time.Second):
			t.Fatal("Timeout waiting for message")
		}
	})

	t.Run("MultipleSubscribers", func(t *testing.T) {
		channel := "multi-channel"
		message := &Message{
			ID:      "456",
			Type:    "broadcast",
			Payload: "broadcast message",
		}

		// åˆ›å»ºå¤šä¸ªè®¢é˜…è€…
		sub1 := queue.Subscribe(ctx, channel)
		sub2 := queue.Subscribe(ctx, channel)
		sub3 := queue.Subscribe(ctx, channel)

		// å‘å¸ƒæ¶ˆæ¯
		err := queue.Publish(ctx, channel, message)
		require.NoError(t, err)

		// æ‰€æœ‰è®¢é˜…è€…éƒ½åº”è¯¥æ”¶åˆ°æ¶ˆæ¯
		received := 0
		timeout := time.After(5 * time.Second)

		for received < 3 {
			select {
			case msg := <-sub1:
				assert.Equal(t, message.ID, msg.ID)
				received++
			case msg := <-sub2:
				assert.Equal(t, message.ID, msg.ID)
				received++
			case msg := <-sub3:
				assert.Equal(t, message.ID, msg.ID)
				received++
			case <-timeout:
				t.Fatal("Timeout waiting for messages")
			}
		}

		assert.Equal(t, 3, received)
	})

	t.Run("MultipleChannels", func(t *testing.T) {
		channels := []string{"channel1", "channel2", "channel3"}
		messages := []*Message{
			{ID: "1", Type: "type1", Payload: "payload1"},
			{ID: "2", Type: "type2", Payload: "payload2"},
			{ID: "3", Type: "type3", Payload: "payload3"},
		}

		// è®¢é˜…ä¸åŒé¢‘é“
		subs := make([]<-chan *Message, len(channels))
		for i, channel := range channels {
			subs[i] = queue.Subscribe(ctx, channel)
		}

		// å‘å¸ƒæ¶ˆæ¯åˆ°ä¸åŒé¢‘é“
		for i, channel := range channels {
			err := queue.Publish(ctx, channel, messages[i])
			require.NoError(t, err)
		}

		// éªŒè¯æ¯ä¸ªé¢‘é“çš„æ¶ˆæ¯
		for i, sub := range subs {
			select {
			case msg := <-sub:
				assert.Equal(t, messages[i].ID, msg.ID)
				assert.Equal(t, messages[i].Type, msg.Type)
			case <-time.After(5 * time.Second):
				t.Fatalf("Timeout waiting for message on channel %s", channels[i])
			}
		}
	})
}
```

## æœåŠ¡é›†æˆæµ‹è¯•

### å¾®æœåŠ¡é›†æˆæµ‹è¯•

```go
package service

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// UserService ç”¨æˆ·æœåŠ¡
type UserService struct {
	users map[string]*User
}

func NewUserService() *UserService {
	return &UserService{
		users: map[string]*User{
			"1": {ID: "1", Name: "User 1", Email: "user1@example.com"},
			"2": {ID: "2", Name: "User 2", Email: "user2@example.com"},
		},
	}
}

func (s *UserService) GetUser(id string) (*User, error) {
	user, exists := s.users[id]
	if !exists {
		return nil, fmt.Errorf("user not found")
	}
	return user, nil
}

func (s *UserService) GetUsers() ([]*User, error) {
	var users []*User
	for _, user := range s.users {
		users = append(users, user)
	}
	return users, nil
}

// OrderService è®¢å•æœåŠ¡
type OrderService struct {
	orders map[string]*Order
}

func NewOrderService() *OrderService {
	return &OrderService{
		orders: map[string]*Order{
			"1": {ID: "1", UserID: "1", Product: "Product 1", Amount: 100.0},
			"2": {ID: "2", UserID: "2", Product: "Product 2", Amount: 200.0},
		},
	}
}

func (s *OrderService) GetOrder(id string) (*Order, error) {
	order, exists := s.orders[id]
	if !exists {
		return nil, fmt.Errorf("order not found")
	}
	return order, nil
}

func (s *OrderService) GetOrdersByUser(userID string) ([]*Order, error) {
	var orders []*Order
	for _, order := range s.orders {
		if order.UserID == userID {
			orders = append(orders, order)
		}
	}
	return orders, nil
}

// APIService APIç½‘å…³æœåŠ¡
type APIService struct {
	userService  *UserService
	orderService *OrderService
}

func NewAPIService(userService *UserService, orderService *OrderService) *APIService {
	return &APIService{
		userService:  userService,
		orderService: orderService,
	}
}

func (s *APIService) GetUserWithOrders(c *gin.Context) {
	userID := c.Param("userID")

	// è·å–ç”¨æˆ·ä¿¡æ¯
	user, err := s.userService.GetUser(userID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// è·å–ç”¨æˆ·è®¢å•
	orders, err := s.orderService.GetOrdersByUser(userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get orders"})
		return
	}

	// ç»„åˆå“åº”
	response := gin.H{
		"user":   user,
		"orders": orders,
	}

	c.JSON(http.StatusOK, response)
}

func TestAPIServiceIntegration(t *testing.T) {
	// è®¾ç½®Ginä¸ºæµ‹è¯•æ¨¡å¼
	gin.SetMode(gin.TestMode)

	// åˆ›å»ºæœåŠ¡
	userService := NewUserService()
	orderService := NewOrderService()
	apiService := NewAPIService(userService, orderService)

	// åˆ›å»ºè·¯ç”±
	router := gin.Default()
	router.GET("/users/:userID/orders", apiService.GetUserWithOrders)

	// æµ‹è¯•è·å–ç”¨æˆ·åŠå…¶è®¢å•
	t.Run("GetUserWithOrders", func(t *testing.T) {
		// æµ‹è¯•å­˜åœ¨çš„ç”¨æˆ·
		req, _ := http.NewRequest("GET", "/users/1/orders", nil)
		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		// éªŒè¯ç”¨æˆ·ä¿¡æ¯
		user, ok := response["user"].(map[string]interface{})
		assert.True(t, ok)
		assert.Equal(t, "1", user["id"])
		assert.Equal(t, "User 1", user["name"])

		// éªŒè¯è®¢å•ä¿¡æ¯
		orders, ok := response["orders"].([]interface{})
		assert.True(t, ok)
		assert.Len(t, orders, 1)

		order := orders[0].(map[string]interface{})
		assert.Equal(t, "1", order["id"])
		assert.Equal(t, "Product 1", order["product"])
	})

	t.Run("GetUserWithNoOrders", func(t *testing.T) {
		// æµ‹è¯•æ²¡æœ‰è®¢å•çš„ç”¨æˆ·
		req, _ := http.NewRequest("GET", "/users/2/orders", nil)
		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		// éªŒè¯ç”¨æˆ·ä¿¡æ¯
		user, ok := response["user"].(map[string]interface{})
		assert.True(t, ok)
		assert.Equal(t, "2", user["id"])
		assert.Equal(t, "User 2", user["name"])

		// éªŒè¯è®¢å•ä¿¡æ¯ï¼ˆåº”è¯¥ä¸ºç©ºï¼‰
		orders, ok := response["orders"].([]interface{})
		assert.True(t, ok)
		assert.Len(t, orders, 0)
	})

	t.Run("GetNonExistentUser", func(t *testing.T) {
		// æµ‹è¯•ä¸å­˜åœ¨çš„ç”¨æˆ·
		req, _ := http.NewRequest("GET", "/users/999/orders", nil)
		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusNotFound, w.Code)

		var response map[string]interface{}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Contains(t, response, "error")
	})
}
```

## æµ‹è¯•å·¥å…·å’Œè¾…åŠ©å‡½æ•°

### æµ‹è¯•è¾…åŠ©å‡½æ•°

```go
package testutils

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// HTTPTestHelper HTTPæµ‹è¯•è¾…åŠ©ç»“æ„
type HTTPTestHelper struct {
	router *gin.Engine
	t      *testing.T
}

func NewHTTPTestHelper(router *gin.Engine, t *testing.T) *HTTPTestHelper {
	return &HTTPTestHelper{
		router: router,
		t:      t,
	}
}

// Request å‘é€HTTPè¯·æ±‚å¹¶è¿”å›å“åº”
func (h *HTTPTestHelper) Request(method, url string, body interface{}, headers map[string]string) *httptest.ResponseRecorder {
	var bodyBytes []byte
	if body != nil {
		var err error
		bodyBytes, err = json.Marshal(body)
		require.NoError(h.t, err)
	}

	req, err := http.NewRequest(method, url, bytes.NewBuffer(bodyBytes))
	require.NoError(h.t, err)

	// è®¾ç½®è¯·æ±‚å¤´
	req.Header.Set("Content-Type", "application/json")
	for key, value := range headers {
		req.Header.Set(key, value)
	}

	w := httptest.NewRecorder()
	h.router.ServeHTTP(w, req)

	return w
}

// AssertStatus æ–­è¨€HTTPçŠ¶æ€ç 
func (h *HTTPTestHelper) AssertStatus(w *httptest.ResponseRecorder, expectedStatus int) {
	assert.Equal(h.t, expectedStatus, w.Code)
}

// AssertJSONResponse æ–­è¨€JSONå“åº”
func (h *HTTPTestHelper) AssertJSONResponse(w *httptest.ResponseRecorder, target interface{}) {
	require.NoError(h.t, json.Unmarshal(w.Body.Bytes(), target))
}

// AssertErrorMessage æ–­è¨€é”™è¯¯æ¶ˆæ¯
func (h *HTTPTestHelper) AssertErrorMessage(w *httptest.ResponseRecorder, expectedMessage string) {
	var response map[string]interface{}
	require.NoError(h.t, json.Unmarshal(w.Body.Bytes(), &response))
	assert.Contains(h.t, response, "error")
	assert.Equal(h.t, expectedMessage, response["error"])
}

// ä½¿ç”¨ç¤ºä¾‹
func TestUserAPIWithHelper(t *testing.T) {
	router := setupRouter()
	helper := NewHTTPTestHelper(router, t)

	t.Run("CreateUser", func(t *testing.T) {
		user := map[string]interface{}{
			"username": "testuser",
			"email":    "test@example.com",
		}

		w := helper.Request("POST", "/users", user, nil)
		helper.AssertStatus(w, http.StatusCreated)

		var response map[string]interface{}
		helper.AssertJSONResponse(w, &response)
		assert.NotEmpty(t, response["id"])
		assert.Equal(t, user["username"], response["username"])
	})
}
```

### æ•°æ®åº“æµ‹è¯•è¾…åŠ©å‡½æ•°

```go
package testutils

import (
	"context"
	"database/sql"
	"fmt"
	"testing"
	"time"

	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

// DatabaseTestHelper æ•°æ®åº“æµ‹è¯•è¾…åŠ©ç»“æ„
type DatabaseTestHelper struct {
	db      *sql.DB
	cleanup func()
}

// NewTestDatabase åˆ›å»ºæµ‹è¯•æ•°æ®åº“
func NewTestDatabase(t *testing.T) *DatabaseTestHelper {
	ctx := context.Background()

	// åˆ›å»ºPostgreSQLå®¹å™¨
	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:15-alpine"),
		postgres.WithDatabase("testdb"),
		postgres.WithUsername("testuser"),
		postgres.WithPassword("testpass"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).
				WithStartupTimeout(5*time.Second),
		),
	)
	require.NoError(t, err)

	// è·å–è¿æ¥å­—ç¬¦ä¸²
	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	require.NoError(t, err)

	// è¿æ¥æ•°æ®åº“
	db, err := sql.Open("postgres", connStr)
	require.NoError(t, err)

	return &DatabaseTestHelper{
		db: db,
		cleanup: func() {
			db.Close()
			pgContainer.Terminate(ctx)
		},
	}
}

// DB è·å–æ•°æ®åº“è¿æ¥
func (h *DatabaseTestHelper) DB() *sql.DB {
	return h.db
}

// Cleanup æ¸…ç†èµ„æº
func (h *DatabaseTestHelper) Cleanup() {
	h.cleanup()
}

// CreateUsersTable åˆ›å»ºç”¨æˆ·è¡¨
func (h *DatabaseTestHelper) CreateUsersTable() error {
	_, err := h.db.Exec(`
		CREATE TABLE IF NOT EXISTS users (
			id SERIAL PRIMARY KEY,
			username VARCHAR(50) NOT NULL UNIQUE,
			email VARCHAR(100) NOT NULL UNIQUE,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		)
	`)
	return err
}

// TruncateTable æ¸…ç©ºè¡¨æ•°æ®
func (h *DatabaseTestHelper) TruncateTable(tableName string) error {
	_, err := h.db.Exec(fmt.Sprintf("TRUNCATE TABLE %s CASCADE", tableName))
	return err
}

// InsertTestData æ’å…¥æµ‹è¯•æ•°æ®
func (h *DatabaseTestHelper) InsertTestData() error {
	users := []struct {
		username string
		email    string
	}{
		{"user1", "user1@example.com"},
		{"user2", "user2@example.com"},
		{"user3", "user3@example.com"},
	}

	for _, user := range users {
		_, err := h.db.Exec(
			"INSERT INTO users (username, email) VALUES ($1, $2)",
			user.username, user.email,
		)
		if err != nil {
			return err
		}
	}

	return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func TestUserRepositoryWithHelper(t *testing.T) {
	dbHelper := NewTestDatabase(t)
	defer dbHelper.Cleanup()

	// åˆ›å»ºè¡¨
	err := dbHelper.CreateUsersTable()
	require.NoError(t, err)

	// æ’å…¥æµ‹è¯•æ•°æ®
	err = dbHelper.InsertTestData()
	require.NoError(t, err)

	repo := NewUserRepository(dbHelper.DB())

	// æµ‹è¯•ç”¨ä¾‹
	t.Run("GetUser", func(t *testing.T) {
		user, err := repo.GetByID(context.Background(), 1)
		require.NoError(t, err)
		assert.Equal(t, "user1", user.Username)
	})
}
```

## é›†æˆæµ‹è¯•æœ€ä½³å®è·µ

### 1. æµ‹è¯•ç¯å¢ƒç®¡ç†

**ä½¿ç”¨Testcontainers**
```go
// æ¨èä½¿ç”¨Testcontainersè¿›è¡Œé›†æˆæµ‹è¯•
func TestWithRealDatabase(t *testing.T) {
    // è‡ªåŠ¨åˆ›å»ºå’Œç®¡ç†å®¹å™¨
    container := setupTestContainer(t)
    defer container.Cleanup()

    // æ‰§è¡Œæµ‹è¯•
    runTests(t, container)
}
```

**ç¯å¢ƒå˜é‡é…ç½®**
```go
func TestWithEnvironment(t *testing.T) {
    // è®¾ç½®æµ‹è¯•ç¯å¢ƒå˜é‡
    os.Setenv("TEST_MODE", "true")
    defer os.Setenv("TEST_MODE", "")

    // æ‰§è¡Œæµ‹è¯•
    runTests(t)
}
```

### 2. æµ‹è¯•æ•°æ®ç®¡ç†

**ä½¿ç”¨å·¥å‚æ¨¡å¼åˆ›å»ºæµ‹è¯•æ•°æ®**
```go
// testdata/factory.go
package testdata

type UserFactory struct {
	baseUser *User
}

func NewUserFactory() *UserFactory {
	return &UserFactory{
		baseUser: &User{
			Username: "testuser",
			Email:    "test@example.com",
			IsActive: true,
		},
	}
}

func (f *UserFactory) Create(overrides ...func(*User)) *User {
	user := &User{
		Username: f.baseUser.Username,
		Email:    f.baseUser.Email,
		IsActive: f.baseUser.IsActive,
	}

	for _, override := range overrides {
		override(user)
	}

	return user
}

// ä½¿ç”¨ç¤ºä¾‹
func TestUserCreation(t *testing.T) {
	factory := NewUserFactory()

	// åˆ›å»ºé»˜è®¤ç”¨æˆ·
	user := factory.Create()

	// åˆ›å»ºè‡ªå®šä¹‰ç”¨æˆ·
	adminUser := factory.Create(func(u *User) {
		u.Username = "admin"
		u.Email = "admin@example.com"
		u.IsActive = true
	})
}
```

### 3. å¼‚æ­¥æµ‹è¯•å¤„ç†

**å¤„ç†å¼‚æ­¥æ“ä½œ**
```go
func TestAsyncOperation(t *testing.T) {
	// å¯åŠ¨å¼‚æ­¥æ“ä½œ
	go asyncOperation()

	// ç­‰å¾…æ“ä½œå®Œæˆ
	assert.Eventually(t, func() bool {
		return checkOperationComplete()
	}, 5*time.Second, 100*time.Millisecond, "Operation should complete")
}
```

### 4. æµ‹è¯•æ€§èƒ½è€ƒè™‘

**è®¾ç½®åˆç†çš„è¶…æ—¶**
```go
func TestWithTimeout(t *testing.T) {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// æ‰§è¡Œæµ‹è¯•
	err := performOperation(ctx)
	assert.NoError(t, err)
}
```

### 5. æµ‹è¯•éš”ç¦»å’Œæ¸…ç†

**ç¡®ä¿æµ‹è¯•éš”ç¦»**
```go
func TestWithCleanup(t *testing.T) {
	// æ¯ä¸ªæµ‹è¯•å‰æ¸…ç†
	cleanupDatabase()

	// æ‰§è¡Œæµ‹è¯•
	t.Run("Test1", func(t *testing.T) {
		// æµ‹è¯•ä»£ç 
	})

	t.Run("Test2", func(t *testing.T) {
		// æµ‹è¯•ä»£ç 
	})
}
```

## é›†æˆæµ‹è¯•ç­–ç•¥æ€»ç»“

### 1. æµ‹è¯•èŒƒå›´é€‰æ‹©
- **å…³é”®è·¯å¾„**: æµ‹è¯•æ ¸å¿ƒä¸šåŠ¡æµç¨‹
- **å¤–éƒ¨ä¾èµ–**: æµ‹è¯•ä¸å¤–éƒ¨ç³»ç»Ÿçš„é›†æˆ
- **æ•°æ®ä¸€è‡´æ€§**: æµ‹è¯•æ•°æ®åœ¨ä¸åŒç»„ä»¶é—´çš„æµè½¬
- **é”™è¯¯å¤„ç†**: æµ‹è¯•å¼‚å¸¸æƒ…å†µçš„å¤„ç†

### 2. æµ‹è¯•ç¯å¢ƒç­–ç•¥
- **å®¹å™¨åŒ–**: ä½¿ç”¨Dockerå®¹å™¨ç¡®ä¿ç¯å¢ƒä¸€è‡´æ€§
- **æ¨¡æ‹ŸæœåŠ¡**: å¯¹äºéš¾ä»¥é›†æˆçš„å¤–éƒ¨æœåŠ¡ä½¿ç”¨æ¨¡æ‹Ÿ
- **æ•°æ®ç®¡ç†**: åˆç†ç®¡ç†æµ‹è¯•æ•°æ®çš„åˆ›å»ºå’Œæ¸…ç†

### 3. æµ‹è¯•æ‰§è¡Œç­–ç•¥
- **å¹¶è¡Œæ‰§è¡Œ**: æé«˜æµ‹è¯•æ‰§è¡Œæ•ˆç‡
- **åˆ†çº§æµ‹è¯•**: æ ¹æ®é‡è¦æ€§åˆ†çº§æ‰§è¡Œæµ‹è¯•
- **æŒç»­é›†æˆ**: é›†æˆåˆ°CI/CDæµç¨‹ä¸­

### 4. æµ‹è¯•ç»´æŠ¤ç­–ç•¥
- **å®šæœŸæ›´æ–°**: è·Ÿéšä¸šåŠ¡å˜åŒ–æ›´æ–°æµ‹è¯•
- **ç›‘æ§è¦†ç›–**: ç›‘æ§æµ‹è¯•è¦†ç›–ç‡
- **æ€§èƒ½ç›‘æ§**: å…³æ³¨æµ‹è¯•æ‰§è¡Œæ—¶é—´

é€šè¿‡åˆç†åº”ç”¨è¿™äº›ç­–ç•¥å’ŒæŠ€å·§ï¼Œå¯ä»¥æ„å»ºå‡ºç¨³å®šã€å¯é çš„é›†æˆæµ‹è¯•å¥—ä»¶ï¼Œç¡®ä¿Goåº”ç”¨ç¨‹åºçš„è´¨é‡å’Œå¯é æ€§ã€‚

*æœ€åæ›´æ–°: 2025å¹´9æœˆ*